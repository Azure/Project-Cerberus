// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef SECURITY_POLICY_H_
#define SECURITY_POLICY_H_

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include "status/rot_status.h"


/**
 * Provides information about the security properties applied to the device.
 */
struct security_policy {
	/**
	 * Indicate if the policy will survive a reset of the device or not.
	 *
	 * A persistent policy does not necessarily mean a permanent change to the device state.  In
	 * some cases, the device lifecycle can be irreversibly altered, generating a new policy.  In
	 * other cases, it could be a temporary alteration that deviates from the default behavior of
	 * the device.
	 *
	 * @param policy The security policy to query.
	 *
	 * @return 1 if the policy is persistent, 0 if not, or an error code.
	 */
	int (*is_persistent) (const struct security_policy *policy);

	/**
	 * Determine if the security policy requires that firmware signing be enforced by the device.
	 * The specifics of how this enforcement is implemented and which can be bypassed will vary.
	 *
	 * @param policy The security policy to query.
	 *
	 * @return 1 if the policy requires firmware signing, 0 if not, or an error code.
	 */
	int (*enforce_firmware_signing) (const struct security_policy *policy);

	/**
	 * Determine if the security policy requires that anti-rollback checks be enforced by the
	 * device.  The specifics of what anti-rollback checks exist and can be bypassed will vary.
	 *
	 * @param policy The security policy to query.
	 *
	 * @return 1 if the policy requires anti-rollback checks, 0 if not, or an error code.
	 */
	int (*enforce_anti_rollback) (const struct security_policy *policy);

	/**
	 * Indicate if an unlock policy would survive a reset of the device if applied.  This check is
	 * exclusively done against the specified unlock policy data.  It does not change the active
	 * security policy in any way, and the active security policy does not affect the result of this
	 * check.
	 *
	 * @param policy The policy handler to use for checking the unlock policy.
	 * @param unlock The unlock policy to check for persistence.
	 * @param length Length of the unlock policy data.
	 *
	 * @return 1 if the unlock policy is persistent, 0 if not, or an error code.
	 */
	int (*check_unlock_persistence) (const struct security_policy *policy, const uint8_t *unlock,
		size_t length);

	/**
	 * Parse an authenticated unlock policy and apply it as the current security policy.
	 *
	 * No validation or security checks are done against the unlock policy, aside from possibly
	 * checking structure of the data or presence of any required parameters.  Validity checks must
	 * be done prior to providing the unlock policy as the new security policy.
	 *
	 * @param policy The policy handler to update with the unlock policy.
	 * @param unlock The unlock policy to parse and apply.
	 * @param length Length of the unlock policy data.
	 *
	 * @return 0 if the unlock policy was successfully parsed or an error code.
	 */
	int (*parse_unlock_policy) (const struct security_policy *policy, const uint8_t *unlock,
		size_t length);
};


bool security_policy_enforce_firmware_signing (const struct security_policy *policy);
bool security_policy_enforce_anti_rollback (const struct security_policy *policy);


#define	SECURITY_POLICY_ERROR(code)		ROT_ERROR (ROT_MODULE_SECURITY_POLICY, code)

/**
 * Error codes that can be generated by a security policy.
 */
enum {
	SECURITY_POLICY_INVALID_ARGUMENT = SECURITY_POLICY_ERROR (0x00),			/**< Input parameter is null or not valid. */
	SECURITY_POLICY_NO_MEMORY = SECURITY_POLICY_ERROR (0x01),					/**< Memory allocation failed. */
	SECURITY_POLICY_PERSIST_CHECK_FAILED = SECURITY_POLICY_ERROR (0x02),		/**< Failed to determine policy persistence. */
	SECURITY_POLICY_FW_SIGNING_CHECK_FAILED = SECURITY_POLICY_ERROR (0x03),		/**< Failed to determine signature enforcement. */
	SECURITY_POLICY_ANTI_ROLLBACK_CHECK_FAILED = SECURITY_POLICY_ERROR (0x04),	/**< Failed to determine anti-rollback enforcement. */
	SECURITY_POLICY_PARSE_UNLOCK_FAILED = SECURITY_POLICY_ERROR (0x05),			/**< Failed to parse an unlock policy. */
	SECURITY_POLICY_SMALL_BUFFER = SECURITY_POLICY_ERROR (0x06),				/**< An output buffer is not large enough. */
	SECURITY_POLICY_IMMUTABLE = SECURITY_POLICY_ERROR (0x07),					/**< The security policy cannot be changed. */
	SECURITY_POLICY_BAD_DATA = SECURITY_POLICY_ERROR (0x08),					/**< The security policy data is not valid. */

	/* Error codes 0x80 and above are reserved for device-specific security policy errors. */
};


#endif	/* SECURITY_POLICY_H_ */
