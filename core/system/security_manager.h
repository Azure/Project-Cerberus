// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef SECURITY_MANAGER_H_
#define SECURITY_MANAGER_H_

#include <stdint.h>
#include <stddef.h>
#include "status/rot_status.h"
#include "system/security_policy.h"


/**
 * Provides the current security policy for the device execution context and handles any security
 * configuration required by the security policy.  As part of this, the application and removal of
 * unlock policies being applied to the device is managed.
 */
struct security_manager {
	/**
	 * Remove any stored unlock policy from the device and return to a secure configuration.  Device
	 * state will be altered to invalidate the policy from being reused.
	 *
	 * While the unlock policy has been removed, the device may continue running with the unlock
	 * policy until the next reset.
	 *
	 * @param manager The security manager to use for locking the device.
	 *
	 * @return 0 if the device was lock successfully or an error code.
	 */
	int (*lock_device) (const struct security_manager *manager);

	/**
	 * Apply an unlock policy to the device.  The policy must already have been checked for
	 * authorization.
	 *
	 * A valid unlock policy may or may not take effect immediately, depending on the policy being
	 * applied and the capabilities of the device.  Even for policies that won't activate until the
	 * device resets, the device state may be altered before then.
	 *
	 * @param manager The security manager to use for unlocking the device.
	 * @param policy The authenticated unlock policy to apply.  This will be the entire
	 * authorized unlock policy data, including the unlock token used to authorize the policy.
	 * @param length Length of the unlock policy data.
	 *
	 * @param 0 if the device was unlocked successfully or an error code.
	 */
	int (*unlock_device) (const struct security_manager *manager, const uint8_t *policy,
		size_t length);

	/**
	 * Get the current value of the persistent unlock anti-replay counter.
	 *
	 * @param manager The security manager to query.
	 * @param counter Output for the unlock counter value.
	 * @param length Length of the counter output buffer.
	 *
	 * @return Length of the unlock counter value or an error code.  Use ROT_IS_ERROR to check the
	 * return value.
	 */
	int (*get_unlock_counter) (const struct security_manager *manager, uint8_t *counter,
		size_t length);

	/**
	 * Determine if the current security policy includes any properties that are being overridden by
	 * an active unlock policy.
	 *
	 * @param manager The security manager to query.
	 *
	 * @return 1 if there is an active unlock policy, 0 if not, or an error code.
	 */
	int (*has_unlock_policy) (const struct security_manager *manager);

	/**
	 * Load the current security policy for the device.  This includes checking for any valid unlock
	 * policies that may override default policy settings.
	 *
	 * @param manager The security manager that will load the security policy.
	 *
	 * @return 0 if the security policy was successfully loaded or an error code.
	 */
	int (*load_security_policy) (const struct security_manager *manager);

	/**
	 * Apply a device configuration appropriate for the current security policy.
	 *
	 * Depending on the current policy and capabilities of the device, it may only be possible to
	 * apply a security configuration to the device once per boot.
	 *
	 * @param manager The security manager that will configure the device.
	 *
	 * @param 0 if the device was configured successfully or an error code.
	 */
	int (*apply_device_config) (const struct security_manager *manager);

	/**
	 * Private APIs for internal use.
	 */
	struct {
		/**
		 * Get the active security policy, if one exists.
		 *
		 * @param manager The security manager to query.
		 * @param policy Output for the active policy.  This will be null if the default policy
		 * should be used.
		 *
		 * @return 0 if the security policy was retrieved successfully or an error code.
		 */
		int (*get_security_policy) (const struct security_manager *manager,
			const struct security_policy **policy);
	} internal;
};


const struct security_policy* security_manager_get_security_policy (
	const struct security_manager *manager);


#define	SECURITY_MANAGER_ERROR(code)		ROT_ERROR (ROT_MODULE_SECURITY_MANAGER, code)

/**
 * Error codes that can be generated by a security policy manager.
 */
enum {
	SECURITY_MANAGER_INVALID_ARGUMENT = SECURITY_MANAGER_ERROR (0x00),		/**< Input parameter is null or not valid. */
	SECURITY_MANAGER_NO_MEMORY = SECURITY_MANAGER_ERROR (0x01),				/**< Memory allocation failed. */
	SECURITY_MANAGER_LOCK_FAILED = SECURITY_MANAGER_ERROR (0x02),			/**< Failed to lock the device. */
	SECURITY_MANAGER_UNLOCK_FAILED = SECURITY_MANAGER_ERROR (0x03),			/**< Failed to unlock the device. */
	SECURITY_MANAGER_GET_COUNTER_FAILED = SECURITY_MANAGER_ERROR (0x04),	/**< Failed to get the unlock counter value. */
	SECURITY_MANAGER_HAS_UNLOCK_FAILED = SECURITY_MANAGER_ERROR (0x05),		/**< Failed to query for an active unlock policy. */
	SECURITY_MANAGER_LOAD_FAILED = SECURITY_MANAGER_ERROR (0x06),			/**< Failed to load the active security policy. */
	SECURITY_MANAGER_CONFIG_FAILED = SECURITY_MANAGER_ERROR (0x07),			/**< Failed to apply the security configuration. */
	SECURITY_MANAGER_GET_POLICY_FAILED = SECURITY_MANAGER_ERROR (0x08),		/**< Failed to get the active security policy. */
	SECURITY_MANAGER_UNSUPPORTED = SECURITY_MANAGER_ERROR (0x09),			/**< The operation is not supported by the manager. */
	SECURITY_MANAGER_SMALL_COUNTER_BUFFER = SECURITY_MANAGER_ERROR (0x0a),	/**< Unlock counter buffer is too small. */
	SECURITY_MANAGER_UNALIGNED_ADDRESS = SECURITY_MANAGER_ERROR (0x0b),		/**< An address does not meet alignment requirements. */
	SECURITY_MANAGER_UNALIGNED_BUFFER = SECURITY_MANAGER_ERROR (0x0c),		/**< A buffer length does not meet alignment requirements. */
	SECURITY_MANAGER_SMALL_NONCE_BUFFER = SECURITY_MANAGER_ERROR (0x0d),	/**< A buffer for nonce management is too small. */
	SECURITY_MANAGER_BAD_UNLOCK_POLICY = SECURITY_MANAGER_ERROR (0x0e),		/**< A stored unlock policy failed verification. */
	SECURITY_MANAGER_BAD_DEVICE_STATE = SECURITY_MANAGER_ERROR (0x0f),		/**< The device state is not compatible with the operation. */
	SECURITY_MANAGER_COUNTER_MISMATCH = SECURITY_MANAGER_ERROR (0x10),		/**< The unlock counter is not the expected value. */
	SECURITY_MANAGER_NONCE_MISMATCH = SECURITY_MANAGER_ERROR (0x11),		/**< The policy nonce is not the expected value. */
	SECURITY_MANAGER_INVALID_COUNTER_VALUE = SECURITY_MANAGER_ERROR (0x12),	/**< The unlock counter is not a valid value. */
};


#endif /* SECURITY_MANAGER_H_ */
