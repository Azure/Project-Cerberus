// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef MPU_H_
#define MPU_H_

#include <stdint.h>
#include "status/rot_status.h"


/**
 * MPU page attributes
 */
enum {
	MPU_PAGE_ATTRIBUTE_READ = 0x1,		/**< MPU bit which enables read access */
	MPU_PAGE_ATTRIBUTE_WRITE = 0x2,		/**< MPU bit which enables write access */
	MPU_PAGE_ATTRIBUTE_EXECUTE = 0x4,	/**< MPU bit which enables execite access */
	MPU_PAGE_ATTRIBUTE_LOCKED = 0x8,	/**< MPU bit which lock this page for further attributes modification */
	MPU_PAGE_ATTRIBUTE_ALL = 0xF,		/**< Bitmask of all used MPU bits */
};

/**
 * MPU protection levels
 */
enum {
	MPU_PROTECTION_LEVEL_USER = 0x1,		/**< User (low) protection level  */
	MPU_PROTECTION_LEVEL_PRIVILEGE = 0x2,	/**< Privilege (high) protection level */
	MPU_PROTECTION_LEVEL_ALL = 0x3,			/**< All levels combination */
};

/**
 * MPU interface
 */
struct mpu_interface {
	/**
	 * get_page_size returns MPU supported memory page size
	 *
	 * @param mpu - MPU interface instance
	 * @param page_size - Output page size
	 *
	 * @return - 0 if successful, otherwise error code
	 */
	int (*get_page_size) (const struct mpu_interface *mpu, size_t *page_size);

	/**
	 * Sets MPU page attributes for each page inside given region. Region address must be valid
	 * and belong to valid hardware supported range. Region address must be aligned
	 * based on the page size returned by get_page_size(). Region size is also must be aligned
	 * based on page size.
	 *
	 * @param mpu - MPU interface instance
	 * @param region_address - region start address, must be aligned based on page size returned
	 * by get_page_size()
	 * @param region_size - region size, must be aligned by page size
	 * @param protection_level - requested protection level, multiple bit masks could be used.
	 * @param page_attributes - MPU page attributes bit mask
	 *
	 * @return - 0 if successful, error code otherwise
	 */
	int (*set_region_attributes) (const struct mpu_interface *mpu, const void *region_address,
		size_t region_size, uint32_t protection_level, uint32_t page_attributes);

	/**
	 * Query MPU attributes for an arbitrary memory address. This function will determine the
	 * validity of the address and will map it to the right page.
	 *
	 * @param mpu - MPU interface instance
	 * @param address - arbitrary memory address, must belong to a valid memory range
	 * controlled by MPU. Function will map it to the right page and fetch that page attributes.
	 * @param protection_level - protection level to query, must be a single bit
	 * @param page_attributes - Output for MPU page attributes to a given address
	 *
	 * @return - 0 if successful, error code otherwise
	 */
	int (*get_page_attributes) (const struct mpu_interface *mpu, const void *address,
		uint32_t protection_level, uint32_t *page_attributes);
};

#define MPU_ERROR(code)    ROT_ERROR (ROT_MODULE_MPU, code)

/**
 * Error codes that can be generated by the command handler.
 *
 * Note: Commented error codes have been deprecated.
 */
enum {
	MPU_INVALID_ARGUMENT = MPU_ERROR (0x00),				/**< Input parameter is null or not valid. */
	MPU_NO_MEMORY = MPU_ERROR (0x01),						/**< Memory allocation failed. */
	MPU_GET_PAGE_SIZE_FAILED = MPU_ERROR (0x02),			/**< Get page size failure */
	MPU_SET_REGION_ATTRIBUTES_FAILED = MPU_ERROR (0x03),	/**< Set region attributes failure */
	MPU_GET_PAGE_ATTRIBUTES_FAILED = MPU_ERROR (0x04),		/**< Get page attributes failure */
	MPU_UNALIGNED_ADDRESS = MPU_ERROR (0x05),				/**< MPU page address is unaligned */
	MPU_UNALIGNED_SIZE = MPU_ERROR (0x06),					/**< Region size is unaligned */
	MPU_UNSUPPORTED_ADDRESS = MPU_ERROR (0x07),				/**< Memory address is unsupported by current hardware */
	MPU_UNSUPPORTED_PROTECTION_LEVEL = MPU_ERROR (0x08),	/**< Unsupported protection level */
};


#endif	// MPU_H_
