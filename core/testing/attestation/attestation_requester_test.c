// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "platform_api.h"
#include "testing.h"
#include "attestation/attestation_logging.h"
#include "attestation/attestation_requester.h"
#include "attestation/attestation_requester_static.h"
#include "cmd_interface/cerberus_protocol_required_commands.h"
#include "cmd_interface/cmd_interface_system.h"
#include "cmd_interface/device_manager.h"
#include "common/array_size.h"
#include "common/unused.h"
#include "crypto/checksum.h"
#include "mctp/cmd_interface_mctp_control.h"
#include "mctp/mctp_control_protocol_commands.h"
#include "mctp/mctp_interface.h"
#include "spdm/cmd_interface_spdm.h"
#include "spdm/spdm_commands.h"
#include "spdm/spdm_measurements.h"
#include "spdm/spdm_protocol.h"
#include "testing/mock/asn1/x509_mock.h"
#include "testing/mock/attestation/attestation_responder_mock.h"
#include "testing/mock/cmd_interface/cmd_channel_mock.h"
#include "testing/mock/cmd_interface/cmd_background_mock.h"
#include "testing/mock/cmd_interface/cmd_authorization_mock.h"
#include "testing/mock/cmd_interface/cmd_device_mock.h"
#include "testing/mock/crypto/ecc_mock.h"
#include "testing/mock/crypto/rsa_mock.h"
#include "testing/mock/crypto/hash_mock.h"
#include "testing/mock/crypto/rng_mock.h"
#include "testing/mock/firmware/firmware_update_control_mock.h"
#include "testing/mock/keystore/keystore_mock.h"
#include "testing/mock/logging/logging_mock.h"
#include "testing/mock/manifest/cfm/cfm_manager_mock.h"
#include "testing/mock/manifest/cfm/cfm_mock.h"
#include "testing/engines/x509_testing_engine.h"
#include "testing/asn1/x509_testing.h"
#include "testing/logging/debug_log_testing.h"
#include "testing/riot/riot_core_testing.h"


TEST_SUITE_LABEL ("attestation_requester");


static struct riot_keys keys = {
	.devid_cert = RIOT_CORE_DEVID_CERT,
	.devid_cert_length = 0,
	.devid_csr = NULL,
	.devid_csr_length = 0,
	.alias_key = RIOT_CORE_ALIAS_KEY,
	.alias_key_length = 0,
	.alias_cert = RIOT_CORE_ALIAS_CERT,
	.alias_cert_length = 0
};

static uint8_t cert_buffer[SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER + 1];

static uint8_t pmr_id_list[1] = {0};

/**
 * List of FW version strings.
 */
const char *fw_ver_list[1];

/**
 * Dependencies for testing the attestation requester.
 */
struct attestation_requester_testing {
	struct attestation_requester test;							/**< Attestation manager instance. */
	struct attestation_requester_state state;					/**< Attestation manager variable context. */
	struct hash_engine_mock primary_hash;						/**< Primary hash engine mock */
	struct hash_engine_mock secondary_hash;						/**< Secondary hash engine mock */
	struct ecc_engine_mock ecc;									/**< ECC engine mock */
	struct rsa_engine_mock rsa;									/**< RSA engine mock */
	struct x509_engine_mock x509_mock;							/**< X509 engine mock */
	X509_TESTING_ENGINE x509;									/**< X.509 engine for the RIoT keys. */
	struct rng_engine_mock rng;									/**< RNG engine mock */
	struct riot_key_manager riot;								/**< RIoT key manager */
	struct keystore_mock keystore;								/**< Keystore mock */
	struct cmd_channel_mock channel;							/**< Command channel mock */
	struct firmware_update_control_mock fw_update;				/**< FW update control mock */
	struct cmd_background_mock background;						/**< Command background mock */
	struct cmd_authorization_mock authorization;				/**< Command authorization mock */
	struct cmd_device_mock device;								/**< Command device mock */
	struct attestation_responder_mock attestation_responder;	/**< Attestation responder mock */
	struct cfm_manager_mock cfm_manager;						/**< CFM manager mock */
	struct cfm_mock cfm;										/**< CFM mock */
	struct device_manager device_mgr;							/**< Device manager instance */
	struct mctp_interface mctp;									/**< MCTP interface instance */
	struct cmd_interface_fw_version fw_version;					/**< The firmware version data. */
	struct cmd_interface_system cmd_cerberus;					/**< Cerberus command interface */
	struct cmd_interface_mctp_control cmd_mctp;					/**< MCTP command interface */
	struct cmd_interface_spdm cmd_spdm;							/**< SPDM command interface */
	struct pcr_store store;										/**< PCR store instance */
	const uint8_t *cert[3];										/**< Certificate to use in response. */
	size_t cert_buffer_len;										/**< Length of certificates in cert_buffer. */
	size_t cert_len[3];											/**< Certificate length to use in response */
	uint8_t hash_len[2];										/**< Hash length to use during testing */
	uint8_t cert_num;											/**< Certificate number to use in attestation request/response */
	uint8_t slot_num[3];										/**< Slot number to use in attestation request/response */
	uint8_t slot_mask;											/**< Slot mask to use in attestation request/response */
	uint8_t msg_tag;											/**< Message tag to utilize in attestation request/response */
	uint8_t min_protocol_version;								/**< Minimum protocol version to use in attestation response */
	uint8_t max_protocol_version;								/**< Maximum protocol version to use in attestation response */
	uint8_t spdm_version;										/**< SPDM minor version to use */
	uint8_t spdm_min_version;									/**< SPDM minimum minor version to use */
	uint8_t spdm_max_version;									/**< SPDM maximum minor version to use */
	uint8_t spdm_alpha_version;									/**< SPDM alpha version to use */
	uint8_t discovery_id_missing;								/**< Select PCI ID to leave out of response */
	uint8_t rsp_not_ready_request;								/**< Request code of request that should respond with response not ready */
	uint8_t *dev_id_der;										/**< Buffer to hold RIoT device ID certificate */
	uint8_t *ca_der;											/**< Buffer to hold RIoT root CA certificate */
	uint8_t *int_der;											/**< Buffer to hold RIoT intermediate CA certificate */
	bool version_unsupported;									/**< Flag indicating whether target doesn't support same protocol version as requestor */
	bool get_cert_unsupported;									/**< Flag indicating whether target doesn't support get certificate command */
	bool challenge_unsupported;									/**< Flag indicating whether target doesn't support challenge command */
	bool meas_cap_unsupported;									/**< Flag indicating whether target doesn't support measurement capabilities */
	bool meas_cap_sign_unsupported;								/**< Flag indicating whether target support measurement capabilities with signature */
	bool measurement_spec_unsupported;							/**< Flag indicating whether target doesn't support DMTF measurement spec */
	bool asymmetric_key_signature_alg_unsupported;				/**< Flag indicating whether target doesn't support expected asymmetric key signature algorithms  */
	bool asymmetric_key_signature_alg_mismatched;				/**< Flag indicating whether target doesn't support expected asymmetric key signature algorithms  */
	bool rsp_len_invalid[2];									/**< Flag indicating whether target sends response with invalid length */
	bool unsupported_operation;									/**< Flag indicating whether target requests unsupported operation */
	bool expected_slot_num_empty;								/**< Flag indicating whether target sends response with empty expected slot number */
	bool cert_chain_digest_compare_fail;						/**< Flag indicating whether target sends incorrect cert chain digest */
	bool second_response[2];									/**< Flag indicating whether response is second in a transaction. */
	bool raw_rsp[2];											/**< Flag indicating whether to return response with raw measurement data */
	bool get_all_blocks;										/**< Flag indicating whether to return all measurement blocks in response */
	bool measurement_modify;									/**< Flag indicating whether to modify measurement byte 0 */
	bool digest_instead_of_raw;									/**< Flag indicating whether to respond with a digest instead of raw measurement data */
	bool num_blocks_incorrect;									/**< Flag indicating whether to respond with incorrect number of blocks */
	bool unexpected_measurement_block;							/**< Flag indicating whether to respond with unexpected measurement block */
	bool rsp_fail;												/**< Flag indicating whether to respond with a failure command code */
	bool cerberus_discovery;									/**< Flag indicating whether to perform Cerberus device discovery */
	bool spdm_discovery;										/**< Flag indicating whether to perform SPDM device discovery */
	bool device_id_block_short;									/**< Flag indicating whether SPDM device ID measurement block contains all IDs */
	bool device_id_fail;										/**< Flag indicating whether SPDM device ID measurement block contains failure completion code */
	bool cert_rsp_too_large;									/**< Flag indicating whether certificate response will be larger than expected */
	bool multiple_devices;										/**< Flag indicating test is for multiple devices */
	bool second_device;											/**< Flag indicating test is processing second device */
	bool multiple_cert_calls;									/**< Flag indicating test expects multiple get cert responses */
	bool get_num_indices;										/**< Flag indicating measurement response includes number of measurement block indices */
	uint32_t hashing_alg_requested;								/**< Hashing algorithm source device requests */
	uint32_t hashing_alg_supported;								/**< Hashing algorithm target device supports */
	uint32_t meas_hashing_alg_requested;						/**< Measurement hashing algorithm source device requests */
	uint32_t meas_hashing_alg_supported;						/**< Measurement hashing algorithm target device supports */
	size_t max_cert_buffer_portion;								/**< Maximum certificate buffer portion length */
};


/**
 * Helper function to add an intermediate and root CA to RIoT key manager cert chain
 *
 * @param test The test framework.
 * @param testing Testing instances to utilize.
 */
static void attestation_requester_testing_add_certs_to_riot_key_manager (CuTest *test,
	struct attestation_requester_testing *testing)
{
	int status;

	testing->dev_id_der = platform_malloc (RIOT_CORE_DEVID_SIGNED_CERT_LEN);
	CuAssertPtrNotNull (test, testing->dev_id_der);

	testing->ca_der = platform_malloc (X509_CERTSS_RSA_CA_NOPL_DER_LEN);
	CuAssertPtrNotNull (test, testing->ca_der);

	testing->int_der = platform_malloc (X509_CERTCA_ECC_CA_NOPL_DER_LEN);
	CuAssertPtrNotNull (test, testing->int_der);

	memcpy (testing->dev_id_der, RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN);
	memcpy (testing->ca_der, X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN);
	memcpy (testing->int_der, X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN);

	status = mock_expect (&testing->keystore.mock, testing->keystore.base.load_key,
		&testing->keystore, 0, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&testing->keystore.mock, 1, &testing->dev_id_der,
		sizeof (testing->dev_id_der), -1);
	status |= mock_expect_output (&testing->keystore.mock, 2, &RIOT_CORE_DEVID_SIGNED_CERT_LEN,
		sizeof (RIOT_CORE_DEVID_SIGNED_CERT_LEN), -1);
	status |= mock_expect (&testing->keystore.mock, testing->keystore.base.load_key,
		&testing->keystore, 0, MOCK_ARG (1), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&testing->keystore.mock, 1, &testing->ca_der,
		sizeof (testing->ca_der), -1);
	status |= mock_expect_output (&testing->keystore.mock, 2, &X509_CERTSS_RSA_CA_NOPL_DER_LEN,
		sizeof (X509_CERTSS_RSA_CA_NOPL_DER_LEN), -1);
	status |= mock_expect (&testing->keystore.mock, testing->keystore.base.load_key,
		&testing->keystore, 0, MOCK_ARG (2), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&testing->keystore.mock, 1, &testing->int_der,
		sizeof (testing->int_der), -1);
	status |= mock_expect_output (&testing->keystore.mock, 2, &X509_CERTCA_ECC_CA_NOPL_DER_LEN,
		sizeof (X509_CERTCA_ECC_CA_NOPL_DER_LEN), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.load_certificate,
		&testing->x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 4);
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.init_ca_cert_store,
		&testing->x509_mock, 0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 5);
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_root_ca,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (5),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN));
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_intermediate_ca,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (5),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN));
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_intermediate_ca,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (5),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT,	RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN));
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.authenticate,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (4),	MOCK_ARG_SAVED_ARG (5));
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.release_ca_cert_store,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (5));
	status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.release_certificate,
		&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (4));
	CuAssertIntEquals (test, 0, status);

	status = riot_key_manager_verify_stored_certs (&testing->riot);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Helper function to setup the attestation manager for testing
 *
 * @param test The test framework
 * @param testing The testing instances to initialize
 * @param init_attestation Boolean flag indicating whether to call attestation_requester_init
 * @param no_mctp_bridge Boolean flag indicating whether to add an MCTP bridge entry to the device
 * 	manager
 * @param x509_mock Boolean flag indicating whether to use a mock x509 or mbedtls x509 engine
 */
static void setup_attestation_requester_mock_test (CuTest *test,
	struct attestation_requester_testing *testing, bool init_attestation, bool no_mctp_bridge,
	bool x509_mock)
{
	const struct pcr_config pcr_config[2] = {
		{
			.num_measurements = 6,
			.measurement_algo = HASH_TYPE_SHA256
		},
		{
			.num_measurements = 6,
			.measurement_algo = HASH_TYPE_SHA256
		}
	};
	struct x509_engine *x509;
	int status;

	memset (testing, 0, sizeof (struct attestation_requester_testing));

	testing->cert_buffer_len = sizeof (struct spdm_certificate_chain);
	testing->max_protocol_version = 255;
	testing->spdm_version = 2;
	testing->spdm_min_version = 1;
	testing->spdm_max_version = 2;

	status = hash_mock_init (&testing->primary_hash);
	CuAssertIntEquals (test, 0, status);
	mock_set_name (&testing->primary_hash.mock, "primary hash");

	status = hash_mock_init (&testing->secondary_hash);
	CuAssertIntEquals (test, 0, status);
	mock_set_name (&testing->secondary_hash.mock, "secondary hash");

	status = ecc_mock_init (&testing->ecc);
	CuAssertIntEquals (test, 0, status);

	status = rsa_mock_init (&testing->rsa);
	CuAssertIntEquals (test, 0, status);

	status = x509_mock_init (&testing->x509_mock);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&testing->rng);
	CuAssertIntEquals (test, 0, status);

	status = keystore_mock_init (&testing->keystore);
	CuAssertIntEquals (test, 0, status);

	status = cmd_channel_mock_init (&testing->channel, 0);
	CuAssertIntEquals (test, 0, status);

	status = firmware_update_control_mock_init (&testing->fw_update);
	CuAssertIntEquals (test, 0, status);

	status = attestation_responder_mock_init (&testing->attestation_responder);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&testing->store, pcr_config, ARRAY_SIZE (pcr_config));
	CuAssertIntEquals (test, 0, status);

	status = cmd_background_mock_init (&testing->background);
	CuAssertIntEquals (test, 0, status);

	status = cmd_authorization_mock_init (&testing->authorization);
	CuAssertIntEquals (test, 0, status);

	status = cmd_device_mock_init (&testing->device);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_mock_init (&testing->cfm_manager);
	CuAssertIntEquals (test, 0, status);

	status = cfm_mock_init (&testing->cfm);
	CuAssertIntEquals (test, 0, status);

	status = X509_TESTING_ENGINE_INIT (&testing->x509);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing->keystore.mock, testing->keystore.base.load_key,
		&testing->keystore, KEYSTORE_NO_KEY, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing->keystore.mock, 1, &testing->dev_id_der,
		sizeof (testing->dev_id_der), -1);
	CuAssertIntEquals (test, 0, status);

	keys.alias_cert_length = RIOT_CORE_ALIAS_CERT_LEN;
	keys.devid_cert_length = RIOT_CORE_DEVID_CERT_LEN;
	keys.alias_key_length = RIOT_CORE_ALIAS_KEY_LEN;

	if (x509_mock) {
		x509 = &testing->x509_mock.base;
	}
	else {
		x509 = &testing->x509.base;
	}

	status = riot_key_manager_init_static (&testing->riot, &testing->keystore.base, &keys, x509);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_init (&testing->device_mgr, 1, !no_mctp_bridge, !no_mctp_bridge,
		DEVICE_MANAGER_PA_ROT_MODE, DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE, 10, 10, 10, 10, 0, 0,
		0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing->device_mgr, 0,
		MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0);
	CuAssertIntEquals (test, 0, status);

	if (!no_mctp_bridge) {
		status = device_manager_update_not_attestable_device_entry (&testing->device_mgr, 1, 0x0A,
			0x20, 1);
		CuAssertIntEquals (test, 0, status);

		status = device_manager_update_device_state (&testing->device_mgr, 1,
			DEVICE_MANAGER_UNIDENTIFIED);
		CuAssertIntEquals (test, 0, status);
	}

	status = device_manager_add_unidentified_device (&testing->device_mgr, 0x0A);
	CuAssertIntEquals (test, 0, status);

	fw_ver_list[0] = "1.1.1.1";
	testing->fw_version.count = 1;
	testing->fw_version.id = fw_ver_list;

	status = cmd_interface_system_init (&testing->cmd_cerberus, &testing->fw_update.base, NULL,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, &testing->attestation_responder.base,
		&testing->device_mgr, &testing->store, &testing->primary_hash.base,
		&testing->background.base, NULL, NULL, &testing->fw_version, &testing->riot,
		&testing->authorization.base, NULL, NULL, NULL,	NULL, NULL, NULL, &testing->device.base, 1,
		2, 3, 4, NULL);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_init (&testing->cmd_mctp, &testing->device_mgr, 0x1414, 4);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_init (&testing->cmd_spdm);
	CuAssertIntEquals (test, 0, status);

	status = mctp_interface_init (&testing->mctp, &testing->cmd_cerberus.base,
		&testing->cmd_mctp.base, &testing->cmd_spdm.base, &testing->device_mgr);
	CuAssertIntEquals (test, 0, status);

	if (init_attestation) {
		status = attestation_requester_init (&testing->test, &testing->state, &testing->mctp,
			&testing->channel.base,	&testing->primary_hash.base, &testing->secondary_hash.base,
			&testing->ecc.base, NULL, &testing->x509.base, &testing->rng.base, &testing->riot,
			&testing->device_mgr, &testing->cfm_manager.base);
		CuAssertIntEquals (test, 0, status);

		status = cmd_interface_system_add_cerberus_protocol_observer (&testing->cmd_cerberus,
			&testing->test.cerberus_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cmd_interface_spdm_add_spdm_protocol_observer (&testing->cmd_spdm,
			&testing->test.spdm_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cmd_interface_mctp_control_add_mctp_control_protocol_observer (&testing->cmd_mctp,
			&testing->test.mctp_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cfm_manager_add_observer (&testing->cfm_manager.base, &testing->test.cfm_observer);
		CuAssertIntEquals (test, 0, status);
	}
}

/**
 * Helper function to setup the attestation manager for attestation testing
 *
 * @param test The test framework
 * @param testing The testing instances to initialize
 * @param init_attestation Boolean flag indicating whether to call attestation_requester_init
 * @param riot_no_root_ca Boolean flag indicating whether to initialize RIoT keystore with a root CA
 * @param rsa Boolean flag indicating whether RSA is to be supported
 * @param x509_mock Boolean flag indicating whether to use a mock x509 or mbedtls x509 engine
 * @param sha256 Boolean flag indicating whether to use sha256
 * @param component_id Component ID to use
 */
static void setup_attestation_requester_mock_attestation_test (CuTest *test,
	struct attestation_requester_testing *testing, bool init_attestation, bool riot_no_root_ca,
	bool rsa, bool x509_mock, enum hash_type hash_algo, enum hash_type meas_hash_algo,
	enum cfm_attestation_type attestation_protocol, uint8_t slot_id, uint32_t component_id)
{
	struct cfm_component_device component_device;
	struct x509_engine *x509;
	int status;

	component_device.attestation_protocol = attestation_protocol;
	component_device.cert_slot = slot_id;
	component_device.component_id = component_id;
	component_device.num_pmr_ids = 1;
	component_device.pmr_id_list = pmr_id_list;
	component_device.measurement_hash_type = meas_hash_algo;
	component_device.transcript_hash_type = hash_algo;

	setup_attestation_requester_mock_test (test, testing, false, false, x509_mock);

	if (x509_mock) {
		x509 = &testing->x509_mock.base;
	}
	else {
		x509 = &testing->x509.base;
	}

	testing->max_cert_buffer_portion = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	if (hash_algo == HASH_TYPE_SHA256) {
		memset (testing->hash_len, SHA256_HASH_LENGTH, sizeof (testing->hash_len));
		testing->hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
		testing->hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
		testing->cert_buffer_len += SHA256_HASH_LENGTH;
	}
	else if (hash_algo == HASH_TYPE_SHA384) {
		memset (testing->hash_len, SHA384_HASH_LENGTH, sizeof (testing->hash_len));
		testing->hashing_alg_requested = SPDM_TPM_ALG_SHA_384;
		testing->hashing_alg_supported = SPDM_TPM_ALG_SHA_384;
		testing->cert_buffer_len += SHA384_HASH_LENGTH;
	}
	else {
		memset (testing->hash_len, SHA512_HASH_LENGTH, sizeof (testing->hash_len));
		testing->hashing_alg_requested = SPDM_TPM_ALG_SHA_512;
		testing->hashing_alg_supported = SPDM_TPM_ALG_SHA_512;
		testing->cert_buffer_len += SHA512_HASH_LENGTH;
	}

	if (meas_hash_algo == HASH_TYPE_SHA256) {
		testing->meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
		testing->meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	} else if (meas_hash_algo == HASH_TYPE_SHA384) {
		testing->meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_384;
		testing->meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_384;
	} else {
		testing->meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_512;
		testing->meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_512;
	}

	if (!riot_no_root_ca) {
		memcpy (&cert_buffer[testing->cert_buffer_len], X509_CERTSS_RSA_CA_NOPL_DER,
			X509_CERTSS_RSA_CA_NOPL_DER_LEN);

		testing->cert_buffer_len += X509_CERTSS_RSA_CA_NOPL_DER_LEN;
	}
	else {
		memcpy (&cert_buffer[testing->cert_buffer_len], X509_CERTSS_ECC_CA_NOPL_DER,
			X509_CERTSS_ECC_CA_NOPL_DER_LEN);

		testing->cert_buffer_len += X509_CERTSS_ECC_CA_NOPL_DER_LEN;
	}

	memcpy (&cert_buffer[testing->cert_buffer_len], RIOT_CORE_DEVID_SIGNED_CERT,
		RIOT_CORE_DEVID_SIGNED_CERT_LEN);

	testing->cert_buffer_len += RIOT_CORE_DEVID_SIGNED_CERT_LEN;

	memcpy (&cert_buffer[testing->cert_buffer_len], RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN);

	testing->cert_buffer_len += RIOT_CORE_ALIAS_CERT_LEN;

	if (!riot_no_root_ca) {
		attestation_requester_testing_add_certs_to_riot_key_manager (test, testing);
	}

	status = device_manager_update_mctp_bridge_device_entry (&testing->device_mgr, 1, 0xAA, 0xBB,
		0xCC, 0xDD,	1, component_id, 1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_device_state (&testing->device_mgr, 1,
		DEVICE_MANAGER_READY_FOR_ATTESTATION);
	CuAssertIntEquals (test, 0, status);

	if (init_attestation) {
		status = mock_expect (&testing->cfm_manager.mock, testing->cfm_manager.base.get_active_cfm,
			&testing->cfm_manager, MOCK_RETURN_PTR (&testing->cfm.base));
		status |= mock_expect (&testing->cfm_manager.mock, testing->cfm_manager.base.free_cfm,
			&testing->cfm_manager, 0, MOCK_ARG_PTR (&testing->cfm.base));
		CuAssertIntEquals (test, 0, status);

		status = mock_expect (&testing->cfm.mock, testing->cfm.base.get_component_device,
			&testing->cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
		status |= mock_expect_output_tmp (&testing->cfm.mock, 1, &component_device,
			sizeof (struct cfm_component_device), -1);
		status |= mock_expect_save_arg (&testing->cfm.mock, 1, 0);
		status |= mock_expect (&testing->cfm.mock, testing->cfm.base.free_component_device,
			&testing->cfm, 0, MOCK_ARG_SAVED_ARG (0));
		CuAssertIntEquals (test, 0, status);

		if (rsa) {
			status = attestation_requester_init (&testing->test, &testing->state, &testing->mctp,
				&testing->channel.base, &testing->primary_hash.base, &testing->secondary_hash.base,
				&testing->ecc.base, &testing->rsa.base, x509, &testing->rng.base, &testing->riot,
				&testing->device_mgr, &testing->cfm_manager.base);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = attestation_requester_init (&testing->test, &testing->state, &testing->mctp,
				&testing->channel.base,	&testing->primary_hash.base, &testing->secondary_hash.base,
				&testing->ecc.base, NULL, x509, &testing->rng.base, &testing->riot,
				&testing->device_mgr, &testing->cfm_manager.base);
			CuAssertIntEquals (test, 0, status);
		}

		status = cmd_interface_system_add_cerberus_protocol_observer (&testing->cmd_cerberus,
			&testing->test.cerberus_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cmd_interface_spdm_add_spdm_protocol_observer (&testing->cmd_spdm,
			&testing->test.spdm_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cmd_interface_mctp_control_add_mctp_control_protocol_observer (&testing->cmd_mctp,
			&testing->test.mctp_rsp_observer);
		CuAssertIntEquals (test, 0, status);

		status = cfm_manager_add_observer (&testing->cfm_manager.base, &testing->test.cfm_observer);
		CuAssertIntEquals (test, 0, status);
	}
}

/**
 * Helper function to release attestation testing instances
 *
 * @param test The test framework
 * @param testing The instances to release
 * @param release_attestation Boolean flag indicating whether to call attestation_requester_deinit
 */
static void complete_attestation_requester_mock_test (CuTest *test,
	struct attestation_requester_testing *testing, bool release_attestation)
{
	int status;

	if (release_attestation) {
		attestation_requester_deinit (&testing->test);
	}

	status = hash_mock_validate_and_release (&testing->primary_hash);
	status |= hash_mock_validate_and_release (&testing->secondary_hash);
	status |= ecc_mock_validate_and_release (&testing->ecc);
	status |= rsa_mock_validate_and_release (&testing->rsa);
	status |= rng_mock_validate_and_release (&testing->rng);
	status |= keystore_mock_validate_and_release (&testing->keystore);
	status |= cmd_channel_mock_validate_and_release (&testing->channel);
	status |= cmd_background_mock_validate_and_release (&testing->background);
	status |= cmd_authorization_mock_validate_and_release (&testing->authorization);
	status |= cmd_device_mock_validate_and_release (&testing->device);
	status |= firmware_update_control_mock_validate_and_release (&testing->fw_update);
	status |= cfm_manager_mock_validate_and_release (&testing->cfm_manager);
	status |= cfm_mock_validate_and_release (&testing->cfm);
	status |= attestation_responder_mock_validate_and_release (&testing->attestation_responder);

	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_system_remove_cerberus_protocol_observer (&testing->cmd_cerberus,
		&testing->test.cerberus_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_remove_spdm_protocol_observer (&testing->cmd_spdm,
		&testing->test.spdm_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	pcr_store_release (&testing->store);
	cmd_interface_spdm_deinit (&testing->cmd_spdm);
	cmd_interface_mctp_control_deinit (&testing->cmd_mctp);
	cmd_interface_system_deinit (&testing->cmd_cerberus);
	riot_key_manager_release (&testing->riot);
	device_manager_release (&testing->device_mgr);
	mctp_interface_deinit (&testing->mctp);

	status = x509_mock_validate_and_release (&testing->x509_mock);
	CuAssertIntEquals (test, 0, status);

	X509_TESTING_ENGINE_RELEASE (&testing->x509);
}

/**
 * Generate packets for full MCTP message from payload
 *
 * @param buf Buffer with payload bytes at beginning, to be filled with generated packets
 * @param payload_len Length of payload bytes
 * @param max_buf_len Maximum length of buf
 * @param dest_eid EID to address packets to
 * @param dest_addr SMBus address to address packets to
 * @param src_eid EID of source device
 * @param src_addr SMBus address of source device
 * @param msg_tag MCTP message tag to utilize
 * @param tag_owner MCTP tag owner to utilize
 *
 * @return Generated MCTP message length
 */
static size_t attestation_requester_testing_generate_mctp_packets_from_payload (uint8_t *buf,
	size_t payload_len, size_t max_buf_len, uint8_t dest_eid, uint8_t dest_addr, uint8_t src_eid,
	uint8_t src_addr, uint8_t msg_tag, uint8_t tag_owner)
{
	uint8_t *payload;
	uint8_t packet_seq = 0;
	size_t packet_payload_len;
	size_t i_payload = 0;
	size_t i_buf = 0;
	bool som = true;
	bool eom = false;
	int status;

	payload = &buf[max_buf_len - payload_len];

	memcpy (payload, buf, payload_len);

	while (payload_len > 0) {
		if (payload_len > MCTP_BASE_PROTOCOL_MAX_TRANSMISSION_UNIT) {
			packet_payload_len = MCTP_BASE_PROTOCOL_MAX_TRANSMISSION_UNIT;
		}
		else {
			packet_payload_len = payload_len;
			eom = true;
		}

		status = mctp_base_protocol_construct (&payload[i_payload], packet_payload_len, &buf[i_buf],
			max_buf_len - i_buf, src_addr, dest_eid, src_eid, som, eom, packet_seq, msg_tag,
			tag_owner, dest_addr);

		i_buf += status;
		i_payload += packet_payload_len;
		payload_len -= packet_payload_len;

		som = false;
		packet_seq = (packet_seq + 1) % 4;
	}

	return i_buf;
}

/**
 * Callback function which generates and processes a Cerberus protocol error response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_cerberus_error_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_error *error_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0F;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	error_response = (struct cerberus_protocol_error*) &rx_packet.data[offset];
	error_response->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	error_response->header.pci_vendor_id = 0x1414;
	error_response->header.command = CERBERUS_PROTOCOL_ERROR;

	offset += sizeof (struct cerberus_protocol_error);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a Cerberus protocol Get Device capabilities
 * response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_cerberus_device_capabilities_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_device_capabilities_response *capabilities_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x14;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	capabilities_response =
		(struct cerberus_protocol_device_capabilities_response*) &rx_packet.data[offset];
	capabilities_response->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	capabilities_response->header.pci_vendor_id = 0x1414;
	capabilities_response->header.command = CERBERUS_PROTOCOL_GET_DEVICE_CAPABILITIES;

	offset += sizeof (struct cerberus_protocol_device_capabilities_response);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a Cerberus protocol Get Digest response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_cerberus_get_digest_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_get_certificate_digest_response *digest_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;
	size_t i;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0C + testing->hash_len[0] * 3;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	digest_response =
		(struct cerberus_protocol_get_certificate_digest_response*) &rx_packet.data[offset];
	digest_response->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	digest_response->header.pci_vendor_id = 0x1414;
	digest_response->header.command = CERBERUS_PROTOCOL_GET_DIGEST;

	digest_response->num_digests = 3;

	offset += sizeof (struct cerberus_protocol_get_certificate_digest_response);

	for (i = 0; i < (testing->hash_len[0] * 3); ++i) {
		rx_packet.data[offset + i] = i;
	}

	offset += (testing->hash_len[0] * 3);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a Cerberus protocol Get Certificate response
 * message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_cerberus_get_certificate_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	uint8_t msg[MCTP_BASE_PROTOCOL_MAX_MESSAGE_LEN] = {0};
	struct attestation_requester_testing *testing = expected->context;
	struct cerberus_protocol_get_certificate_response *cert_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t payload_len;
	size_t packet_len;
	size_t offset = 0;
	size_t msg_len;
	uint8_t msg_tag = testing->msg_tag;

	++testing->msg_tag;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	cert_response = (struct cerberus_protocol_get_certificate_response*) msg;
	cert_response->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	cert_response->header.pci_vendor_id = 0x1414;
	cert_response->header.command = CERBERUS_PROTOCOL_GET_CERTIFICATE;

	cert_response->slot_num = testing->slot_num[1];
	cert_response->cert_num = testing->cert_num;

	payload_len = sizeof (struct cerberus_protocol_get_certificate_response);

	memcpy (&msg[payload_len], testing->cert[testing->cert_num],
		testing->cert_len[testing->cert_num]);

	payload_len += testing->cert_len[testing->cert_num];

	testing->cert_num = testing->cert_num + 1;

	msg_len = attestation_requester_testing_generate_mctp_packets_from_payload (msg, payload_len,
		sizeof (msg), MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0x0A, 0x20, msg_tag,
		MCTP_BASE_PROTOCOL_TO_RESPONSE);

	while (offset < msg_len) {
		if ((msg_len - offset) > MCTP_BASE_PROTOCOL_MAX_PACKET_LEN) {
			packet_len = MCTP_BASE_PROTOCOL_MAX_PACKET_LEN;
		}
		else {
			packet_len = msg_len - offset;
		}

		memcpy (rx_packet.data, &msg[offset], packet_len);

		rx_packet.pkt_size = packet_len;
		rx_packet.state = CMD_VALID_PACKET;
		rx_packet.dest_addr = 0x41;
		rx_packet.timeout_valid = false;

		mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

		offset += packet_len;
	}

	return 0;
}

/**
 * Callback function which generates and processes a Cerberus protocol Challenge response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_cerberus_challenge_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_challenge_response *challenge_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;
	size_t i;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x37 + testing->hash_len[1];
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	challenge_response =
		(struct cerberus_protocol_challenge_response*) &rx_packet.data[offset];
	challenge_response->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	challenge_response->header.pci_vendor_id = 0x1414;
	challenge_response->header.command = CERBERUS_PROTOCOL_ATTESTATION_CHALLENGE;

	challenge_response->challenge.slot_num = testing->slot_num[2];
	challenge_response->challenge.min_protocol_version = testing->min_protocol_version;
	challenge_response->challenge.max_protocol_version = testing->max_protocol_version;
	challenge_response->challenge.digests_size = testing->hash_len[1];

	for (i = 0; i < sizeof (challenge_response->challenge.nonce); ++i) {
		challenge_response->challenge.nonce[i] = i * 2;
	}

	offset += sizeof (struct cerberus_protocol_challenge_response);

	for (i = 0; i < testing->hash_len[1]; ++i) {
		rx_packet.data[offset + i] = i * 3;
	}

	offset += testing->hash_len[1];

	for (i = 0; i < 5; ++i) {
		rx_packet.data[offset + i] = i * 10;
	}

	offset += 5;

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Setup mock send and receive Cerberus protocol Get Device Capabilities transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_cerberus_device_capabilities (
	CuTest *test, bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_device_capabilities *request;
	int status = 0;
	size_t offset;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x12;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct cerberus_protocol_device_capabilities*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	request->header.pci_vendor_id = 0x1414;
	request->header.command = CERBERUS_PROTOCOL_GET_DEVICE_CAPABILITIES;

	request->capabilities.max_message_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	request->capabilities.max_packet_size = MCTP_BASE_PROTOCOL_MAX_TRANSMISSION_UNIT;
	request->capabilities.security_mode = DEVICE_MANAGER_SECURITY_AUTHENTICATION;
	request->capabilities.bus_role = DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE;
	request->capabilities.hierarchy_role = DEVICE_MANAGER_PA_ROT_MODE;

	offset += sizeof (struct cerberus_protocol_device_capabilities);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = ATTESTATION_RIOT_SLOT_NUM;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_device_capabilities_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Setup mock send and receive Cerberus protocol Get Digest transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param hash_len Hashing algorithm length to use in Get Digest transaction.
 * @param msg_tag Message tag to utilize in request/response.
 * @param slot_num Slot number to utilize in request.
 * @param key_alg Asymmetric key signing algorithm to utilize in request.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_cerberus_get_digest (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t hash_len, uint8_t msg_tag,
	uint8_t slot_num, uint8_t key_alg, struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_get_certificate_digest *request;
	int status = 0;
	size_t offset;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0C;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct cerberus_protocol_get_certificate_digest*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	request->header.pci_vendor_id = 0x1414;
	request->header.command = CERBERUS_PROTOCOL_GET_DIGEST;

	request->slot_num = slot_num;
	request->key_alg = key_alg;

	offset += sizeof (struct cerberus_protocol_get_certificate_digest);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = slot_num;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			testing->hash_len[0] = hash_len;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_digest_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Setup mock send and receive Cerberus protocol Get Certificate transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param unexpected_slot_num Flag indicating whether to use an unexpected slot number in response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param slot_num Slot number to utilize in request.
 * @param cert_num Certificate number to utilize in request.
 * @param cert Certificate to receive in response.
 * @param cert_len Certificate length to receive in response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_cerberus_get_certificate (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, bool unexpected_slot_num, uint8_t msg_tag,
	uint8_t slot_num, uint8_t cert_num, const uint8_t *cert, size_t cert_len,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_get_certificate *request;
	int status = 0;
	size_t offset;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x10;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct cerberus_protocol_get_certificate*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	request->header.pci_vendor_id = 0x1414;
	request->header.command = CERBERUS_PROTOCOL_GET_CERTIFICATE;

	request->slot_num = slot_num;
	request->cert_num = cert_num;
	request->offset = 0;
	request->length = 0;

	offset += sizeof (struct cerberus_protocol_get_certificate);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_digest_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			testing->cert[cert_num] = cert;
			testing->cert_len[cert_num] = cert_len;
			testing->slot_num[1] = unexpected_slot_num ? (slot_num + 1) : slot_num;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Setup mock send and receive Cerberus protocol Challenge transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param unexpected_slot_num Flag indicating whether to use an unexpected slot number in response.
 * @param unexpected_hash_len Flag indicating whether to use an unexpected hash length in response.
 * @param unexpected_min_protocol_version Flag indicating whether to use an unexpected minimum
 * protocol version in response.
 * @param unexpected_max_protocol_version Flag indicating whether to use an unexpected maximum
 * protocol version in response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param slot_num Slot number to utilize in request.
 * @param hash_update_result Completion code of hash update of attestation challenge request.
 * @param hash_update_rsp_result Completion code of hash update of attestation challenge response.
 * @param hash_finish_result Completion code of hash finish of attestation challenge.
 * @param init_pub_key_result Completion code of public key init as part of attestation challenge.
 * @param verify_result Completion code of signature verify as part of attestation challenge.
 * @param ecc Flag indicating whether to use an ECC or RSA alias key.
 * @param rsa Flag indicating whether attestation requester supports RSA.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_cerberus_challenge (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, bool unexpected_slot_num,
	bool unexpected_hash_len, bool unexpected_min_protocol_version,
	bool unexpected_max_protocol_version, uint8_t msg_tag, uint8_t slot_num, int hash_update_result,
	int hash_update_rsp_result, int hash_finish_result, int init_pub_key_result, int verify_result,
	bool ecc, bool rsa_not_supported, struct attestation_requester_testing *testing)
{
	bool rsp_successful = get_rsp && !rsp_fail && !unexpected_rsp && !unexpected_slot_num &&
		!unexpected_hash_len && !unexpected_min_protocol_version &&
		!unexpected_max_protocol_version && (hash_update_result == 0);
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct cerberus_protocol_challenge *request;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t signature[5];
	size_t offset;
	size_t i;
	int status;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x2C;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct cerberus_protocol_challenge*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	request->header.pci_vendor_id = 0x1414;
	request->header.command = CERBERUS_PROTOCOL_ATTESTATION_CHALLENGE;

	request->challenge.slot_num = slot_num;

	for (i = 0; i < sizeof (request->challenge.nonce); ++i) {
		request->challenge.nonce[i] = 255 - i;
	}

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = 50 - i;
	}

	offset += sizeof (struct cerberus_protocol_challenge);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.start_sha256,
		&testing->primary_hash, 0);
	status |= mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.update,
		&testing->primary_hash, hash_update_result,	MOCK_ARG_PTR_CONTAINS_TMP (
			&tx_packet.data[sizeof (struct mctp_base_protocol_transport_header) +
				sizeof (struct cerberus_protocol_header)],
			sizeof (struct attestation_challenge)),
			MOCK_ARG (sizeof (struct attestation_challenge)));
	if (!rsp_successful) {
		status |= mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.cancel,
			&testing->primary_hash, 0);
	}
	else {
		status |= mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.update,
			&testing->primary_hash,	hash_update_rsp_result, MOCK_ARG_NOT_NULL, MOCK_ARG_ANY);

		if (hash_update_rsp_result == 0) {
			status |= mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.finish,
				&testing->primary_hash,	hash_finish_result, MOCK_ARG_NOT_NULL,
				MOCK_ARG (HASH_MAX_HASH_LEN));
			status |= mock_expect_output_tmp (&testing->primary_hash.mock, 0, digest,
				sizeof (digest), -1);
		}
		if ((hash_update_rsp_result != 0) || (hash_finish_result != 0)) {
			status |= mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.cancel,
				&testing->primary_hash,	0);
		}
	}
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing->rng.mock, testing->rng.base.generate_random_buffer,
		&testing->rng, 0, MOCK_ARG (ATTESTATION_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing->rng.mock, 1, request->challenge.nonce,
		sizeof (request->challenge.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	if (hash_update_result != 0) {
		return;
	}

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0, MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet,
		sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_digest_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			testing->slot_num[2] = unexpected_slot_num ? (slot_num + 1) : slot_num;
			testing->hash_len[1] = unexpected_hash_len ? SHA384_HASH_LENGTH : SHA256_HASH_LENGTH;
			testing->min_protocol_version = unexpected_min_protocol_version ? 5 : 0;
			testing->max_protocol_version = unexpected_max_protocol_version ? 3 : 4;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_challenge_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}

	if (rsp_successful & (hash_update_rsp_result == 0) && (hash_finish_result == 0)) {
		for (i = 0; i < 5; ++i) {
			signature[i] = i * 10;
		}

		if (ecc) {
			status = mock_expect (&testing->ecc.mock, testing->ecc.base.init_public_key,
				&testing->ecc, init_pub_key_result,
				MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
				MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);

			if (init_pub_key_result == 0) {
				status |= mock_expect_save_arg (&testing->ecc.mock, 2, 0);
				status |= mock_expect (&testing->ecc.mock, testing->ecc.base.verify, &testing->ecc,
					verify_result, MOCK_ARG_SAVED_ARG (0),
					MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
					MOCK_ARG (SHA256_HASH_LENGTH),
					MOCK_ARG_PTR_CONTAINS_TMP (signature, sizeof (signature)), MOCK_ARG (5));
				status |= mock_expect (&testing->ecc.mock, testing->ecc.base.release_key_pair,
					&testing->ecc, 0, MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
			}
		}
		else if (!rsa_not_supported) {
			status = mock_expect (&testing->rsa.mock, testing->rsa.base.init_public_key,
				&testing->rsa, init_pub_key_result, MOCK_ARG_NOT_NULL,
				MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
					RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
				MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN));

			if (init_pub_key_result == 0) {
				status |= mock_expect_save_arg (&testing->rsa.mock, 0, 0);
				status |= mock_expect (&testing->rsa.mock, testing->rsa.base.sig_verify,
					&testing->rsa, verify_result, MOCK_ARG_SAVED_ARG (0),
					MOCK_ARG_PTR_CONTAINS_TMP (signature, sizeof (signature)), MOCK_ARG (5),
					MOCK_ARG (HASH_TYPE_SHA256),
					MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
					MOCK_ARG (SHA256_HASH_LENGTH));
			}
		}

		CuAssertIntEquals (test, 0, status);
	}
}

/**
 * Helper function which sends and receives a successful Cerberus Protocol Get Digest, and sets up
 * hashing mock.
 *
 * @param test Testing framework to utilize
 * @param testing Instances to utilize
 * @param msg_tag Message tag to utilize
 */
static void attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (
	CuTest *test, struct attestation_requester_testing *testing, uint8_t msg_tag)
{
	uint8_t digest[SHA256_HASH_LENGTH * 3];
	uint8_t out_digest[SHA256_HASH_LENGTH];
	size_t i_digest;
	int status;

	attestation_requester_testing_send_and_receive_cerberus_get_digest (test, true, false, false,
		SHA256_HASH_LENGTH, msg_tag, ATTESTATION_RIOT_SLOT_NUM, ATTESTATION_ECDHE_KEY_EXCHANGE,
		testing);

	for (i_digest = 0; i_digest < sizeof (digest); ++i_digest) {
		digest[i_digest] = i_digest;
	}

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest + 50;
	}

	status = mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.calculate_sha256,
		&testing->primary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (SHA256_HASH_LENGTH * 3), MOCK_ARG_NOT_NULL, MOCK_ARG (SHA256_HASH_LENGTH));
	status = mock_expect_output_tmp (&testing->primary_hash.mock, 2, out_digest,
		sizeof (out_digest), -1);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Helper function which sends and receives a successful Cerberus Protocol Get Certificate, and sets
 * up hashing mock.
 *
 * @param test Testing framework to utilize
 * @param testing Instances to utilize
 * @param ecc Flag indicating whether to use an ECC or RSA alias key
 * @param x509_mock Flag indicating an x509 mock is used
 * @param msg_tag Message tag to utilize
 * @param riot_no_root_ca Cerberus does not have RIoT root CA
 * @param vendor_root_ca CFM includes vendor root CA
 * @param ca_digests Buffer to use as root CA digests
 * @param component_id Component ID to use
 */
static void attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (
	CuTest *test, struct attestation_requester_testing *testing, bool ecc, bool x509_mock,
	uint8_t msg_tag, bool riot_no_root_ca, bool vendor_root_ca, uint8_t *ca_digests,
	uint32_t component_id)
{
	struct cfm_root_ca_digests root_ca_digests;
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	const uint8_t *root_cert = (riot_no_root_ca || vendor_root_ca) ? X509_CERTSS_ECC_CA_NOPL_DER :
		X509_CERTSS_RSA_CA_NOPL_DER;
	uint8_t *pub_key;
	size_t root_cert_len = (riot_no_root_ca || vendor_root_ca) ? X509_CERTSS_ECC_CA_NOPL_DER_LEN :
		X509_CERTSS_RSA_CA_NOPL_DER_LEN;
	size_t i_digest;
	int key_type = ecc ? X509_PUBLIC_KEY_ECC : X509_PUBLIC_KEY_RSA;
	int status;

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest + 50;
	}

	if (ca_digests != NULL) {
		for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
			ca_digests[SHA256_HASH_LENGTH + i_digest] = 0x0a + i_digest;
		}
	}

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, msg_tag, ATTESTATION_RIOT_SLOT_NUM, 0, root_cert, root_cert_len, testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, msg_tag + 1, ATTESTATION_RIOT_SLOT_NUM, 1, RIOT_CORE_DEVID_SIGNED_CERT,
		RIOT_CORE_DEVID_SIGNED_CERT_LEN, testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, msg_tag + 2, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_ALIAS_CERT,
		RIOT_CORE_ALIAS_CERT_LEN, testing);

	if (vendor_root_ca) {
		status = mock_expect (&testing->cfm.mock, testing->cfm.base.get_root_ca_digest,
			&testing->cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
		status |= mock_expect_output_tmp (&testing->cfm.mock, 1, &root_ca_digests,
			sizeof (struct cfm_root_ca_digests), -1);
		status |= mock_expect (&testing->cfm.mock, testing->cfm.base.free_root_ca_digest,
			&testing->cfm, 0,
			MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
		CuAssertIntEquals (test, 0, status);

		status = mock_expect (&testing->primary_hash.mock,
			testing->primary_hash.base.calculate_sha256, &testing->primary_hash, 0,
			MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
			MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
			MOCK_ARG (HASH_MAX_HASH_LEN));
		status |= mock_expect_output_tmp (&testing->primary_hash.mock, 2,
			&ca_digests[SHA256_HASH_LENGTH], SHA256_HASH_LENGTH, -1);
		CuAssertIntEquals (test, 0, status);
	}
	else {
		status = mock_expect (&testing->cfm.mock, testing->cfm.base.get_root_ca_digest,
			&testing->cfm, CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
		CuAssertIntEquals (test, 0, status);
	}

	if (x509_mock) {
		pub_key = platform_malloc (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);
		CuAssertPtrNotNull (test, pub_key);

		memcpy (pub_key, RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);

		status = mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.init_ca_cert_store,
			&testing->x509_mock, 0, MOCK_ARG_NOT_NULL);
		status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 0);

		if (riot_no_root_ca || vendor_root_ca) {
			status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_root_ca,
				&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
				MOCK_ARG_PTR_CONTAINS (root_cert, root_cert_len),
				MOCK_ARG (root_cert_len + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
					RIOT_CORE_ALIAS_CERT_LEN));
		}
		else {
			status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_root_ca,
				&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
				MOCK_ARG_PTR_CONTAINS (root_cert, root_cert_len), MOCK_ARG (root_cert_len));
		}

		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.add_intermediate_ca, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT,
				RIOT_CORE_DEVID_SIGNED_CERT_LEN),
			MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN + RIOT_CORE_ALIAS_CERT_LEN));
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.load_certificate,
			&testing->x509_mock, 0, MOCK_ARG_NOT_NULL,
			MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
			MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
		status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 1);
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.authenticate,
			&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.get_public_key_type, &testing->x509_mock, key_type,
			MOCK_ARG_SAVED_ARG (1));
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.get_public_key,
			&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
		status |= mock_expect_output_tmp (&testing->x509_mock.mock, 1, &pub_key, sizeof (pub_key),
			-1);
		status |= mock_expect_output (&testing->x509_mock.mock, 2,
			&RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
			sizeof (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), -1);
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.release_certificate, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (1));
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.release_ca_cert_store, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (0));
		CuAssertIntEquals (test, 0, status);
	}

	status = mock_expect (&testing->primary_hash.mock, testing->primary_hash.base.calculate_sha256,
		&testing->primary_hash, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG (root_cert_len + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing->primary_hash.mock, 2, out_digest,
		sizeof (out_digest), -1);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Callback function which generates and processes a SPDM protocol error response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_error_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_error_response *error_response;
	struct spdm_error_response_not_ready *rsp_not_ready;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0A + ((testing->rsp_not_ready_request != 0) ? 4 : 0);
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	error_response = (struct spdm_error_response*) &rx_packet.data[offset];

	error_response->header.spdm_minor_version = testing->spdm_version;
	error_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	error_response->header.req_rsp_code = SPDM_RESPONSE_ERROR;

	offset += sizeof (struct spdm_error_response);

	if (testing->rsp_not_ready_request != 0) {
		error_response->error_code = SPDM_ERROR_RESPONSE_NOT_READY;

		rsp_not_ready = (struct spdm_error_response_not_ready*) &rx_packet.data[offset];

		rsp_not_ready->token = 1;
		rsp_not_ready->rdt_exponent = 10;
		rsp_not_ready->rdtm = 20;
		rsp_not_ready->request_code = testing->rsp_not_ready_request;

		offset += sizeof (struct spdm_error_response_not_ready);
	}

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Get Version response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_get_version_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_version_response *version_response;
	struct spdm_version_num_entry *version_table;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t num_entries = testing->spdm_max_version - testing->spdm_min_version + 1;
	size_t offset;
	size_t i;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0C + num_entries * sizeof (struct spdm_version_num_entry);
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	version_response = (struct spdm_get_version_response*) &rx_packet.data[offset];

	version_response->header.spdm_minor_version = 0;
	version_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	version_response->header.req_rsp_code = SPDM_RESPONSE_GET_VERSION;

	version_response->version_num_entry_count = num_entries;

	offset += sizeof (struct spdm_get_version_response);
	version_table = (struct spdm_version_num_entry*) &rx_packet.data[offset];

	for (i = 0; i < num_entries; ++i, ++version_table) {
		version_table->major_version = SPDM_MAJOR_VERSION + testing->version_unsupported;
		version_table->minor_version = i + testing->spdm_min_version;
		version_table->alpha = testing->spdm_alpha_version;
	}

	offset += (sizeof (struct spdm_version_num_entry) * num_entries);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Get Capabilities response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_get_capabilities_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_capabilities *capabilities_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = (testing->spdm_version >= 2)? 0x1A : 0x12;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	capabilities_response = (struct spdm_get_capabilities*) &rx_packet.data[offset];

	capabilities_response->base_capabilities.header.spdm_minor_version = testing->spdm_version;
	capabilities_response->base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	capabilities_response->base_capabilities.header.req_rsp_code = SPDM_RESPONSE_GET_CAPABILITIES;

	capabilities_response->base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	capabilities_response->base_capabilities.flags.cache_cap = 0;
	capabilities_response->base_capabilities.flags.cert_cap = !testing->get_cert_unsupported;
	capabilities_response->base_capabilities.flags.chal_cap = !testing->challenge_unsupported;
	capabilities_response->base_capabilities.flags.meas_cap =
		(testing->meas_cap_unsupported ? 0 : (testing->meas_cap_sign_unsupported ? 1 : 2));
	capabilities_response->base_capabilities.flags.meas_fresh_cap = 0;
	capabilities_response->base_capabilities.flags.encrypt_cap = 0;
	capabilities_response->base_capabilities.flags.mac_cap = 0;
	capabilities_response->base_capabilities.flags.mut_auth_cap = 0;
	capabilities_response->base_capabilities.flags.key_ex_cap = 0;
	capabilities_response->base_capabilities.flags.psk_cap = 0;
	capabilities_response->base_capabilities.flags.encap_cap = 0;
	capabilities_response->base_capabilities.flags.hbeat_cap = 0;
	capabilities_response->base_capabilities.flags.key_upd_cap = 0;
	capabilities_response->base_capabilities.flags.handshake_in_the_clear_cap =	0;
	capabilities_response->base_capabilities.flags.pub_key_id_cap = 0;

	if (testing->spdm_version >= 2) {
		capabilities_response->data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		capabilities_response->max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		offset += sizeof (struct spdm_get_capabilities);
	}
	else {
		offset += sizeof (struct spdm_get_capabilities_1_1);
	}

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Negotiate Algorithms response
 * message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_negotiate_algorithms_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_negotiate_algorithms_response *algorithms_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x2A;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	algorithms_response = (struct spdm_negotiate_algorithms_response*) &rx_packet.data[offset];

	algorithms_response->header.spdm_minor_version = testing->spdm_version;
	algorithms_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	algorithms_response->header.req_rsp_code = SPDM_RESPONSE_NEGOTIATE_ALGORITHMS;

	algorithms_response->num_alg_structure_tables = 0;
	algorithms_response->length = sizeof (struct spdm_negotiate_algorithms_response);
	algorithms_response->measurement_specification = testing->measurement_spec_unsupported ?
		(SPDM_MEASUREMENT_SPEC_DMTF + 1) : SPDM_MEASUREMENT_SPEC_DMTF;
	algorithms_response->base_asym_sel = testing->asymmetric_key_signature_alg_unsupported ?
		0 : (testing->asymmetric_key_signature_alg_mismatched ?
			SPDM_TPM_ALG_RSASSA_2048 : SPDM_TPM_ALG_ECDSA_ECC_NIST_P256);
	algorithms_response->base_hash_sel = testing->hashing_alg_supported;
	algorithms_response->measurement_hash_algo = testing->meas_hashing_alg_supported;

	offset += sizeof (struct spdm_negotiate_algorithms_response);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Get Digests response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_get_digests_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	const size_t hash_len_multiplier = testing->slot_mask ?
			common_math_get_num_bits_set (testing->slot_mask) : 1;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_digests_response *digests_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t hash_len;
	size_t offset;
	size_t i;

	UNUSED (called);

	if (testing->rsp_len_invalid[0]) {
		hash_len = 0;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH * hash_len_multiplier;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH * hash_len_multiplier;
	}
	else {
		hash_len = SHA512_HASH_LENGTH * hash_len_multiplier;
	}

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0A + hash_len;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	digests_response = (struct spdm_get_digests_response*) &rx_packet.data[offset];

	digests_response->header.spdm_minor_version = testing->spdm_version;
	digests_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	digests_response->header.req_rsp_code = SPDM_RESPONSE_GET_DIGESTS;

	if (testing->slot_mask) {
		digests_response->slot_mask = testing->slot_mask;
	}
	else {
		digests_response->slot_mask = 1;
	}

	offset += sizeof (struct spdm_get_digests_response);

	for (i = 0; i < hash_len; ++i, ++offset) {
		rx_packet.data[offset] = i + (testing->second_response[0] && testing->multiple_devices);
	}

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Get Certificate response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_get_certificate_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	uint8_t msg[MCTP_BASE_PROTOCOL_MAX_MESSAGE_LEN] = {0};
	struct attestation_requester_testing *testing = expected->context;
	struct spdm_protocol_mctp_header *mctp = (struct spdm_protocol_mctp_header*) msg;
	struct spdm_get_certificate_response *certificate_response =
		(struct spdm_get_certificate_response*) &msg[sizeof (*mctp)];
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t cert_buffer_offset = (testing->second_response[0] && testing->multiple_cert_calls) ?
		testing->max_cert_buffer_portion : 0;
	size_t length = testing->cert_buffer_len - cert_buffer_offset;
	size_t payload_len;
	size_t packet_len;
	size_t offset = 0;
	size_t msg_len;
	uint8_t eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C: 0x0A;
	uint8_t msg_tag = testing->msg_tag;

	length = (length > testing->max_cert_buffer_portion) ?
		testing->max_cert_buffer_portion : length;

	if (testing->cert_rsp_too_large && testing->second_response[0]) {
		length += 1;
	}

	++testing->msg_tag;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	certificate_response->header.spdm_minor_version = testing->spdm_version;
	certificate_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	certificate_response->header.req_rsp_code = SPDM_RESPONSE_GET_CERTIFICATE;

	certificate_response->slot_num = testing->slot_num[0];
	certificate_response->portion_len = length;
	certificate_response->remainder_len = testing->cert_buffer_len -
		(cert_buffer_offset + certificate_response->portion_len);

	payload_len = sizeof (struct spdm_protocol_mctp_header) +
		sizeof (struct spdm_get_certificate_response);

	memcpy (&msg[payload_len], &cert_buffer[cert_buffer_offset], length);

	payload_len += length;

	testing->second_response[0] = !testing->second_response[0];

	msg_len = attestation_requester_testing_generate_mctp_packets_from_payload (msg, payload_len,
		sizeof (msg), MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, eid, 0x20, msg_tag,
		MCTP_BASE_PROTOCOL_TO_RESPONSE);

	while (offset < msg_len) {
		if ((msg_len - offset) > MCTP_BASE_PROTOCOL_MAX_PACKET_LEN) {
			packet_len = MCTP_BASE_PROTOCOL_MAX_PACKET_LEN;
		}
		else {
			packet_len = msg_len - offset;
		}

		memcpy (rx_packet.data, &msg[offset], packet_len);

		rx_packet.pkt_size = packet_len;
		rx_packet.state = CMD_VALID_PACKET;
		rx_packet.dest_addr = 0x41;
		rx_packet.timeout_valid = false;

		mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

		offset += packet_len;
	}

	return 0;
}

/**
 * Callback function which generates and processes a SPDM protocol Challenge response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_challenge_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_challenge_response *challenge_response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	uint16_t *opaque_length;
	size_t hash_len;
	size_t offset;
	size_t i;
	bool second_rsp = testing->second_response[1] && testing->multiple_devices;
	int status;

	testing->second_response[1] = !testing->second_response[1];

	UNUSED (called);

	if (testing->rsp_len_invalid[1]) {
		hash_len = 0;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH;
	}
	else {
		hash_len = SHA512_HASH_LENGTH;
	}

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x71 + 2 * hash_len;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = second_rsp ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &rx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	challenge_response = (struct spdm_challenge_response*) &rx_packet.data[offset];

	challenge_response->header.spdm_minor_version = testing->spdm_version;
	challenge_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	challenge_response->header.req_rsp_code = SPDM_RESPONSE_CHALLENGE;

	challenge_response->slot_num = testing->slot_num[1];
	challenge_response->basic_mutual_auth_req = testing->unsupported_operation;
	if (testing->slot_num[1]) {
		challenge_response->slot_mask = testing->slot_mask;
	}
	else {
		challenge_response->slot_mask = 1 << testing->expected_slot_num_empty;
	}

	offset += sizeof (struct spdm_challenge_response);

	for (i = 0; i < hash_len; ++i, ++offset) {
		rx_packet.data[offset] = i + testing->cert_chain_digest_compare_fail + second_rsp;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rx_packet.data[offset] = SPDM_NONCE_LEN - i;
	}

	for (i = 0; i < hash_len; ++i, ++offset) {
		rx_packet.data[offset] = 50 + i;
	}

	opaque_length = (uint16_t*) &rx_packet.data[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rx_packet.data[offset] = 5 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i, ++offset) {
		rx_packet.data[offset] = i * 10;
	}

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	status = mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return status;
}

/**
 * Callback function which generates and processes a SPDM protocol Get Measurements response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_spdm_get_measurements_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	uint8_t msg[MCTP_BASE_PROTOCOL_MAX_MESSAGE_LEN] = {0};
	struct attestation_requester_testing *testing = expected->context;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_measurements_response *measurements_response;
	struct spdm_measurements_block_header *block;
	struct spdm_measurements_device_id_block *device_id_block;
	struct spdm_measurements_device_id_descriptor *device_id_descriptor;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	uint16_t *opaque_length;
	uint16_t *id;
	size_t hash_len;
	size_t offset = 0;
	size_t i;
	size_t num_blocks_in_rsp = (testing->get_all_blocks | testing->num_blocks_incorrect) ? 2 : 1;
	size_t block_len;
	size_t device_id_len;
	size_t msg_len;
	size_t payload_len = 0;
	size_t packet_len;

	UNUSED (called);

	if (testing->meas_hashing_alg_supported == SPDM_MEAS_RSP_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH;
	}
	else if (testing->meas_hashing_alg_supported == SPDM_MEAS_RSP_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH;
	}
	else {
		hash_len = SHA512_HASH_LENGTH;
	}

	memset (&rx_packet, 0, sizeof (rx_packet));

	device_id_len = sizeof (struct spdm_measurements_device_id_block) +
		(sizeof (struct spdm_measurements_device_id_descriptor) + sizeof (uint16_t)) *
		(4 - testing->device_id_block_short);

	block_len = testing->spdm_discovery ? spdm_measurements_block_size (device_id_len) :
		num_blocks_in_rsp * spdm_measurements_block_size (hash_len);

	if (testing->get_num_indices) {
		block_len = 0;
	}

	mctp = (struct spdm_protocol_mctp_header*) msg;
	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;
	payload_len += sizeof (*mctp);

	measurements_response = (struct spdm_get_measurements_response*) &msg[sizeof (*mctp)];
	measurements_response->header.spdm_minor_version = testing->spdm_version;
	measurements_response->header.spdm_major_version = SPDM_MAJOR_VERSION;
	measurements_response->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	if (testing->get_num_indices) {
		measurements_response->slot_id = 0;
		measurements_response->num_measurement_indices = 5;
		measurements_response->number_of_blocks = 0;
		measurements_response->measurement_record_len[0] = 0;

		testing->get_num_indices = false;

		payload_len += sizeof (struct spdm_get_measurements_response);
	}
	else {
		measurements_response->slot_id = testing->slot_num[1];
		measurements_response->num_measurement_indices = 0;
		measurements_response->number_of_blocks = num_blocks_in_rsp;
		measurements_response->measurement_record_len[0] = block_len;

		payload_len += sizeof (struct spdm_get_measurements_response);
		block =	(struct spdm_measurements_block_header*) &msg[payload_len];
		payload_len += sizeof (struct spdm_measurements_block_header);

		if (!testing->spdm_discovery) {
			if (!testing->second_response[1]) {
				block->index = 1 + testing->unexpected_measurement_block;
				block->measurement_size = sizeof (struct spdm_measurements_block_dmtf) + hash_len;
				block->measurement_specification = 1;
				block->dmtf.measurement_block_type = 0;
				block->dmtf.measurement_size = hash_len;
				block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw & testing->raw_rsp[0];

				for (i = 0; i < hash_len; ++i, ++payload_len) {
					msg[payload_len] = 50 + i + testing->raw_rsp[0];

					if ((i == 0) && (testing->measurement_modify)) {
						msg[payload_len] = 0xCC;
					}
				}

				if (testing->get_all_blocks | testing->num_blocks_incorrect) {
					block =	(struct spdm_measurements_block_header*) &msg[payload_len];
					payload_len += sizeof (struct spdm_measurements_block_header);

					block->index = 2 + testing->unexpected_measurement_block;
					block->measurement_size =
						sizeof (struct spdm_measurements_block_dmtf) + hash_len;
					block->measurement_specification = 1;
					block->dmtf.measurement_block_type = 0;
					block->dmtf.measurement_size = hash_len;
					block->dmtf.raw_bit_stream =
						!testing->digest_instead_of_raw & testing->raw_rsp[0];

					for (i = 0; i < hash_len; ++i, ++payload_len) {
						msg[payload_len] = 100 - i + testing->raw_rsp[0];
					}
				}
			}
			else {
				block->index = 2 + testing->unexpected_measurement_block;
				block->measurement_size = sizeof (struct spdm_measurements_block_dmtf) + hash_len;
				block->measurement_specification = 1;
				block->dmtf.measurement_block_type = 0;
				block->dmtf.measurement_size = hash_len;
				block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw & testing->raw_rsp[1];

				for (i = 0; i < hash_len; ++i, ++payload_len) {
					msg[payload_len] = 100 - i + testing->raw_rsp[1];
				}
			}
		}
		else {
			block->index = (testing->spdm_version == 1) ? 5 : 0xEF;
			block->measurement_size = device_id_len +
				sizeof (struct spdm_measurements_block_dmtf);
			block->measurement_specification = 1;
			block->dmtf.measurement_block_type = 3;
			block->dmtf.measurement_size = device_id_len;
			block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw;

			device_id_block =
				(struct spdm_measurements_device_id_block*) &msg[payload_len];
			device_id_block->completion_code = testing->device_id_fail;
			device_id_block->descriptor_count = 4 - testing->device_id_block_short;
			device_id_block->device_id_len = block->dmtf.measurement_size -
				sizeof (struct spdm_measurements_device_id_block);
			payload_len += sizeof (struct spdm_measurements_device_id_block);

			device_id_descriptor =
				(struct spdm_measurements_device_id_descriptor*) &msg[payload_len];
			payload_len += sizeof (struct spdm_measurements_device_id_descriptor);

			device_id_descriptor->descriptor_len = sizeof (uint16_t);
			device_id_descriptor->descriptor_type = (testing->discovery_id_missing != 1) ?
				SPDM_MEASUREMENTS_DEVICE_ID_PCI_VID :
				SPDM_MEASUREMENTS_DEVICE_ID_IANA_ENTERPRISE_ID;

			id = (uint16_t*) &msg[payload_len];
			*id = (testing->second_response[0] && testing->multiple_devices) ? 0xAB : 0xAA;
			payload_len += 2;

			device_id_descriptor =
				(struct spdm_measurements_device_id_descriptor*) &msg[payload_len];
			payload_len += sizeof (struct spdm_measurements_device_id_descriptor);

			device_id_descriptor->descriptor_len = sizeof (uint16_t);
			device_id_descriptor->descriptor_type = (testing->discovery_id_missing != 2) ?
				SPDM_MEASUREMENTS_DEVICE_ID_PCI_DEVICE_ID :
				SPDM_MEASUREMENTS_DEVICE_ID_IANA_ENTERPRISE_ID;

			id = (uint16_t*) &msg[payload_len];
			*id = (testing->second_response[0] && testing->multiple_devices) ? 0xBC : 0xBB;
			payload_len += 2;

			device_id_descriptor =
				(struct spdm_measurements_device_id_descriptor*) &msg[payload_len];
			payload_len += sizeof (struct spdm_measurements_device_id_descriptor);

			device_id_descriptor->descriptor_len = sizeof (uint16_t);
			device_id_descriptor->descriptor_type = (testing->discovery_id_missing != 3) ?
				SPDM_MEASUREMENTS_DEVICE_ID_PCI_SUBSYSTEM_VID :
				SPDM_MEASUREMENTS_DEVICE_ID_IANA_ENTERPRISE_ID;

			id = (uint16_t*) &msg[payload_len];
			*id = (testing->second_response[0] && testing->multiple_devices) ? 0xCD : 0xCC;
			payload_len += 2;

			if (!testing->device_id_block_short) {
				device_id_descriptor =
					(struct spdm_measurements_device_id_descriptor*) &msg[payload_len];
				payload_len += sizeof (struct spdm_measurements_device_id_descriptor);

				device_id_descriptor->descriptor_len = sizeof (uint16_t);
				device_id_descriptor->descriptor_type = (testing->discovery_id_missing != 4) ?
					SPDM_MEASUREMENTS_DEVICE_ID_PCI_SUBSYSTEM_ID :
					SPDM_MEASUREMENTS_DEVICE_ID_IANA_ENTERPRISE_ID;

				id = (uint16_t*) &msg[payload_len];
				*id = (testing->second_response[0] && testing->multiple_devices) ? 0xDE : 0xDD;
				payload_len += 2;
			}
		}
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++payload_len) {
		msg[payload_len] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &msg[payload_len];
	*opaque_length = testing->spdm_discovery ? 0 : 5;
	payload_len += 2;

	if (!testing->spdm_discovery) {
		for (i = 0; i < *opaque_length; ++i, ++payload_len) {
			msg[payload_len] = 5 + i;
		}

		for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i, ++payload_len) {
			msg[payload_len] = i * 10;

			if (testing->second_response[1]) {
				msg[payload_len] -= 1;
			}
		}
	}

	msg_len = attestation_requester_testing_generate_mctp_packets_from_payload (msg, payload_len,
		sizeof (msg), MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41,
		(testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A, 0x20,
		testing->msg_tag, MCTP_BASE_PROTOCOL_TO_RESPONSE);

	while (offset < msg_len) {
		if ((msg_len - offset) > MCTP_BASE_PROTOCOL_MAX_PACKET_LEN) {
			packet_len = MCTP_BASE_PROTOCOL_MAX_PACKET_LEN;
		}
		else {
			packet_len = msg_len - offset;
		}

		memcpy (rx_packet.data, &msg[offset], packet_len);

		rx_packet.pkt_size = packet_len;
		rx_packet.state = CMD_VALID_PACKET;
		rx_packet.dest_addr = 0x41;
		rx_packet.timeout_valid = false;

		mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

		offset += packet_len;
	}

	testing->second_response[0] = !testing->second_response[0];
	testing->second_response[1] = !testing->second_response[1];

	++testing->msg_tag;

	return 0;
}

/**
 * Callback function which generates and processes a MCTP protocol Get Message Type response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_mctp_get_message_type_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct mctp_control_get_message_type_response *response;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0B + testing->cerberus_discovery + testing->spdm_discovery;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = (testing->second_response[0] && testing->multiple_devices) ? 0x0C : 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	response = (struct mctp_control_get_message_type_response*) &rx_packet.data[offset];
	response->header.header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;
	response->header.header.command_code = MCTP_CONTROL_PROTOCOL_GET_MESSAGE_TYPE;

	response->header.completion_code = testing->rsp_fail;
	response->message_type_count = 1 + testing->cerberus_discovery + testing->spdm_discovery;

	offset += sizeof (struct mctp_control_get_message_type_response);

	rx_packet.data[offset++] = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;

	if (testing->cerberus_discovery) {
		rx_packet.data[offset++] = MCTP_BASE_PROTOCOL_MSG_TYPE_VENDOR_DEF;
	}

	if (testing->spdm_discovery) {
		rx_packet.data[offset++] = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;
	}

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Callback function which generates and processes a MCTP protocol Get Routing Table Entries
 * 	response message
 *
 * @param expected The expectation that is being used to validate the current call on the mock.
 * @param called The context for the actual call on the mock.
 *
 * @return This function always returns 0
 */
static int64_t attestation_requester_testing_mctp_get_routing_table_entries_rsp_callback (
	const struct mock_call *expected, const struct mock_call *called)
{
	struct attestation_requester_testing *testing = expected->context;
	struct mctp_base_protocol_transport_header *header;
	struct mctp_control_get_routing_table_entries_response *response;
	struct mctp_control_routing_table_entry *entry;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;

	UNUSED (called);

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0B + 2 * sizeof (struct mctp_control_routing_table_entry);
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_RESPONSE;
	header->msg_tag = testing->msg_tag;
	header->packet_seq = 0;

	++testing->msg_tag;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	response = (struct mctp_control_get_routing_table_entries_response*) &rx_packet.data[offset];
	entry = mctp_control_get_routing_table_entries_response_get_entries (response);

	response->header.header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;
	response->header.header.command_code = MCTP_CONTROL_PROTOCOL_GET_ROUTING_TABLE_ENTRIES;

	response->header.completion_code = testing->rsp_fail;
	response->num_entries = 2;
	response->next_entry_handle = testing->second_response[0] ? 0xFF : 1;

	offset += sizeof (struct mctp_control_get_routing_table_entries_response);

	if (!testing->second_response[0]) {
		entry->eid_range_size = 2;
		entry->starting_eid = 0xAA;

		++entry;

		offset += sizeof (struct mctp_control_routing_table_entry);

		entry->eid_range_size = 1;
		entry->starting_eid = 0xBB;

		offset += sizeof (struct mctp_control_routing_table_entry);
	}
	else {
		entry->eid_range_size = 1;
		entry->starting_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;

		++entry;

		offset += sizeof (struct mctp_control_routing_table_entry);

		entry->eid_range_size = 2;
		entry->starting_eid = 0xDD;

		offset += sizeof (struct mctp_control_routing_table_entry);
	}

	testing->second_response[0] = !testing->second_response[0];

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);

	return 0;
}

/**
 * Generate and process a MCTP protocol Set Endpoint ID request
 *
 * @param test The testing framework.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_receive_mctp_set_eid_request (CuTest *test,
	struct attestation_requester_testing *testing)
{
	struct mctp_base_protocol_transport_header *header;
	struct mctp_control_set_eid *rq;
	struct cmd_packet rx_packet;
	struct cmd_message *tx;
	size_t offset;
	int status;

	memset (&rx_packet, 0, sizeof (rx_packet));

	header = (struct mctp_base_protocol_transport_header*) rx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0C;
	header->source_addr = (0x20 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->source_eid = 0x0A;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = 0;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	rq = (struct mctp_control_set_eid*) &rx_packet.data[offset];

	rq->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;
	rq->header.command_code = MCTP_CONTROL_PROTOCOL_SET_EID;
	rq->header.rq = 1;

	rq->operation = MCTP_CONTROL_SET_EID_OPERATION_SET_ID;
	rq->reserved = 0;
	rq->eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;

	offset += sizeof (struct mctp_control_get_routing_table_entries_response);

	rx_packet.data[offset] = checksum_crc8 (0x41 << 1, rx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	rx_packet.pkt_size = offset;
	rx_packet.state = CMD_VALID_PACKET;
	rx_packet.dest_addr = 0x41;
	rx_packet.timeout_valid = false;

	status = mctp_interface_process_packet (&testing->mctp, &rx_packet, &tx);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Setup mock send and receive SPDM protocol Get Version transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param version_unsupported Flag indicating whether SPDM protocol version is unsupported.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_version (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, bool version_unsupported, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_version_request *request;
	size_t offset;
	int status = 0;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0A;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_get_version_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = 0;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	offset += sizeof (struct spdm_get_version_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else if (version_unsupported) {
			testing->version_unsupported = true;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_version_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_version_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Get Version, and sets up hashing mock
 *
 * @param test The testing framework.
 * @param msg_tag Message tag to utilize in request.
 * @param hash_update_fail Flag indicating whether to fail while hashing Get Version response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (
	CuTest *test, uint8_t msg_tag, bool hash_update_fail,
	struct attestation_requester_testing *testing)
{
	struct spdm_get_version_request req;
	uint8_t rsp_buf[sizeof (struct spdm_get_version_response) +
		3 * sizeof (struct spdm_version_num_entry)];
	struct spdm_get_version_response *rsp = (struct spdm_get_version_response*) rsp_buf;
	struct spdm_version_num_entry *version_table =
		(struct spdm_version_num_entry*) &rsp_buf[sizeof (struct spdm_get_version_response)];
	size_t rsp_buf_len;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_get_version_request));
	memset (&rsp_buf, 0, sizeof (rsp_buf));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	rsp->header.spdm_minor_version = 0;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_VERSION;

	rsp->version_num_entry_count = testing->spdm_max_version - testing->spdm_min_version + 1;

	rsp_buf_len = sizeof (struct spdm_get_version_response) +
		sizeof (struct spdm_version_num_entry) * rsp->version_num_entry_count;

	for (i = 0; i < rsp->version_num_entry_count; ++i, ++version_table) {
		version_table->major_version = SPDM_MAJOR_VERSION;
		version_table->minor_version = testing->spdm_min_version + i;
		version_table->alpha = testing->spdm_alpha_version;
	}

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	if (hash_update_fail) {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_buf_len), MOCK_ARG (rsp_buf_len));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_buf_len),
			MOCK_ARG (rsp_buf_len));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, msg_tag, testing);
}

/**
 * Setup mock send and receive SPDM protocol Get Capabilities transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_capabilities (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_capabilities *request;
	size_t offset;
	int status = 0;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = (testing->spdm_version >= 2)? 0x1A : 0x12;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_get_capabilities*) &tx_packet.data[offset];

	request->base_capabilities.header.spdm_minor_version = testing->spdm_version;
	request->base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	request->base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	request->base_capabilities.flags.cache_cap = 0;
	request->base_capabilities.flags.cert_cap = 0;
	request->base_capabilities.flags.chal_cap = 0;
	request->base_capabilities.flags.meas_cap = 0;
	request->base_capabilities.flags.meas_fresh_cap = 0;
	request->base_capabilities.flags.encrypt_cap = 0;
	request->base_capabilities.flags.mac_cap = 0;
	request->base_capabilities.flags.mut_auth_cap = 0;
	request->base_capabilities.flags.key_ex_cap = 0;
	request->base_capabilities.flags.psk_cap = 0;
	request->base_capabilities.flags.encap_cap = 0;
	request->base_capabilities.flags.hbeat_cap = 0;
	request->base_capabilities.flags.key_upd_cap = 0;
	request->base_capabilities.flags.handshake_in_the_clear_cap = 0;
	request->base_capabilities.flags.pub_key_id_cap = 0;

	if (testing->spdm_version >= 2) {
		request->data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		request->max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		offset += sizeof (struct spdm_get_capabilities);
	}
	else {
		offset += sizeof (struct spdm_get_capabilities_1_1);
	}

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_capabilities_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Get Capabilities, and sets up hashing
 * mock
 *
 * @param test The testing framework.
 * @param starting_msg_tag Starting message tag to use with Get Version request.
 * @param hash_update_fail Flag indicating whether to fail while hashing Get Capabilities response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (
	CuTest *test, uint8_t starting_msg_tag, bool hash_update_fail,
	struct attestation_requester_testing *testing)
{
	struct spdm_get_capabilities req;
	struct spdm_get_capabilities rsp;
	size_t capabilities_len = (testing->spdm_version >= 2) ?
		(sizeof (struct spdm_get_capabilities)) : (sizeof (struct spdm_get_capabilities_1_1));
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));
	memset (&rsp, 0, sizeof (struct spdm_get_capabilities));

	req.base_capabilities.header.spdm_minor_version = testing->spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;

	if (testing->spdm_version >= 2) {
		req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	}

	rsp.base_capabilities.header.spdm_minor_version = testing->spdm_version;
	rsp.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp.base_capabilities.header.req_rsp_code = SPDM_RESPONSE_GET_CAPABILITIES;

	rsp.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	rsp.base_capabilities.flags.cache_cap = 0;
	rsp.base_capabilities.flags.cert_cap = !testing->get_cert_unsupported;
	rsp.base_capabilities.flags.chal_cap = !testing->challenge_unsupported;
	rsp.base_capabilities.flags.meas_cap = (testing->meas_cap_unsupported ?
		0 : (testing->meas_cap_sign_unsupported ? 1 : 2));
	rsp.base_capabilities.flags.meas_fresh_cap = 0;
	rsp.base_capabilities.flags.encrypt_cap = 0;
	rsp.base_capabilities.flags.mac_cap = 0;
	rsp.base_capabilities.flags.mut_auth_cap = 0;
	rsp.base_capabilities.flags.key_ex_cap = 0;
	rsp.base_capabilities.flags.psk_cap = 0;
	rsp.base_capabilities.flags.encap_cap = 0;
	rsp.base_capabilities.flags.hbeat_cap = 0;
	rsp.base_capabilities.flags.key_upd_cap = 0;
	rsp.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	rsp.base_capabilities.flags.pub_key_id_cap = 0;

	if (testing->spdm_version >= 2) {
		rsp.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		rsp.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	}

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test,
		starting_msg_tag, false, testing);

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, capabilities_len),
		MOCK_ARG (capabilities_len));
	if (hash_update_fail) {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (&rsp, capabilities_len), MOCK_ARG (capabilities_len));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&rsp, capabilities_len),
			MOCK_ARG (capabilities_len));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		starting_msg_tag + 1, testing);
}

/**
 * Setup mock send and receive SPDM protocol Negotiate Algorithms transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_negotiate_algorithms_request *request;
	size_t offset;
	int status = 0;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x26;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_negotiate_algorithms_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing->spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	request->length = sizeof (struct spdm_negotiate_algorithms_request);
	request->measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	request->base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;

	request->base_hash_algo = testing->hashing_alg_requested;

	if (testing->meas_hashing_alg_requested != testing->hashing_alg_requested) {
		request->base_hash_algo |= testing->meas_hashing_alg_requested;
	}

	offset += sizeof (struct spdm_negotiate_algorithms_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_negotiate_algorithms_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Negotiate Algorithms, and sets up
 * hashing mock
 *
 * @param test The testing framework.
 * @param starting_msg_tag Starting message tag to use in Get Version request.
 * @param hash_update_fail Flag indicating whether to fail while hashing Negotiate Algorithms
 * response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (
	CuTest *test, uint8_t starting_msg_tag, bool hash_update_fail,
	struct attestation_requester_testing *testing)
{
	struct spdm_negotiate_algorithms_request req;
	struct spdm_negotiate_algorithms_response rsp;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));
	memset (&rsp, 0, sizeof (struct spdm_negotiate_algorithms_response));

	req.header.spdm_minor_version = testing->spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = testing->hashing_alg_requested;

	if (testing->meas_hashing_alg_requested != testing->hashing_alg_requested) {
		req.base_hash_algo |= testing->meas_hashing_alg_requested;
	}

	rsp.header.spdm_minor_version = testing->spdm_version;
	rsp.header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp.header.req_rsp_code = SPDM_RESPONSE_NEGOTIATE_ALGORITHMS;

	rsp.length = sizeof (struct spdm_negotiate_algorithms_response);
	rsp.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	rsp.base_asym_sel = testing->asymmetric_key_signature_alg_unsupported ?
		0 : (testing->asymmetric_key_signature_alg_mismatched ?
			SPDM_TPM_ALG_RSASSA_2048 : SPDM_TPM_ALG_ECDSA_ECC_NIST_P256);
	rsp.base_hash_sel = testing->hashing_alg_supported;
	rsp.measurement_hash_algo = testing->meas_hashing_alg_supported;

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test,
		starting_msg_tag, false, testing);

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	if (hash_update_fail) {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (&rsp, sizeof (rsp)), MOCK_ARG (sizeof (rsp)));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&rsp, sizeof (rsp)),
			MOCK_ARG (sizeof (rsp)));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, starting_msg_tag + 2, testing);
}

/**
 * Setup mock send and receive SPDM protocol Get Digests transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_digests (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_digests_request *request;
	size_t offset;
	int status = 0;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0A;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_get_digests_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing->spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	offset += sizeof (struct spdm_get_digests_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_digests_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Get Digests, and sets up
 * hashing mock
 *
 * @param test The testing framework.
 * @param hash_update_fail Flag indicating whether to fail while hashing Get Digests response.
 * @param hash_update Flag indicating whether hash update of response occurs.
 * @param testing Testing instances.
 * @param msg_tag Message tag to use in transaction.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (
	CuTest *test, bool hash_update_fail, bool hash_update, bool non_contiguous_slot_mask,
	struct attestation_requester_testing *testing, uint8_t msg_tag)
{
	const size_t hash_len_multiplier =
		non_contiguous_slot_mask ? common_math_get_num_bits_set (testing->slot_mask) : 1;
	const size_t rsp_buf_length = sizeof (struct spdm_get_digests_response) +
		(HASH_MAX_HASH_LEN * hash_len_multiplier);
	uint8_t rsp_buf[rsp_buf_length];
	struct spdm_get_digests_response *rsp = (struct spdm_get_digests_response*) &rsp_buf;
	struct spdm_get_digests_request req;
	size_t hash_len;
	size_t rsp_len;
	int status;
	size_t i;

	if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH * hash_len_multiplier;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH * hash_len_multiplier;
	}
	else {
		hash_len = SHA512_HASH_LENGTH * hash_len_multiplier;
	}

	rsp_len = sizeof (struct spdm_get_digests_response) + hash_len;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));
	memset (rsp_buf, 0, sizeof (rsp_buf));

	req.header.spdm_minor_version = testing->spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	rsp->header.spdm_minor_version = testing->spdm_version;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_DIGESTS;

	if (non_contiguous_slot_mask) {
		rsp->slot_mask = testing->slot_mask;
	}
	else {
		rsp->slot_mask = 1;
	}

	for (i = 0; i < hash_len; ++i) {
		rsp_buf[sizeof (struct spdm_get_digests_response) + i] = i + testing->second_device;
	}

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));

	if (hash_update) {
		if (hash_update_fail) {
			status = mock_expect (&testing->secondary_hash.mock,
				testing->secondary_hash.base.update, &testing->secondary_hash,
				HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_len),
				MOCK_ARG (rsp_len));
			status |= mock_expect (&testing->secondary_hash.mock,
				testing->secondary_hash.base.cancel, &testing->secondary_hash, 0);
		}
		else {
			status = mock_expect (&testing->secondary_hash.mock,
				testing->secondary_hash.base.update, &testing->secondary_hash, 0,
				MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_len), MOCK_ARG (rsp_len));
		}
	}

	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, false, false,
		msg_tag, testing);
}

/**
 * Setup mock send and receive SPDM protocol Get Certificate transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 * @param cert_buffer_offset Offset in certificate buffer.
 * @param length Remaining length to request.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_certificate (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, bool non_contiguous_slot_mask,
	uint8_t msg_tag, struct attestation_requester_testing *testing, uint16_t cert_buffer_offset,
	uint16_t length)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_certificate_request *request;
	size_t offset;
	int status;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0E;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_get_certificate_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing->spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	if (non_contiguous_slot_mask) {
		request->slot_num = testing->slot_num[0];
	}
	else {
		request->slot_num = ATTESTATION_RIOT_SLOT_NUM;
	}
	request->offset = cert_buffer_offset;
	request->length = length;

	offset += sizeof (struct spdm_get_certificate_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Get Certificate, and sets up
 * hashing mock
 *
 * @param test The testing framework.
 * @param hash_update_fail Flag indicating whether to fail while hashing Get Certificate response.
 * @param testing Testing instances.
 * @param msg_tag Message tag to use in transaction.
 * @param portion_length Portion length to utilize response.
 * @param offset Offset to utilize in response.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (
	CuTest *test, bool hash_update_fail, bool non_contiguous_slot_mask,
	struct attestation_requester_testing *testing, uint8_t msg_tag, uint16_t portion_length,
	uint16_t offset)
{
	struct spdm_get_certificate_request req;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY];
	struct spdm_get_certificate_response *rsp = (struct spdm_get_certificate_response*) &rsp_buf;
	size_t rsp_len;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));
	memset (rsp_buf, 0, sizeof (rsp_buf));

	req.header.spdm_minor_version = testing->spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	if (non_contiguous_slot_mask) {
		req.slot_num = testing->slot_num[0];
	}
	else {
		req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	}
	req.offset = offset;
	req.length = (offset > 0) ? (testing->cert_buffer_len - offset) :
		SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	rsp->header.spdm_minor_version = testing->spdm_version;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_CERTIFICATE;

	rsp->slot_num = testing->slot_num[0];
	rsp->portion_len = portion_length;
	rsp->remainder_len = testing->cert_buffer_len - (offset + portion_length);

	memcpy (&rsp_buf[sizeof (struct spdm_get_certificate_response)], &cert_buffer[offset],
		portion_length);

	rsp_len = sizeof (struct spdm_get_certificate_response) + portion_length;

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	if (hash_update_fail) {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_len), MOCK_ARG (rsp_len));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, rsp_len),
			MOCK_ARG (rsp_len));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, true, false, false,
		non_contiguous_slot_mask, msg_tag, testing, offset, req.length);
}

/**
 * Helper function which sends and receives a successful SPDM Protocol Get Certificate, and sets
 * up hashing mock, and verifies received certificate chain
 *
 * @param test The testing framework.
 * @param testing Testing instances.
 * @param hash_algo Hashing algorithm to use in transaction.
 * @param msg_tag Message tag to use in transaction.
 * @param x509_mock Boolean flag indicating whether to use a mock x509 or mbedtls x509 engine
 * @param use_riot_ca Use device RIoT root CA
 * @param vendor_root_ca CFM includes vendor root CA
 * @param ca_digests Buffer to use as root CA digests
 * @param component_id Component ID of device attested
 */
static void attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (
	CuTest *test, struct attestation_requester_testing *testing, uint8_t hash_algo, uint8_t msg_tag,
	bool x509_mock, bool use_riot_root_ca, bool vendor_root_ca, bool non_contiguous_slot_mask,
	uint8_t *ca_digests, uint8_t component_id)
{
	struct cfm_root_ca_digests root_ca_digests;
	uint8_t out_digest[HASH_MAX_HASH_LEN];
	const uint8_t *root_ca_cert = use_riot_root_ca ? X509_CERTSS_RSA_CA_NOPL_DER :
		X509_CERTSS_ECC_CA_NOPL_DER;
	uint8_t *pub_key;
	size_t root_ca_cert_len = use_riot_root_ca ? X509_CERTSS_RSA_CA_NOPL_DER_LEN :
		X509_CERTSS_ECC_CA_NOPL_DER_LEN;
	size_t cert_chain_len_wout_root_ca = RIOT_CORE_DEVID_SIGNED_CERT_LEN + RIOT_CORE_ALIAS_CERT_LEN;
	size_t cert_chain_len = use_riot_root_ca ? root_ca_cert_len :
		(cert_chain_len_wout_root_ca + X509_CERTSS_ECC_CA_NOPL_DER_LEN);
	size_t hash_len;
	size_t i_digest;
	int save_arg_adjustment = testing->second_device * 2;
	int status;

	if (hash_algo == HASH_TYPE_SHA256) {
		hash_len = SHA256_HASH_LENGTH;
	}
	else if (hash_algo == HASH_TYPE_SHA384) {
		hash_len = SHA384_HASH_LENGTH;
	}
	else {
		hash_len = SHA512_HASH_LENGTH;
	}

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest + testing->second_device;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	if (ca_digests != NULL) {
		for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
			ca_digests[SHA256_HASH_LENGTH + i_digest] = 0x0a + i_digest;
		}
	}

	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		non_contiguous_slot_mask, testing, msg_tag, testing->cert_buffer_len, 0);

	if (vendor_root_ca) {
		status = mock_expect (&testing->cfm.mock, testing->cfm.base.get_root_ca_digest,
			&testing->cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
		status |= mock_expect_output_tmp (&testing->cfm.mock, 1, &root_ca_digests,
			sizeof (struct cfm_root_ca_digests), -1);
		status |= mock_expect (&testing->cfm.mock, testing->cfm.base.free_root_ca_digest,
			&testing->cfm, 0,
			MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
		CuAssertIntEquals (test, 0, status);

		status = mock_expect (&testing->primary_hash.mock,
			testing->primary_hash.base.calculate_sha256, &testing->primary_hash, 0,
			MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
			MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
			MOCK_ARG (HASH_MAX_HASH_LEN));
		status |= mock_expect_output_tmp (&testing->primary_hash.mock, 2,
			&ca_digests[SHA256_HASH_LENGTH], SHA256_HASH_LENGTH, -1);
		CuAssertIntEquals (test, 0, status);
	}
	else {
		status = mock_expect (&testing->cfm.mock, testing->cfm.base.get_root_ca_digest,
			&testing->cfm, CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
		CuAssertIntEquals (test, 0, status);
	}

	if (x509_mock) {
		pub_key = platform_malloc (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);
		CuAssertPtrNotNull (test, pub_key);

		memcpy (pub_key, RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);

		status = mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.init_ca_cert_store,
			&testing->x509_mock, 0, MOCK_ARG_NOT_NULL);
		status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 0 + save_arg_adjustment);
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.add_root_ca,
			&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (0 + save_arg_adjustment),
			MOCK_ARG_PTR_CONTAINS (root_ca_cert, root_ca_cert_len), MOCK_ARG (cert_chain_len));
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.add_intermediate_ca, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (0 + save_arg_adjustment),
			MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
			MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.load_certificate,
			&testing->x509_mock, 0, MOCK_ARG_NOT_NULL,
			MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
			MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
		status |= mock_expect_save_arg (&testing->x509_mock.mock, 0, 1 + save_arg_adjustment);
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.authenticate,
			&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (1 + save_arg_adjustment),
			MOCK_ARG_SAVED_ARG (0 + save_arg_adjustment));
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.get_public_key_type, &testing->x509_mock, X509_PUBLIC_KEY_ECC,
			MOCK_ARG_SAVED_ARG (1 + save_arg_adjustment));
		status |= mock_expect (&testing->x509_mock.mock, testing->x509_mock.base.get_public_key,
			&testing->x509_mock, 0, MOCK_ARG_SAVED_ARG (1 + save_arg_adjustment),
			MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
		status |= mock_expect_output_tmp (&testing->x509_mock.mock, 1, &pub_key, sizeof (pub_key),
			-1);
		status |= mock_expect_output (&testing->x509_mock.mock, 2, &RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
			sizeof (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), -1);
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.release_certificate, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (1 + save_arg_adjustment));
		status |= mock_expect (&testing->x509_mock.mock,
			testing->x509_mock.base.release_ca_cert_store, &testing->x509_mock, 0,
			MOCK_ARG_SAVED_ARG (0 + save_arg_adjustment));
		CuAssertIntEquals (test, 0, status);
	}

	if (hash_algo == HASH_TYPE_SHA256) {
		status = mock_expect (&testing->primary_hash.mock,
			testing->primary_hash.base.calculate_sha256, &testing->primary_hash, 0,
			MOCK_ARG_NOT_NULL, MOCK_ARG (testing->cert_buffer_len), MOCK_ARG_NOT_NULL,
			MOCK_ARG (HASH_MAX_HASH_LEN));
	}
	else if (hash_algo == HASH_TYPE_SHA384) {
		status = mock_expect (&testing->primary_hash.mock,
			testing->primary_hash.base.calculate_sha384, &testing->primary_hash, 0,
			MOCK_ARG_NOT_NULL, MOCK_ARG (testing->cert_buffer_len), MOCK_ARG_NOT_NULL,
			MOCK_ARG (HASH_MAX_HASH_LEN));
	}
	else {
		status = mock_expect (&testing->primary_hash.mock,
			testing->primary_hash.base.calculate_sha512, &testing->primary_hash, 0,
			MOCK_ARG_NOT_NULL, MOCK_ARG (testing->cert_buffer_len), MOCK_ARG_NOT_NULL,
			MOCK_ARG (HASH_MAX_HASH_LEN));
	}
	status |= mock_expect_output_tmp (&testing->primary_hash.mock, 2, out_digest, hash_len, -1);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Setup mock send and receive SPDM protocol Challenge transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_challenge (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, bool non_contiguous_slot_mask,
	uint8_t msg_tag, struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_challenge_request *request;
	size_t offset;
	int status;
	size_t i;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x2A;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_challenge_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing->spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	if (non_contiguous_slot_mask) {
		request->slot_num = testing->slot_num[0];
	}
	else {
		request->slot_num = ATTESTATION_RIOT_SLOT_NUM;
	}

	request->req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (request->nonce); ++i) {
		request->nonce[i] = SPDM_NONCE_LEN - i;
	}

	offset += sizeof (struct spdm_challenge_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_challenge_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Challenge, and sets up hashing mock
 *
 * @param test The testing framework.
 * @param hash_update_fail Flag indicating whether to fail while hashing Challenge response.
 * @param testing Testing instances.
 * @param msg_tag Message to use in transaction.
 */
static void attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (
	CuTest *test, bool hash_update_fail, bool non_contiguous_slot_mask,
	struct attestation_requester_testing *testing, uint8_t msg_tag)
{
	struct spdm_challenge_request req;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY];
	struct spdm_challenge_response *rsp = (struct spdm_challenge_response*) &rsp_buf;
	uint16_t *opaque_length;
	size_t hash_len;
	size_t offset;
	int status;
	size_t i;

	if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH;
	}
	else if (testing->hashing_alg_supported == SPDM_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH;
	}
	else {
		hash_len = SHA512_HASH_LENGTH;
	}

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));
	memset (rsp_buf, 0, sizeof (rsp_buf));

	req.header.spdm_minor_version = testing->spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	if (non_contiguous_slot_mask) {
		req.slot_num = testing->slot_num[0];
	}
	else {
		req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	}

	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = testing->spdm_version;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_CHALLENGE;

	if (non_contiguous_slot_mask) {
		rsp->slot_num = testing->slot_num[0];
	}
	else {
		rsp->slot_num = ATTESTATION_RIOT_SLOT_NUM;
	}

	rsp->basic_mutual_auth_req = 0;
	if (non_contiguous_slot_mask) {
		rsp->slot_mask = testing->slot_mask;
	}
	else {
		rsp->slot_mask = 1;
	}

	offset = sizeof (struct spdm_challenge_response);

	for (i = 0; i < hash_len; ++i, ++offset) {
		rsp_buf[offset] = i + testing->cert_chain_digest_compare_fail + testing->second_device;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	for (i = 0; i < hash_len; ++i, ++offset) {
		rsp_buf[offset] = 50 + i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < 5; ++i) {
		rsp_buf[offset + i] = i * 10;
	}

	status = mock_expect (&testing->rng.mock, testing->rng.base.generate_random_buffer,
		&testing->rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing->rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	if (hash_update_fail) {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, offset), MOCK_ARG (offset));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, offset),
			MOCK_ARG (offset));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false,
		non_contiguous_slot_mask, msg_tag, testing);
}

/**
 * Setup mock send and receive SPDM protocol Get Measurements transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param rsp_fail Flag indicating whether to receive an error response or not.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param measurement_operation Measurement operation to request.
 * @param raw_request Flag indicating whether to request a raw measurement block.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_measurements (CuTest *test,
	bool get_rsp, bool rsp_fail, bool unexpected_rsp, uint8_t msg_tag,
	uint8_t measurement_operation, bool raw_request, struct attestation_requester_testing *testing)
{
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_get_measurements_request *request;
	size_t offset;
	size_t i;
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;

	if (measurement_operation == 0) {
		testing->get_num_indices = true;
	}

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = testing->spdm_discovery ? 0x0A : 0x2B;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_get_measurements_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing->spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	request->measurement_operation = measurement_operation;
	request->sig_required = !testing->spdm_discovery;
	request->raw_bit_stream_requested = testing->spdm_version == 1 ? 0 : raw_request;

	offset += sizeof (struct spdm_get_measurements_request);

	if (!testing->spdm_discovery) {
		nonce = spdm_get_measurements_rq_nonce (request);

		for (i = 0; i < SPDM_NONCE_LEN; ++i) {
			nonce[i] = SPDM_NONCE_LEN - i;
		}

		offset += SPDM_NONCE_LEN;

		slot_id = spdm_get_measurements_rq_slot_id_ptr (request);
		*slot_id = ATTESTATION_RIOT_SLOT_NUM;

		++offset;
	}

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (rsp_fail) {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_error_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);

		}
		else if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = 0;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_spdm_get_measurements_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Helper function which sends and receives a SPDM Protocol Get Measurements to request all blocks,
 * and sets up hashing mock
 *
 * @param test The testing framework.
 * @param raw_request Flag indicating whether to request a raw measurement block.
 * @param hash_update_fail Flag indicating whether to fail while hashing Get Measurements response.
 * @param testing Testing instances.
 * @param msg_tag Message to use in transaction.
 * @param measurement_operation Measurement operation to utilize in transaction.
 */
static void attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (
	CuTest *test, bool raw_request, bool hash_update_fail,
	struct attestation_requester_testing *testing, uint8_t msg_tag, uint8_t measurement_operation)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_response *rsp = (struct spdm_get_measurements_response*) &rsp_buf;
	struct spdm_measurements_block_header *block =
		(struct spdm_measurements_block_header*)
			spdm_get_measurements_resp_measurement_record (rsp);
	uint16_t *opaque_length;
	uint8_t *slot_id;
	uint8_t *nonce;
	size_t num_blocks = (measurement_operation == SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS) ? 2 :
		1;
	size_t hash_len;
	size_t offset;
	int status;
	size_t i;

	if (testing->meas_hashing_alg_supported == SPDM_MEAS_RSP_TPM_ALG_SHA_256) {
		hash_len = SHA256_HASH_LENGTH;
	}
	else if (testing->meas_hashing_alg_supported == SPDM_MEAS_RSP_TPM_ALG_SHA_384) {
		hash_len = SHA384_HASH_LENGTH;
	}
	else {
		hash_len = SHA512_HASH_LENGTH;
	}

	num_blocks += testing->num_blocks_incorrect;

	req->header.spdm_minor_version = testing->spdm_version;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->raw_bit_stream_requested = raw_request;
	req->measurement_operation = measurement_operation;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = testing->spdm_version;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	rsp->slot_id = ATTESTATION_RIOT_SLOT_NUM;
	rsp->number_of_blocks = num_blocks;

	rsp->measurement_record_len[0] = num_blocks * spdm_measurements_block_size (hash_len);

	offset = sizeof (struct spdm_get_measurements_response) +
		sizeof (struct spdm_measurements_block_header);

	if (measurement_operation != 2) {
		block->index = 1 + testing->unexpected_measurement_block;
		block->measurement_size = sizeof (struct spdm_measurements_block_dmtf) + hash_len;
		block->measurement_specification = 1;
		block->dmtf.measurement_block_type = 0;
		block->dmtf.measurement_size = hash_len;
		block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw & testing->raw_rsp[0];

		for (i = 0; i < hash_len; ++i, ++offset) {
			rsp_buf[offset] = 50 + i + testing->raw_rsp[0];

			if ((i == 0) && (testing->measurement_modify)) {
				rsp_buf[offset] = 0xCC;
			}
		}
	}
	else {
		block->index = 2 + testing->unexpected_measurement_block;
		block->measurement_size = sizeof (struct spdm_measurements_block_dmtf) + hash_len;
		block->measurement_specification = 1;
		block->dmtf.measurement_block_type = 0;
		block->dmtf.measurement_size = hash_len;
		block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw & testing->raw_rsp[1];

		for (i = 0; i < hash_len; ++i, ++offset) {
			rsp_buf[offset] = 100 - i + testing->raw_rsp[1];
		}
	}

	if (num_blocks > 1) {
		block =	(struct spdm_measurements_block_header*) &rsp_buf[offset];
		offset += sizeof (struct spdm_measurements_block_header);

		block->index = 2 + testing->unexpected_measurement_block;
		block->measurement_size = sizeof (struct spdm_measurements_block_dmtf) + hash_len;
		block->measurement_specification = 1;
		block->dmtf.measurement_block_type = 0;
		block->dmtf.measurement_size = hash_len;
		block->dmtf.raw_bit_stream = !testing->digest_instead_of_raw & testing->raw_rsp[0];

		for (i = 0; i < hash_len; ++i, ++offset) {
			rsp_buf[offset] = 100 - i + testing->raw_rsp[0];
		}
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		rsp_buf[offset + i] = i * 10;

		if (measurement_operation == 2) {
			rsp_buf[offset + i] -= 1;
		}
	}

	status = mock_expect (&testing->rng.mock, testing->rng.base.generate_random_buffer,
		&testing->rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing->rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
		&testing->secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	if (hash_update_fail) {
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, HASH_ENGINE_NO_MEMORY,
			MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, offset), MOCK_ARG (offset));
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.cancel,
			&testing->secondary_hash, 0);
	}
	else {
		status |= mock_expect (&testing->secondary_hash.mock, testing->secondary_hash.base.update,
			&testing->secondary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, offset),
			MOCK_ARG (offset));
	}
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		msg_tag, measurement_operation, raw_request, testing);
}

/**
 * Setup mock send and receive MCTP control protocol Get Message Type transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_mctp_get_msg_type (CuTest *test,
	bool get_rsp, bool unexpected_rsp, uint8_t msg_tag,
	struct attestation_requester_testing *testing)
{
	struct mctp_base_protocol_transport_header *header;
	struct cmd_packet tx_packet;
	struct mctp_control_get_message_type *request;
	int status = 0;
	size_t offset;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x08;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = testing->second_device ? 0x0C : 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct mctp_control_get_message_type*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;
	request->header.command_code = MCTP_CONTROL_PROTOCOL_GET_MESSAGE_TYPE;
	request->header.rq = 1;

	offset += sizeof (struct mctp_control_get_message_type);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = ATTESTATION_RIOT_SLOT_NUM;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_mctp_get_message_type_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/**
 * Setup mock send and receive MCTP control protocol Get Routing Table transactions.
 *
 * @param test The testing framework.
 * @param get_rsp Flag indicating whether to receive a response.
 * @param unexpected_rsp Flag indicating whether to send an unexpected response.
 * @param msg_tag Message tag to utilize in request/response.
 * @param entry_handle Entry handle to request.
 * @param testing Testing instances.
 */
static void attestation_requester_testing_send_and_receive_mctp_get_routing_table (CuTest *test,
	bool get_rsp, bool unexpected_rsp, uint8_t msg_tag, uint8_t entry_handle,
	struct attestation_requester_testing *testing)
{
	struct mctp_base_protocol_transport_header *header;
	struct cmd_packet tx_packet;
	struct mctp_control_get_routing_table_entries *request;
	int status = 0;
	size_t offset;

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x09;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = msg_tag;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);

	request = (struct mctp_control_get_routing_table_entries*) &tx_packet.data[offset];
	request->header.msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_CONTROL_MSG;
	request->header.command_code = MCTP_CONTROL_PROTOCOL_GET_ROUTING_TABLE_ENTRIES;
	request->header.rq = 1;

	request->entry_handle = entry_handle;

	offset += sizeof (struct mctp_control_get_routing_table_entries);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing->channel.mock, testing->channel.base.send_packet,
		&testing->channel, 0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	if (get_rsp) {
		if (unexpected_rsp) {
			testing->cert_num = 0;
			testing->cert[0] = X509_CERTSS_RSA_CA_NOPL_DER;
			testing->cert_len[0] = X509_CERTSS_RSA_CA_NOPL_DER_LEN;
			testing->slot_num[1] = ATTESTATION_RIOT_SLOT_NUM;

			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_cerberus_get_certificate_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
		else {
			status = mock_expect_external_action (&testing->channel.mock,
				attestation_requester_testing_mctp_get_routing_table_entries_rsp_callback, testing);
			CuAssertIntEquals (test, 0, status);
		}
	}
}

/*******************
 * Test cases
 *******************/

static void attestation_requester_test_init (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, 0, 0);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, &testing.rsa.base, &testing.x509_mock.base, &testing.rng.base,
		&testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_init_no_rsa (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, 0, 0);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, NULL, &testing.x509_mock.base, &testing.rng.base, &testing.riot,
		&testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_init_no_secondary_hash (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, 0, 0);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base,
		&testing.rsa.base, &testing.x509_mock.base, &testing.rng.base, &testing.riot,
		&testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_init_invalid_arg (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, 0, 0);

	status = attestation_requester_init (NULL, &testing.state, &testing.mctp, &testing.channel.base,
		&testing.primary_hash.base, NULL, &testing.ecc.base, NULL, &testing.x509_mock.base,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, NULL, &testing.mctp, &testing.channel.base,
		&testing.primary_hash.base, NULL, &testing.ecc.base, NULL, &testing.x509_mock.base,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, NULL, &testing.channel.base,
		&testing.primary_hash.base, NULL, &testing.ecc.base, NULL, &testing.x509_mock.base,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp, NULL,
		&testing.primary_hash.base, NULL, &testing.ecc.base, NULL, &testing.x509_mock.base,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, NULL, NULL, &testing.ecc.base, NULL, &testing.x509_mock.base,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, NULL, NULL,
		&testing.x509_mock.base, &testing.rng.base, &testing.riot, &testing.device_mgr,
		&testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base, NULL, NULL,
		&testing.rng.base, &testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base, NULL,
		&testing.x509_mock.base, NULL, &testing.riot, &testing.device_mgr,
		&testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base, NULL,
		&testing.x509_mock.base, &testing.rng.base, NULL, &testing.device_mgr,
		&testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base, NULL,
		&testing.x509_mock.base, &testing.rng.base, &testing.riot, NULL, &testing.cfm_manager.base);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base, NULL,
		&testing.x509_mock.base, &testing.rng.base, &testing.riot, &testing.device_mgr, NULL);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);

	complete_attestation_requester_mock_test (test, &testing, false);
}

static void attestation_requester_test_init_state (CuTest *test)
{
	struct attestation_requester_testing testing;
	const struct pcr_config pcr_config[1] = {
		{
			.num_measurements = 1,
			.measurement_algo = HASH_TYPE_SHA256
		}
	};
	struct attestation_requester attestation = attestation_requester_static_init (&testing.state,
		&testing.mctp, &testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base,
		NULL, &testing.x509_mock.base, &testing.rng.base, &testing.riot, &testing.device_mgr, NULL);
	int status;

	TEST_START;

	status = hash_mock_init (&testing.primary_hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_init (&testing.secondary_hash);
	CuAssertIntEquals (test, 0, status);

	status = ecc_mock_init (&testing.ecc);
	CuAssertIntEquals (test, 0, status);

	status = rsa_mock_init (&testing.rsa);
	CuAssertIntEquals (test, 0, status);

	status = x509_mock_init (&testing.x509_mock);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&testing.rng);
	CuAssertIntEquals (test, 0, status);

	status = keystore_mock_init (&testing.keystore);
	CuAssertIntEquals (test, 0, status);

	status = cmd_channel_mock_init (&testing.channel, 0);
	CuAssertIntEquals (test, 0, status);

	status = firmware_update_control_mock_init (&testing.fw_update);
	CuAssertIntEquals (test, 0, status);

	status = attestation_responder_mock_init (&testing.attestation_responder);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&testing.store, pcr_config, ARRAY_SIZE (pcr_config));
	CuAssertIntEquals (test, 0, status);

	status = cmd_background_mock_init (&testing.background);
	CuAssertIntEquals (test, 0, status);

	status = cmd_authorization_mock_init (&testing.authorization);
	CuAssertIntEquals (test, 0, status);

	status = cmd_device_mock_init (&testing.device);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_mock_init (&testing.cfm_manager);
	CuAssertIntEquals (test, 0, status);

	status = cfm_mock_init (&testing.cfm);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.keystore.mock, testing.keystore.base.load_key,
		&testing.keystore, KEYSTORE_NO_KEY, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.keystore.mock, 1, &testing.dev_id_der,
		sizeof (testing.dev_id_der), -1);
	CuAssertIntEquals (test, 0, status);

	keys.alias_cert_length = RIOT_CORE_ALIAS_CERT_LEN;
	keys.devid_cert_length = RIOT_CORE_DEVID_CERT_LEN;
	keys.alias_key_length = RIOT_CORE_ALIAS_KEY_LEN;

	status = riot_key_manager_init_static (&testing.riot, &testing.keystore.base, &keys,
		&testing.x509.base);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_init (&testing.device_mgr, 1, 1, 1, DEVICE_MANAGER_PA_ROT_MODE,
		DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE, 1000, 1000, 1000, 0, 0, 0, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 0,
		MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_add_unidentified_device (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, 0, status);

	fw_ver_list[0] = "1.1.1.1";
	testing.fw_version.count = 1;
	testing.fw_version.id = fw_ver_list;

	status = cmd_interface_system_init (&testing.cmd_cerberus, &testing.fw_update.base, NULL,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, &testing.attestation_responder.base,
		&testing.device_mgr, &testing.store, &testing.primary_hash.base,
		&testing.background.base, NULL, NULL, &testing.fw_version, &testing.riot,
		&testing.authorization.base, NULL, NULL, NULL,	NULL, NULL, NULL, &testing.device.base, 1,
		2, 3, 4, NULL);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_init (&testing.cmd_mctp, &testing.device_mgr, 0x1414, 4);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_init (&testing.cmd_spdm);
	CuAssertIntEquals (test, 0, status);

	status = mctp_interface_init (&testing.mctp, &testing.cmd_cerberus.base,
		&testing.cmd_mctp.base, &testing.cmd_spdm.base, &testing.device_mgr);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_init_state (&attestation);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_deinit (&attestation);

	complete_attestation_requester_mock_test (test, &testing, false);
}

static void attestation_requester_test_init_state_invalid_arg (CuTest *test)
{
	int status;

	TEST_START;

	status = attestation_requester_init_state (NULL);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);
}

static void attestation_requester_test_deinit_null (CuTest *test)
{
	TEST_START;

	attestation_requester_deinit (NULL);
}

static void attestation_requester_test_attest_device_cerberus_ecc (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_ecc_vendor_root_ca (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 65;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, false, true, ca_digests, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_ecc_untrusted_root_ca (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, false, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0),	MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_rsa (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 75;
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, false, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, false, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_mbedtls_x509 (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, false,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, false, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_already_authenticated (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 40;
	uint8_t digest[SHA256_HASH_LENGTH];
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_device_state_by_eid (&testing.device_mgr, 0x0A,
		DEVICE_MANAGER_AUTHENTICATED);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_multiple_pmr0_digest_options (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH * 2] = {0};
	struct cfm_pmr_digest pmr_digest;
	int status;
	int i;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i) {
		digest[i + SHA256_HASH_LENGTH] = i * 3;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 2;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_device_capabilities_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		true, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_device_capabilities_no_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, false, false,
		false, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_device_capabilities_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, true,
		false, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_digest_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest (test, true, true, false,
		SHA256_HASH_LENGTH, 1, ATTESTATION_RIOT_SLOT_NUM, ATTESTATION_ECDHE_KEY_EXCHANGE,
		&testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_digest_hash_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t digest[SHA256_HASH_LENGTH * 3];
	size_t i_digest;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest (test, true, false, false,
		SHA256_HASH_LENGTH, 1, ATTESTATION_RIOT_SLOT_NUM, ATTESTATION_ECDHE_KEY_EXCHANGE,
		&testing);

	for (i_digest = 0; i_digest < sizeof (digest); ++i_digest) {
		digest[i_digest] = i_digest;
	}

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)), MOCK_ARG (SHA256_HASH_LENGTH * 3),
		MOCK_ARG_NOT_NULL, MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_digest_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest (test, true, false, true,
		SHA256_HASH_LENGTH, 1, ATTESTATION_RIOT_SLOT_NUM, ATTESTATION_ECDHE_KEY_EXCHANGE,
		&testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_digest_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest (test, false, false, false,
		SHA256_HASH_LENGTH, 1, ATTESTATION_RIOT_SLOT_NUM, ATTESTATION_ECDHE_KEY_EXCHANGE,
		&testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, true,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		true, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_unexpected_slot_num (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, true, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_init_ca_cert_store_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_add_root_ca_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_no_riot_ca_add_root_ca_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_hash_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 5;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_not_supported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 12;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
		out_digest[i_digest] = 0x0b + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, out_digest, SHA256_HASH_LENGTH,
		-1);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_add_root_ca_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 50;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2,
		&ca_digests[SHA256_HASH_LENGTH], SHA256_HASH_LENGTH, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_add_intermediate_ca_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_load_certificate_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_authenticate_cert_chain_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN +	X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_hash_cert_chain_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN +	X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_compare_cert_chain_digest_fail (
	CuTest *test)
{
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN +
			X509_CERTCA_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, DEVICE_MGR_DIGEST_MISMATCH, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_public_key_type_fail (
	CuTest *test)
{
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;
	size_t i_digest;

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest + 50;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key_type,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN +
			X509_CERTCA_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_public_key_fail (CuTest *test)
{
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;
	size_t i_digest;

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest + 50;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 3, ATTESTATION_RIOT_SLOT_NUM, 1, X509_CERTCA_ECC_CA_NOPL_DER,
		X509_CERTCA_ECC_CA_NOPL_DER_LEN, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, true, false,
		false, false, 4, ATTESTATION_RIOT_SLOT_NUM, 2, RIOT_CORE_DEVID_INTR_SIGNED_CERT,
		RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN + X509_CERTCA_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTCA_ECC_CA_NOPL_DER, X509_CERTCA_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTCA_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_INTR_SIGNED_CERT,
			RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN), MOCK_ARG (RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key_type,
		&testing.x509_mock, X509_PUBLIC_KEY_ECC, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_NOT_NULL,
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN +
			X509_CERTCA_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_INTR_SIGNED_CERT_LEN),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_certificate_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate (test, false, false,
		false, false, 2, ATTESTATION_RIOT_SLOT_NUM, 0, X509_CERTSS_RSA_CA_NOPL_DER,
		X509_CERTSS_RSA_CA_NOPL_DER_LEN, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_start_hash_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_generate_challenge_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, 0);
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.cancel,
		&testing.primary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer, &testing.rng,
		RNG_ENGINE_NO_MEMORY, MOCK_ARG (ATTESTATION_NONCE_LEN), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, RNG_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, true, false,
		false, false, false, false, 5, 0, HASH_ENGINE_NO_MEMORY, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, true, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_unexpected_slot_num (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		true, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_unexpected_hash_len (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, true, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_unexpected_min_protocol_version (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, true, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_unexpected_max_protocol_version (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, true, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_update_hash_rsp_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, HASH_ENGINE_NO_MEMORY, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_hash_finish_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, HASH_ENGINE_NO_MEMORY, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_ecc_init_pub_key_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, ECC_ENGINE_NO_MEMORY, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_ecc_verify_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, ECC_ENGINE_NO_MEMORY, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_rsa_not_supported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, false, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, false, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, false, true, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_rsa_init_pub_key_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, false, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, ECC_ENGINE_NO_MEMORY, 0, false, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_rsa_verify_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, false, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, ECC_ENGINE_NO_MEMORY, false, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, true,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_challenge_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM, 0);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, 0);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, false, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_get_component_pmr_digest_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, MANIFEST_NO_MEMORY, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MANIFEST_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_pmr0_digest_invalid_len (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	uint8_t digest[SHA512_HASH_LENGTH] = {0};
	struct cfm_pmr_digest pmr_digest;
	int status;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cerberus_no_pmr0_digest_match (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 12;
	uint8_t digest[SHA256_HASH_LENGTH] = {0};
	struct cfm_pmr_digest pmr_digest;
	int status;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_CERBERUS_PROTOCOL, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	attestation_requester_testing_send_and_receive_cerberus_device_capabilities (test, true, false,
		false, 0, &testing);

	attestation_requester_testing_send_and_receive_cerberus_get_digest_with_mocks (test, &testing,
		1);

	attestation_requester_testing_send_and_receive_cerberus_get_certificate_with_mocks (test,
		&testing, true, true, 2, true, false, NULL, component_id);

	attestation_requester_testing_send_and_receive_cerberus_challenge (test, true, false, false,
		false, false, false, false, 5, 0, 0, 0, 0, 0, 0, true, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_different_measurement_hash_algo (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct pcr_measured_data pcr_cfm_valid_measured_data;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t attestation_status_expected[6] = {0x32, 0x00, 0x00, 0x00, 0x01, 0x00};
	uint8_t attestation_status_expected_pcr[11] = {0};
	uint8_t pcr_event_version_info[5] = {0};
	uint8_t *attestation_status;
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t version[4] = {0};
	uint8_t event = 0;
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_384;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_384;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 8);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 9, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 10);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, 0);
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (version, sizeof (version)),
		MOCK_ARG (sizeof (version)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (&event, sizeof (event)),
		MOCK_ARG (sizeof (event)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (attestation_status_expected,
		sizeof (attestation_status_expected)), MOCK_ARG (sizeof (attestation_status_expected)));
	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.finish,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	pcr_cfm_valid_measured_data.type = PCR_DATA_TYPE_MEMORY;
	pcr_cfm_valid_measured_data.data.memory.buffer = testing.device_mgr.attestation_status;
	pcr_cfm_valid_measured_data.data.memory.length = sizeof (attestation_status_expected);

	pcr_store_set_measurement_data (&testing.store, 0, &pcr_cfm_valid_measured_data);

	attestation_requester_discovery_and_attestation_loop (&testing.test, &testing.store, 0, 0);

	status = device_manager_get_attestation_status (&testing.device_mgr,
		(const uint8_t**) &attestation_status);
	CuAssertIntEquals (test, sizeof (attestation_status_expected), status);

	status = testing_validate_array (attestation_status_expected, attestation_status, status);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_get_measurement_data (&testing.store, 0, 0, attestation_status_expected_pcr,
		sizeof (attestation_status_expected_pcr));
	CuAssertIntEquals (test, sizeof (attestation_status_expected_pcr), status);

	status = testing_validate_array (attestation_status_expected_pcr, pcr_event_version_info,
		sizeof (pcr_event_version_info));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (attestation_status_expected_pcr +
		sizeof (pcr_event_version_info) , attestation_status, sizeof (attestation_status_expected));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 12;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature, &signature[ECC_KEY_LENGTH_256],
		ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc, 0,
		MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69), MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_1_1_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 12;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 2;
		digest2[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest2;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 12;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_1_1_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 12;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 2;
		digest2[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest2;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_1_1_only_challenge (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 2;
		digest2[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest2;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_only_pmr0_get_cert_unsupported (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.meas_cap_sign_unsupported = true;
	testing.hashing_alg_supported = 0;
	testing.asymmetric_key_signature_alg_unsupported = true;
	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 3,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 6, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED_WITHOUT_CERTS, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_1_1_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_1_1_only_pmr0_get_cert_unsupported (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;
	testing.meas_cap_sign_unsupported = true;
	testing.hashing_alg_supported = 0;
	testing.asymmetric_key_signature_alg_unsupported = true;
	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 3, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED_WITHOUT_CERTS, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t measurement[SHA384_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
		measurement[i + SHA384_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_1_1_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t measurement[SHA384_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA384_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	uint8_t measurement[SHA512_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
		measurement[i + SHA512_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha512,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_1_1_only_pmr0 (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	uint8_t measurement[SHA512_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA512_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha512,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_multiple_pmr0_options (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 2;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i + SHA256_HASH_LENGTH] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_1_1_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true, \
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t measurement[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA384;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_1_1_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t measurement[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA384;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t measurement[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA512;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_1_1_only_measurement (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t measurement[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA512;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_multiple_measurement_options (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 2;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i + SHA256_HASH_LENGTH] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_digests allowable_digests2;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;
	container2.measurement.digest.allowable_digests = &allowable_digests2;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container2.measurement.digest.pmr_id = 0;
	container2.measurement.digest.measurement_id = 2;
	container2.measurement.digest.allowable_digests_count = 1;
	container2.measurement.digest.allowable_digests[0].version_set = 1;
	container2.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[0].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[0].digests.digests = measurement2;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 2 - 1;
		digest4[i] = i * 3 - 1;
		measurement[i] = 50 + i;
		measurement2[i] = 100 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_version_set_0_permitted (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_digests allowable_digests2;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;
	container2.measurement.digest.allowable_digests = &allowable_digests2;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container2.measurement.digest.pmr_id = 0;
	container2.measurement.digest.measurement_id = 2;
	container2.measurement.digest.allowable_digests_count = 1;
	container2.measurement.digest.allowable_digests[0].version_set = 0;
	container2.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[0].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[0].digests.digests = measurement2;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 2 - 1;
		digest4[i] = i * 3 - 1;
		measurement[i] = 50 + i;
		measurement2[i] = 100 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_skip_inapplicable_version_set (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_digests allowable_digests2;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;
	container2.measurement.digest.allowable_digests = &allowable_digests2;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container2.measurement.digest.pmr_id = 0;
	container2.measurement.digest.measurement_id = 2;
	container2.measurement.digest.allowable_digests_count = 1;
	container2.measurement.digest.allowable_digests[0].version_set = 2;
	container2.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[0].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[0].digests.digests = measurement2;


	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 2 - 1;
		digest4[i] = i * 3 - 1;
		measurement[i] = 50 + i;
		measurement2[i] = 100 - i + 1;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks_multiple_allowable_digests_for_different_version_sets (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_digests allowable_digests2[2];
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;
	container2.measurement.digest.allowable_digests = allowable_digests2;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container2.measurement.digest.pmr_id = 0;
	container2.measurement.digest.measurement_id = 2;
	container2.measurement.digest.allowable_digests_count = 2;
	container2.measurement.digest.allowable_digests[0].version_set = 2;
	container2.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[0].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[0].digests.digests = measurement3;
	container2.measurement.digest.allowable_digests[1].version_set = 1;
	container2.measurement.digest.allowable_digests[1].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[1].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[1].digests.digests = measurement2;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 2 - 1;
		digest4[i] = i * 3 - 1;
		measurement[i] = 50 + i;
		measurement2[i] = 100 - i;
		measurement3[i] = 100 - i + 10;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks_fail_on_second (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_digests allowable_digests2;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;
	container2.measurement.digest.allowable_digests = &allowable_digests2;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container2.measurement.digest.pmr_id = 0;
	container2.measurement.digest.measurement_id = 2;
	container2.measurement.digest.allowable_digests_count = 1;
	container2.measurement.digest.allowable_digests[0].version_set = 1;
	container2.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container2.measurement.digest.allowable_digests[0].digests.hash_type =
		HASH_TYPE_SHA256;
	container2.measurement.digest.allowable_digests[0].digests.digests = measurement2;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 2 - 1;
		digest4[i] = i * 3 - 1;
		measurement[i] = 50 + i;
		measurement2[i] = 100 - i + 1;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_equal (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_equal_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = true;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_equal_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 10 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_equal_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 0x11;
	measurement2[1] = 0x22;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 10 + i;
		measurement[i + SHA256_HASH_LENGTH] = 11 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = true;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 10 + i;
		measurement[i + SHA256_HASH_LENGTH] = 11 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 0x11;
	measurement2[1] = 0x22;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_fail_second_data_entry (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 10 + i;
		measurement[i + SHA256_HASH_LENGTH] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;
	measurement2[1] = 53;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,	component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = true;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 53;
	measurement2[1] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,	component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_LESS_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 50;
	measurement2[1] = 53;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_LESS_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 52;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = true;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 52;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 50;
	measurement2[1] = 53;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 50;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 52;
	measurement2[1] = 51;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = true;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 52;
	measurement2[1] = 51;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_big_endian (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 50;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data data;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 52;
	measurement2[1] = 51;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 52;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	measurement2[0] = 52;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = measurement_bitmask;
	data.bitmask_length = sizeof (measurement_bitmask);
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement2[0] = 50;
	measurement2[1] = 53;
	measurement_bitmask[0] = 0x00;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.measurement_modify = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 25 + i;
		measurement[i + SHA256_HASH_LENGTH] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 25 + i;
		measurement[i + SHA256_HASH_LENGTH] = 75 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_not_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 20 + i;
		measurement[i + SHA256_HASH_LENGTH] = 30 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_not_equal_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_NOT_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
		measurement[i + SHA256_HASH_LENGTH] = 105 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_less_than (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 100 + i;
		measurement[i + SHA256_HASH_LENGTH] = 101 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_less_than_or_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_LESS_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 100 + i;
		measurement[i + SHA256_HASH_LENGTH] = 101 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_greater_than (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 49 + i;
		measurement[i + SHA256_HASH_LENGTH] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_greater_than_or_equal (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_GREATER_THAN_OR_EQUAL;
	data.big_endian = false;
	data.data_count = 2;
	data.allowable_data[0].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;
	data.allowable_data[1].data_len = SHA256_HASH_LENGTH;
	data.allowable_data[1].data = &measurement[SHA256_HASH_LENGTH];
	data.allowable_data[1].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 49 + i;
		measurement[i + SHA256_HASH_LENGTH] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_2_data_checks (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data[2];
	struct cfm_allowable_data_entry data_entry[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement_bitmask[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data[0].allowable_data = &data_entry[0];
	data[1].allowable_data = &data_entry[1];

	data[0].bitmask = measurement_bitmask;
	data[0].bitmask_length = sizeof (measurement_bitmask);
	data[0].check = CFM_CHECK_EQUAL;
	data[0].big_endian = false;
	data[0].data_count = 1;
	data[0].allowable_data[0].data_len = sizeof (measurement);
	data[0].allowable_data[0].data = measurement;
	data[0].allowable_data[0].version_set = 1;

	data[1].bitmask = NULL;
	data[1].bitmask = 0;
	data[1].check = CFM_CHECK_EQUAL;
	data[1].big_endian = false;
	data[1].data_count = 1;
	data[1].allowable_data[0].data_len = sizeof (measurement2);
	data[1].allowable_data[0].data = measurement2;
	data[1].allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = data;
	container.measurement.data.data_checks_count = 2;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
		measurement2[i] = 51 + i;
		measurement_bitmask[i] = 0xFF;
	}

	measurement[0] = 0x11;
	measurement2[1] = 0xCC;
	measurement_bitmask[0] = 0;

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_1_1 (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.spdm_max_version = 1;
	testing.spdm_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_sha384 (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t measurement[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_sha512 (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t measurement[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_2_measurement_blocks (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_data data;
	struct cfm_allowable_data data2;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data_entry data_entry2;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;
	data2.allowable_data = &data_entry2;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	data2.bitmask = NULL;
	data2.bitmask_length = 0;
	data2.check = CFM_CHECK_EQUAL;
	data2.big_endian = false;
	data2.data_count = 1;
	data2.allowable_data[0].data_len = sizeof (measurement2);
	data2.allowable_data[0].data = measurement2;
	data2.allowable_data[0].version_set = 1;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data2;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 101 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_version_set_0_permitted (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_data data;
	struct cfm_allowable_data data2;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data_entry data_entry2;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;
	data2.allowable_data = &data_entry2;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	data2.bitmask = NULL;
	data2.bitmask_length = 0;
	data2.check = CFM_CHECK_EQUAL;
	data2.big_endian = false;
	data2.data_count = 1;
	data2.allowable_data[0].data_len = sizeof (measurement2);
	data2.allowable_data[0].data = measurement2;
	data2.allowable_data[0].version_set = 0;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data2;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 101 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_skip_inapplicable_version_set (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_data data;
	struct cfm_allowable_data data2;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data_entry data_entry2;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;
	data2.allowable_data = &data_entry2;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	data2.bitmask = NULL;
	data2.bitmask_length = 0;
	data2.check = CFM_CHECK_EQUAL;
	data2.big_endian = false;
	data2.data_count = 1;
	data2.allowable_data[0].data_len = sizeof (measurement2);
	data2.allowable_data[0].data = measurement2;
	data2.allowable_data[0].version_set = 2;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data2;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 101 - i + 1;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_data_entries_for_different_version_sets (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_data data;
	struct cfm_allowable_data data2;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data_entry data_entry2[2];
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t measurement3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;
	data2.allowable_data = data_entry2;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	data2.bitmask = NULL;
	data2.bitmask_length = 0;
	data2.check = CFM_CHECK_EQUAL;
	data2.big_endian = false;
	data2.data_count = 2;
	data2.allowable_data[0].data_len = sizeof (measurement3);
	data2.allowable_data[0].data = measurement3;
	data2.allowable_data[0].version_set = 2;
	data2.allowable_data[1].data_len = sizeof (measurement2);
	data2.allowable_data[1].data = measurement2;
	data2.allowable_data[1].version_set = 1;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data2;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 101 - i;
		measurement3[i] = 101 - i + 1;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_2_measurement_blocks_fail_on_second (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_data data;
	struct cfm_allowable_data data2;
	struct cfm_allowable_data_entry data_entry;
	struct cfm_allowable_data_entry data_entry2;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;
	data2.allowable_data = &data_entry2;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	data2.bitmask = NULL;
	data2.bitmask_length = 0;
	data2.check = CFM_CHECK_EQUAL;
	data2.big_endian = false;
	data2.data_count = 1;
	data2.allowable_data[0].data_len = sizeof (measurement2);
	data2.allowable_data[0].data = measurement2;
	data2.allowable_data[0].version_set = 1;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data2;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 101 - i + 1;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_measurement_data_no_checks (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = NULL;
	container.measurement.data.data_checks_count = 0;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_FAILED_TO_SELECT_VERSION_SET, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_then_measurement_data (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;
	data.allowable_data = &data_entry;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;
	container.measurement.digest.measurement_id = 1;
	container.measurement.digest.pmr_id = 0;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 2;
	container2.measurement.data.data_checks = &data;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 50 + i;
		measurement2[i] = 101 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = false;
	testing.raw_rsp[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_data_then_measurement (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_measurement_container container2;
	struct cfm_allowable_digests allowable_digests;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t digest4[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t signature2[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der2[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;
	data.allowable_data = &data_entry;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement2;
	container.measurement.digest.measurement_id = 2;
	container.measurement.digest.pmr_id = 0;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container2.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container2.measurement.data.pmr_id = 0;
	container2.measurement.data.measurement_id = 1;
	container2.measurement.data.data_checks = &data;
	container2.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = i * 3 + 1;
		digest4[i] = i * 2 + 1;
		measurement[i] = 51 + i;
		measurement2[i] = 100 - i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
		signature2[i] = i * 10 - 1;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	status = ecc_der_encode_ecdsa_signature (signature2,
		&signature2[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der2, sizeof (sig_der2));
	CuAssertIntEquals (test, 71, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.raw_rsp[1] = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 9,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 12, 2);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest3, sizeof (digest3),
		-1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest3, sizeof (digest3)),
		MOCK_ARG (sizeof (digest3)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest4, sizeof (digest4),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_PTR_CONTAINS_TMP (digest4, sizeof (digest4)),
		MOCK_ARG (sizeof (digest4)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der2, 71),
		MOCK_ARG (71));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container2,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm,
		CFM_ENTRY_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (0));
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_no_cert_retrieval (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	for (i = 0; i < sizeof (digest); ++i) {
		cert_chain_digest[i] = i;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 4);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69), MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_alias_key (&testing.device_mgr, 0x0A,
		RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
		X509_PUBLIC_KEY_ECC);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_no_cert_retrieval (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		cert_chain_digest[i] = i;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 4);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_alias_key (&testing.device_mgr, 0x0A,
		RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
		X509_PUBLIC_KEY_ECC);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_no_cert_retrieval (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		cert_chain_digest[i] = i;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 4);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_alias_key (&testing.device_mgr, 0x0A,
		RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
		X509_PUBLIC_KEY_ECC);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_update_cert_chain (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	for (i = 0; i < sizeof (cert_chain_digest); ++i) {
		cert_chain_digest[i] = i * 5;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_update_cert_chain (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	for (i = 0; i < sizeof (cert_chain_digest); ++i) {
		cert_chain_digest[i] = i * 5;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_update_cert_chain (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest2[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	uint8_t cert_chain_digest[SHA512_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	for (i = 0; i < sizeof (cert_chain_digest); ++i) {
		cert_chain_digest[i] = i * 5;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_cert_chain_digest (&testing.device_mgr, 0x0A,
		ATTESTATION_RIOT_SLOT_NUM, cert_chain_digest, sizeof (cert_chain_digest));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_vendor_root_ca (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, true, false, ca_digests, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_riot_root_ca (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, true, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_mbedtls_x509 (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, false,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, false, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_already_authenticated (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_device_state_by_eid (&testing.device_mgr, 0x0A,
		DEVICE_MANAGER_AUTHENTICATED);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_cert_retrieval_more_than_one_transaction (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t out_digest[SHA384_HASH_LENGTH] = {0};
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t *pub_key;
	size_t cert_chain_overhead = sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH;
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	for (i = 0; i < sizeof (out_digest); ++i) {
		out_digest[i] = i;
	}

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	pub_key = platform_malloc (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);
	CuAssertPtrNotNull (test, pub_key);

	memcpy (pub_key, RIOT_CORE_ALIAS_PUBLIC_KEY, RIOT_CORE_ALIAS_PUBLIC_KEY_LEN);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.max_cert_buffer_portion = testing.cert_buffer_len - 100;
	testing.multiple_cert_calls = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.max_cert_buffer_portion, 0);

	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 5, 100, testing.max_cert_buffer_portion);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (testing.cert_buffer_len - cert_chain_overhead));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (testing.cert_buffer_len - X509_CERTSS_ECC_CA_NOPL_DER_LEN - cert_chain_overhead));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (testing.cert_buffer_len - RIOT_CORE_DEVID_SIGNED_CERT_LEN -
			X509_CERTSS_ECC_CA_NOPL_DER_LEN - cert_chain_overhead));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key_type,
		&testing.x509_mock, X509_PUBLIC_KEY_ECC, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.x509_mock.mock, 1, &pub_key, sizeof (pub_key), -1);
	status |= mock_expect_output (&testing.x509_mock.mock, 2,
		&RIOT_CORE_ALIAS_PUBLIC_KEY_LEN,
		sizeof (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), -1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha384, &testing.primary_hash, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG (testing.cert_buffer_len), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, out_digest, SHA384_HASH_LENGTH,
		-1);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 6);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_multiple_pmr0_digest_options (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 2;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i + SHA256_HASH_LENGTH] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_no_secondary_hash (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 101;
	struct cfm_component_device component_device;
	int status;

	component_device.attestation_protocol = CFM_ATTESTATION_DMTF_SPDM;
	component_device.cert_slot = ATTESTATION_RIOT_SLOT_NUM;
	component_device.component_id = component_id;
	component_device.num_pmr_ids = 1;
	component_device.pmr_id_list = pmr_id_list;
	component_device.transcript_hash_type = HASH_TYPE_SHA1;
	component_device.measurement_hash_type = HASH_TYPE_SHA1;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, NULL, &testing.ecc.base,
		&testing.rsa.base, &testing.x509_mock.base, &testing.rng.base, &testing.riot,
		&testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 0);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_OPERATION, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_start_hash_sha256_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, 0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_start_hash_sha384_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, 0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_start_hash_sha512_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, 0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_req_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, true, false, false,
		0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_response_not_ready (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_GET_VERSION;

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, true, false, false,
		0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_unexpected_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, true, false,
		0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, false, false, false,
		false, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_unsupported_major_version (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false, true,
		0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_DEVICE_NOT_INTEROPERABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_unsupported_minor_version (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.spdm_min_version = 3;
	testing.spdm_max_version = 3;

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_DEVICE_NOT_INTEROPERABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_unsupported_prerelease_version (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.spdm_alpha_version = 1;

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_DEVICE_NOT_INTEROPERABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_version_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, true,
		&testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_req_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	size_t req_len;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;

	if (testing.spdm_version >= 2) {
		req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
		req_len = sizeof (struct spdm_get_capabilities);
	}
	else {
		req_len = sizeof (struct spdm_get_capabilities_1_1);
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (&req, req_len),
		MOCK_ARG (req_len));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, true, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_response_not_ready (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_GET_CAPABILITIES;

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, true, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, true,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_no_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = SPDM_CT_EXPONENT;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, false, false, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_not_supported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = 20;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	testing.meas_cap_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_MEAS_NOT_SUPPORTED_BY_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_supported_without_sig (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = 20;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	testing.meas_cap_sign_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_MEAS_CAP_MISMATCH_BY_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_supported_with_sig_get_cert_unsupported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = 20;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_MEAS_CAP_MISMATCH_BY_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_challenge_supported_get_cert_unsupported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_capabilities req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_capabilities));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.base_capabilities.header.spdm_minor_version = testing.spdm_version;
	req.base_capabilities.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.base_capabilities.header.req_rsp_code = SPDM_REQUEST_GET_CAPABILITIES;

	req.base_capabilities.ct_exponent = 20;
	req.base_capabilities.flags.cache_cap = 0;
	req.base_capabilities.flags.cert_cap = 0;
	req.base_capabilities.flags.chal_cap = 0;
	req.base_capabilities.flags.meas_cap = 0;
	req.base_capabilities.flags.meas_fresh_cap = 0;
	req.base_capabilities.flags.encrypt_cap = 0;
	req.base_capabilities.flags.mac_cap = 0;
	req.base_capabilities.flags.mut_auth_cap = 0;
	req.base_capabilities.flags.key_ex_cap = 0;
	req.base_capabilities.flags.psk_cap = 0;
	req.base_capabilities.flags.encap_cap = 0;
	req.base_capabilities.flags.hbeat_cap = 0;
	req.base_capabilities.flags.key_upd_cap = 0;
	req.base_capabilities.flags.handshake_in_the_clear_cap = 0;
	req.base_capabilities.flags.pub_key_id_cap = 0;
	req.data_transfer_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;
	req.max_spdm_msg_size = MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY;

	testing.meas_cap_sign_unsupported = true;
	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		1, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CHAL_CAP_MISMATCH_BY_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_capabilities_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, true,
		&testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_req_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, true,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_response_not_ready (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, true,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		true, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_no_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, false, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_measurement_spec (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;
	testing.measurement_spec_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_MEASUREMENT_SPEC, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_mismatched_base_asym_key_sig_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	testing.asymmetric_key_signature_alg_mismatched = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_supported_base_asym_key_sig_alg_get_cert_unsupported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	testing.meas_cap_sign_unsupported = true;
	testing.challenge_unsupported = true;
	testing.hashing_alg_supported = 0;
	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_supported_hash_alg_get_cert_unsupported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	testing.meas_cap_sign_unsupported = true;
	testing.challenge_unsupported = true;
	testing.asymmetric_key_signature_alg_unsupported = 1;
	testing.get_cert_unsupported = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_hash_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_384;

	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_512 + 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_hash_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_384;

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_256;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_ALG_IN_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_meas_hash_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_512 + 1;

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_256;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_meas_hash_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_negotiate_algorithms_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_negotiate_algorithms_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_384;

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_NEGOTIATE_ALGORITHMS;

	req.length = sizeof (struct spdm_negotiate_algorithms_request);
	req.measurement_specification = SPDM_MEASUREMENT_SPEC_DMTF;
	req.base_asym_algo = SPDM_TPM_ALG_ECDSA_ECC_NIST_P256 |
		SPDM_TPM_ALG_ECDSA_ECC_NIST_P384 | SPDM_TPM_ALG_ECDSA_ECC_NIST_P521;
	req.base_hash_algo = SPDM_TPM_ALG_SHA_256;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_capabilities_with_mocks (test, 0, false,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 2, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_ALG_IN_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_negotiate_algorithms_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		true, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_req_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, true, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_unexpected_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, false, true, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, false, false, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_invalid_rsp_len (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	testing.rsp_len_invalid[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, false, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_BAD_LENGTH, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_req_slot_empty (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, 1, 0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, false, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUESTED_SLOT_NUM_EMPTY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, true, true,
		false, &testing, 3);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_rsp_not_ready (CuTest *test)
{
	uint8_t rsp_buf[sizeof (struct spdm_get_digests_response) + HASH_MAX_HASH_LEN];
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 101;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	struct cmd_packet tx_packet;
	struct mctp_base_protocol_transport_header *header;
	struct spdm_protocol_mctp_header *mctp;
	struct spdm_respond_if_ready_request *request;
	struct spdm_get_digests_response *rsp = (struct spdm_get_digests_response*) &rsp_buf;
	struct cfm_component_device component_device;
	size_t rsp_len;
	size_t offset;
	size_t i;
	int status;
	const struct pcr_config pcr_config[2] = {
		{
			.num_measurements = 6,
			.measurement_algo = HASH_TYPE_SHA256
		},
		{
			.num_measurements = 6,
			.measurement_algo = HASH_TYPE_SHA256
		}
	};

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	component_device.attestation_protocol = CFM_ATTESTATION_DMTF_SPDM;
	component_device.cert_slot = ATTESTATION_RIOT_SLOT_NUM;
	component_device.component_id = component_id;
	component_device.num_pmr_ids = 1;
	component_device.pmr_id_list = pmr_id_list;
	component_device.measurement_hash_type = HASH_TYPE_SHA384;
	component_device.transcript_hash_type = HASH_TYPE_SHA384;

	memset (&testing, 0, sizeof (struct attestation_requester_testing));

	testing.cert_buffer_len = sizeof (struct spdm_certificate_chain);
	testing.max_protocol_version = 255;
	testing.spdm_version = 2;
	testing.spdm_min_version = 1;
	testing.spdm_max_version = 2;

	status = hash_mock_init (&testing.primary_hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_init (&testing.secondary_hash);
	CuAssertIntEquals (test, 0, status);

	status = ecc_mock_init (&testing.ecc);
	CuAssertIntEquals (test, 0, status);

	status = rsa_mock_init (&testing.rsa);
	CuAssertIntEquals (test, 0, status);

	status = x509_mock_init (&testing.x509_mock);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&testing.rng);
	CuAssertIntEquals (test, 0, status);

	status = keystore_mock_init (&testing.keystore);
	CuAssertIntEquals (test, 0, status);

	status = cmd_channel_mock_init (&testing.channel, 0);
	CuAssertIntEquals (test, 0, status);

	status = firmware_update_control_mock_init (&testing.fw_update);
	CuAssertIntEquals (test, 0, status);

	status = attestation_responder_mock_init (&testing.attestation_responder);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&testing.store, pcr_config, ARRAY_SIZE (pcr_config));
	CuAssertIntEquals (test, 0, status);

	status = cmd_background_mock_init (&testing.background);
	CuAssertIntEquals (test, 0, status);

	status = cmd_authorization_mock_init (&testing.authorization);
	CuAssertIntEquals (test, 0, status);

	status = cmd_device_mock_init (&testing.device);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_mock_init (&testing.cfm_manager);
	CuAssertIntEquals (test, 0, status);

	status = cfm_mock_init (&testing.cfm);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.keystore.mock, testing.keystore.base.load_key,
		&testing.keystore, KEYSTORE_NO_KEY, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.keystore.mock, 1, &testing.dev_id_der,
		sizeof (testing.dev_id_der), -1);
	CuAssertIntEquals (test, 0, status);

	keys.alias_cert_length = RIOT_CORE_ALIAS_CERT_LEN;
	keys.devid_cert_length = RIOT_CORE_DEVID_CERT_LEN;
	keys.alias_key_length = RIOT_CORE_ALIAS_KEY_LEN;

	status = riot_key_manager_init_static (&testing.riot, &testing.keystore.base, &keys,
		&testing.x509_mock.base);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_init (&testing.device_mgr, 1, 1, 1, DEVICE_MANAGER_PA_ROT_MODE,
		DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE, 10, 10, 10, 10, 0, 0, 1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 0,
		MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 1, 0x0A, 0x20,
		1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_device_state (&testing.device_mgr, 1,
		DEVICE_MANAGER_UNIDENTIFIED);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_add_unidentified_device (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, 0, status);

	fw_ver_list[0] = "1.1.1.1";
	testing.fw_version.count = 1;
	testing.fw_version.id = fw_ver_list;

	status = cmd_interface_system_init (&testing.cmd_cerberus, &testing.fw_update.base, NULL,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, &testing.attestation_responder.base,
		&testing.device_mgr, &testing.store, &testing.primary_hash.base,
		&testing.background.base, NULL, NULL, &testing.fw_version, &testing.riot,
		&testing.authorization.base, NULL, NULL, NULL,	NULL, NULL, NULL, &testing.device.base, 1,
		2, 3, 4, NULL);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_init (&testing.cmd_mctp, &testing.device_mgr, 0x1414, 4);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_init (&testing.cmd_spdm);
	CuAssertIntEquals (test, 0, status);

	status = mctp_interface_init (&testing.mctp, &testing.cmd_cerberus.base,
		&testing.cmd_mctp.base, &testing.cmd_spdm.base, &testing.device_mgr);
	CuAssertIntEquals (test, 0, status);

	testing.max_cert_buffer_portion = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	memset (testing.hash_len, SHA384_HASH_LENGTH, sizeof (testing.hash_len));
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_384;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_384;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_384;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_384;
	testing.cert_buffer_len += SHA384_HASH_LENGTH;

	memcpy (&cert_buffer[testing.cert_buffer_len], X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN);

	testing.cert_buffer_len += X509_CERTSS_ECC_CA_NOPL_DER_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len], RIOT_CORE_DEVID_SIGNED_CERT,
		RIOT_CORE_DEVID_SIGNED_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_DEVID_SIGNED_CERT_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len], RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_ALIAS_CERT_LEN;

	status = device_manager_update_mctp_bridge_device_entry (&testing.device_mgr, 1, 0xAA, 0xBB,
		0xCC, 0xDD,	1, component_id, 1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_device_state (&testing.device_mgr, 1,
		DEVICE_MANAGER_READY_FOR_ATTESTATION);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 0);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, &testing.rsa.base, &testing.x509_mock.base, &testing.rng.base,
		&testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_system_add_cerberus_protocol_observer (&testing.cmd_cerberus,
		&testing.test.cerberus_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_add_spdm_protocol_observer (&testing.cmd_spdm,
		&testing.test.spdm_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_add_mctp_control_protocol_observer (&testing.cmd_mctp,
		&testing.test.mctp_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_add_observer (&testing.cfm_manager.base, &testing.test.cfm_observer);
	CuAssertIntEquals (test, 0, status);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_GET_DIGESTS;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, true, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	CuAssertIntEquals (test, 0, status);

	memset (&tx_packet, 0, sizeof (tx_packet));

	header = (struct mctp_base_protocol_transport_header*) tx_packet.data;

	header->cmd_code = SMBUS_CMD_CODE_MCTP;
	header->byte_count = 0x0A;
	header->source_addr = (0x41 << 1) | 1;
	header->rsvd = 0;
	header->header_version = 1;
	header->destination_eid = 0x0A;
	header->source_eid = MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID;
	header->som = 1;
	header->eom = 1;
	header->tag_owner = MCTP_BASE_PROTOCOL_TO_REQUEST;
	header->msg_tag = 4;
	header->packet_seq = 0;

	offset = sizeof (struct mctp_base_protocol_transport_header);
	mctp = (struct spdm_protocol_mctp_header*) &tx_packet.data[offset];

	mctp->msg_type = MCTP_BASE_PROTOCOL_MSG_TYPE_SPDM;

	offset += sizeof (struct spdm_protocol_mctp_header);
	request = (struct spdm_respond_if_ready_request*) &tx_packet.data[offset];

	request->header.spdm_minor_version = testing.spdm_version;
	request->header.spdm_major_version = SPDM_MAJOR_VERSION;
	request->header.req_rsp_code = SPDM_REQUEST_RESPOND_IF_READY;
	request->token = 1;
	request->original_request_code = SPDM_REQUEST_GET_DIGESTS;

	offset += sizeof (struct spdm_respond_if_ready_request);

	tx_packet.data[offset] = checksum_crc8 (0x20 << 1, tx_packet.data, offset);

	offset += MCTP_BASE_PROTOCOL_PEC_SIZE;

	tx_packet.pkt_size = offset;
	tx_packet.state = CMD_VALID_PACKET;
	tx_packet.dest_addr = 0x20;
	tx_packet.timeout_valid = false;

	status = mock_expect (&testing.channel.mock, testing.channel.base.send_packet, &testing.channel,
		0,
		MOCK_ARG_VALIDATOR_TMP (cmd_channel_mock_validate_packet, &tx_packet, sizeof (tx_packet)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect_external_action (&testing.channel.mock,
		attestation_requester_testing_spdm_get_digests_rsp_callback, &testing);
	CuAssertIntEquals (test, 0, status);

	rsp_len = sizeof (struct spdm_get_digests_response) + SHA384_HASH_LENGTH;

	memset (rsp_buf, 0, sizeof (rsp_buf));

	rsp->header.spdm_minor_version = testing.spdm_version;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_DIGESTS;

	rsp->slot_mask = 1;

	for (i = 0; i < SHA384_HASH_LENGTH; ++i) {
		rsp_buf[sizeof (struct spdm_get_digests_response) + i] = i;
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (rsp_buf, sizeof (rsp_buf)),
		MOCK_ARG (rsp_len));

	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 5, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 6);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)),MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_digests_rsp_not_ready_too_many_retries (
	CuTest *test)
{
	uint32_t component_id = 101;
	struct attestation_requester_testing testing;
	struct spdm_get_digests_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_digests_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_DIGESTS;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_GET_DIGESTS;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests (test, true, true, false, 3,
		&testing);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_TOO_MANY_RETRIES_REQUESTED, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_req_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.length = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.length = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, true, true, false,
		false, 4, &testing, 0, SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.length = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, true, false, true,
		false, 4, &testing, 0, SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.length = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, false, false, false,
		false, 4, &testing, 0, SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_rsp_unexpected_slot_num (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.length = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	testing.slot_num[0] = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, true, false, false,
		false, 4, &testing, 0, SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_SLOT_NUM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, true,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_rsp_rsp_too_large (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_certificate_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_certificate_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		0);

	testing.max_cert_buffer_portion = testing.cert_buffer_len - 100;
	testing.cert_rsp_too_large = true;

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_CERTIFICATE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.offset = testing.max_cert_buffer_portion;
	req.length = 100;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.max_cert_buffer_portion, 0);

	attestation_requester_testing_send_and_receive_spdm_get_certificate (test, true, false, false,
		false, 5, &testing, testing.max_cert_buffer_portion, 100);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_non_contiguous_mask_single (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 55;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_AUX_SLOT_NUM,
		component_id);

	testing.slot_num[0] = ATTESTATION_AUX_SLOT_NUM;
	testing.slot_num[1] = ATTESTATION_AUX_SLOT_NUM;
	testing.slot_mask = 1 << ATTESTATION_AUX_SLOT_NUM;

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_refresh_routing_table (&testing.test);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 2,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		true, &testing, 5);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 6, true, false, false, true, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, true,
		&testing, 7);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix, sizeof (combined_spdm_prefix)),
		MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);

	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);

	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));

	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));

	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);

	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));

	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_certificate_non_contiguous_mask_multiple (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 55;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 2;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_AUX_SLOT_NUM, component_id);

	testing.slot_num[0] = ATTESTATION_AUX_SLOT_NUM;
	testing.slot_num[1] = ATTESTATION_AUX_SLOT_NUM;
	testing.slot_mask = (1 << ATTESTATION_AUX_SLOT_NUM) | (1 << (ATTESTATION_AUX_SLOT_NUM + 2));

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_refresh_routing_table (&testing.test);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 2,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		true, &testing, 5);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 6, true, false, false, true, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, true,
		&testing, 7);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix, sizeof (combined_spdm_prefix)),
		MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));

	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);

	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);

	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));

	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));

	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);

	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));

	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_init_ca_cert_store_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 101;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_add_root_ca_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 101;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_RSA_CA_NOPL_DER, X509_CERTSS_RSA_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_RSA_CA_NOPL_DER_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_no_riot_ca_add_root_ca_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_vendor_root_ca_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_NO_MEMORY, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, CFM_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_vendor_root_ca_hash_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 50;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_vendor_root_ca_not_supported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 50;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	uint8_t out_digest[SHA256_HASH_LENGTH] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
		out_digest[i_digest] = 0x0b + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, out_digest, SHA256_HASH_LENGTH,
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_vendor_root_ca_add_root_ca_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_root_ca_digests root_ca_digests;
	uint32_t component_id = 50;
	uint8_t ca_digests[SHA256_HASH_LENGTH * 2] = {0};
	int i_digest;
	int status;

	for (i_digest = 0; i_digest < SHA256_HASH_LENGTH; ++i_digest) {
		ca_digests[i_digest] = 0x0a + i_digest;
	}

	memset (&root_ca_digests.digests, 0, sizeof (struct cfm_digests));

	root_ca_digests.digests.hash_type = HASH_TYPE_SHA256;
	root_ca_digests.digests.digest_count = 2;
	root_ca_digests.digests.digests = ca_digests;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &root_ca_digests,
		sizeof (struct cfm_root_ca_digests), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_root_ca_digest,
		&testing.cfm, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&root_ca_digests, sizeof (struct cfm_root_ca_digests)));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock,
		testing.primary_hash.base.calculate_sha256, &testing.primary_hash, 0,
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN),	MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2,
		&ca_digests[SHA256_HASH_LENGTH], SHA256_HASH_LENGTH, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_add_intermediate_ca_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_load_certificate_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_authenticate_cert_chain_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN + sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha256_hash_cert_chain_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN +	RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN + sizeof (struct spdm_certificate_chain) + SHA256_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha384_hash_cert_chain_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN + sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_sha512_hash_cert_chain_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha512,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN + sizeof (struct spdm_certificate_chain) + SHA512_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_compare_cert_chain_digest_fail (
	CuTest *test)
{
	uint8_t out_digest[SHA384_HASH_LENGTH] = {0};
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	/* create situation for contiguous slot mask */
	testing.slot_num[0] = ATTESTATION_RIOT_SLOT_NUM;
	testing.slot_mask = 1 << ATTESTATION_RIOT_SLOT_NUM;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_SIGNED_CERT_LEN + RIOT_CORE_ALIAS_CERT_LEN +
			sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, DEVICE_MGR_DIGEST_MISMATCH, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_public_key_type_fail (CuTest *test)
{
	uint8_t out_digest[SHA384_HASH_LENGTH] = {0};
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	int status;
	size_t i_digest;

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key_type,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_SIGNED_CERT_LEN + RIOT_CORE_ALIAS_CERT_LEN +
			sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_get_public_key_fail (CuTest *test)
{
	uint8_t out_digest[SHA384_HASH_LENGTH] = {0};
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	size_t i_digest;
	int status;

	for (i_digest = 0; i_digest < sizeof (out_digest); ++i_digest) {
		out_digest[i_digest] = i_digest;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks (test, false,
		false, &testing, 4, testing.cert_buffer_len, 0);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_root_ca_digest, &testing.cfm,
		CFM_ROOT_CA_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.init_ca_cert_store,
		&testing.x509_mock,	0, MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 0);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_root_ca,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (X509_CERTSS_ECC_CA_NOPL_DER, X509_CERTSS_ECC_CA_NOPL_DER_LEN),
		MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN + RIOT_CORE_DEVID_SIGNED_CERT_LEN +
			RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.add_intermediate_ca,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_DEVID_SIGNED_CERT, RIOT_CORE_DEVID_SIGNED_CERT_LEN),
		MOCK_ARG (RIOT_CORE_DEVID_SIGNED_CERT_LEN +	RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.load_certificate,
		&testing.x509_mock, 0, MOCK_ARG_NOT_NULL,
		MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_CERT_LEN));
	status |= mock_expect_save_arg (&testing.x509_mock.mock, 0, 1);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.authenticate,
		&testing.x509_mock,	0, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_SAVED_ARG (0));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key_type,
		&testing.x509_mock, X509_PUBLIC_KEY_ECC, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.get_public_key,
		&testing.x509_mock, X509_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (1), MOCK_ARG_NOT_NULL,
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_certificate,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (1));
	status |= mock_expect (&testing.x509_mock.mock, testing.x509_mock.base.release_ca_cert_store,
		&testing.x509_mock, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha384,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (X509_CERTSS_ECC_CA_NOPL_DER_LEN +
			RIOT_CORE_DEVID_SIGNED_CERT_LEN + RIOT_CORE_ALIAS_CERT_LEN +
			sizeof (struct spdm_certificate_chain) + SHA384_HASH_LENGTH),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output (&testing.primary_hash.mock, 2, out_digest, sizeof (out_digest),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, X509_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_generate_random_buffer_fail (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, RNG_ENGINE_NO_MEMORY, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, RNG_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_req_hash_update_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS ( &req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_rsp_fail (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, true, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_unexpected_rsp (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, true, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_no_rsp (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, false, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_rsp_unexpected_slot_num (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	testing.slot_num[1] = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_SLOT_NUM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_rsp_unsupported_mutual_auth (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	testing.unsupported_operation = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_OPERATION, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_rsp_req_slot_empty (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	testing.expected_slot_num_empty = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUESTED_SLOT_NUM_EMPTY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_invalid_rsp_len (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	testing.rsp_len_invalid[1] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_BAD_LENGTH, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_compare_cert_chain_digest_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	struct spdm_challenge_request req;
	int status;
	size_t i;

	memset (&req, 0, sizeof (struct spdm_challenge_request));

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	req.header.spdm_minor_version = testing.spdm_version;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_CHALLENGE;

	req.slot_num = ATTESTATION_RIOT_SLOT_NUM;
	req.req_measurement_summary_hash_type = SPDM_MEASUREMENT_SUMMARY_HASH_ALL;

	for (i = 0; i < sizeof (req.nonce); ++i) {
		req.nonce[i] = SPDM_NONCE_LEN - i;
	}

	testing.cert_chain_digest_compare_fail = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, req.nonce, sizeof (req.nonce), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_challenge (test, true, false, false, false,
		5, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, DEVICE_MGR_DIGEST_MISMATCH, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_rsp_hash_update_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, true, false,
		&testing, 5);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_hash_finish_fail (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha256_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t digest[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha384_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t digest[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha512_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t digest[SHA512_HASH_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_update_hash_prefix_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint8_t digest[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_update_hash_digest_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint8_t digest[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (digest,
			sizeof (digest)), MOCK_ARG (sizeof (digest)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_hash_finish_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint8_t digest[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_ecc_init_pub_key_fail (
	CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		ECC_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_ecc_verify_fail (CuTest *test)
{
	uint32_t component_id = 50;
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest2[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
			RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		ECC_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)), MOCK_ARG (sizeof (digest2)),
		MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69), MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair,
		&testing.ecc, 0, MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_get_component_pmr_digest_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, MANIFEST_NO_MEMORY, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MANIFEST_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_pmr0_digest_invalid_len (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_INVALID_ATTESTATION, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_challenge_no_pmr0_digest_match (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH] = {0};
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 2;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 5);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_get_pmr_digest_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_NO_MEMORY, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, CFM_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_start_hash_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_1_2_setup_device_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	struct spdm_get_version_request req;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, true, false, false,
		5, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_generate_random_buffer_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, RNG_ENGINE_NO_MEMORY, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, RNG_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_req_hash_update_fail (
	CuTest *test)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	req->header.spdm_minor_version = 1;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->measurement_operation = SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_rsp_fail (CuTest *test)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_response *rsp = (struct spdm_get_measurements_response*) &rsp_buf;
	struct spdm_measurements_block_header *block =
		(struct spdm_measurements_block_header*)
		spdm_get_measurements_resp_measurement_record (rsp);
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint16_t *opaque_length;
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t offset;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	req->header.spdm_minor_version = 1;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->measurement_operation = SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = 2;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	rsp->slot_id = ATTESTATION_RIOT_SLOT_NUM + 1;
	rsp->number_of_blocks = 2;

	rsp->measurement_record_len[0] = 2 * spdm_measurements_block_size (SHA256_HASH_LENGTH);

	offset = sizeof (struct spdm_get_measurements_response) +
		sizeof (struct spdm_measurements_block_header);

	block->index = 1;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 50 + i;
	}

	block =	(struct spdm_measurements_block_header*) &rsp_buf[offset];
	offset += sizeof (struct spdm_measurements_block_header);

	block->index = 2;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 100 - i;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < 5; ++i) {
		rsp_buf[offset + i] = i * 10;
	}

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, true, false,
		5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_no_rsp (CuTest *test)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_response *rsp = (struct spdm_get_measurements_response*) &rsp_buf;
	struct spdm_measurements_block_header *block =
		(struct spdm_measurements_block_header*)
		spdm_get_measurements_resp_measurement_record (rsp);
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint16_t *opaque_length;
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t offset;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	req->header.spdm_minor_version = 1;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->measurement_operation = SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = 2;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	rsp->slot_id = ATTESTATION_RIOT_SLOT_NUM + 1;
	rsp->number_of_blocks = 2;

	rsp->measurement_record_len[0] = 2 * spdm_measurements_block_size (SHA256_HASH_LENGTH);

	offset = sizeof (struct spdm_get_measurements_response) +
		sizeof (struct spdm_measurements_block_header);

	block->index = 1;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 50 + i;
	}

	block =	(struct spdm_measurements_block_header*) &rsp_buf[offset];
	offset += sizeof (struct spdm_measurements_block_header);

	block->index = 2;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 100 - i;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < 5; ++i) {
		rsp_buf[offset + i] = i * 10;
	}

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
			&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, false, false, false,
		5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_unexpected_rsp (
	CuTest *test)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_response *rsp = (struct spdm_get_measurements_response*) &rsp_buf;
	struct spdm_measurements_block_header *block =
		(struct spdm_measurements_block_header*)
		spdm_get_measurements_resp_measurement_record (rsp);
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint16_t *opaque_length;
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t offset;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	req->header.spdm_minor_version = 1;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->measurement_operation = SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = 2;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	rsp->slot_id = ATTESTATION_RIOT_SLOT_NUM + 1;
	rsp->number_of_blocks = 2;

	rsp->measurement_record_len[0] = 2 * spdm_measurements_block_size (SHA256_HASH_LENGTH);

	offset = sizeof (struct spdm_get_measurements_response) +
		sizeof (struct spdm_measurements_block_header);

	block->index = 1;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 50 + i;
	}

	block =	(struct spdm_measurements_block_header*) &rsp_buf[offset];
	offset += sizeof (struct spdm_measurements_block_header);

	block->index = 2;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 100 - i;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < 5; ++i) {
		rsp_buf[offset + i] = i * 10;
	}

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
			&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, true,
		5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_rsp_unexpected_slot_num (
	CuTest *test)
{
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t rsp_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_response *rsp = (struct spdm_get_measurements_response*) &rsp_buf;
	struct spdm_measurements_block_header *block =
		(struct spdm_measurements_block_header*)
		spdm_get_measurements_resp_measurement_record (rsp);
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint16_t *opaque_length;
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t offset;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.slot_num[1] = 1;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	req->header.spdm_minor_version = 1;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->measurement_operation = SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	rsp->header.spdm_minor_version = 2;
	rsp->header.spdm_major_version = SPDM_MAJOR_VERSION;
	rsp->header.req_rsp_code = SPDM_RESPONSE_GET_MEASUREMENTS;

	rsp->slot_id = ATTESTATION_RIOT_SLOT_NUM + 1;
	rsp->number_of_blocks = 2;

	rsp->measurement_record_len[0] = 2 * spdm_measurements_block_size (SHA256_HASH_LENGTH);

	offset = sizeof (struct spdm_get_measurements_response) +
		sizeof (struct spdm_measurements_block_header);

	block->index = 1;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 50 + i;
	}

	block =	(struct spdm_measurements_block_header*) &rsp_buf[offset];
	offset += sizeof (struct spdm_measurements_block_header);

	block->index = 2;
	block->measurement_size =
		sizeof (struct spdm_measurements_block_dmtf) + SHA256_HASH_LENGTH;
	block->measurement_specification = 1;
	block->dmtf.measurement_block_type = 0;
	block->dmtf.measurement_size = SHA256_HASH_LENGTH;
	block->dmtf.raw_bit_stream = 0;

	for (i = 0; i < SHA256_HASH_LENGTH; ++i, ++offset) {
		rsp_buf[offset] = 100 - i;
	}

	for (i = 0; i < SPDM_NONCE_LEN; ++i, ++offset) {
		rsp_buf[offset] = SPDM_NONCE_LEN - i;
	}

	opaque_length = (uint16_t*) &rsp_buf[offset];
	*opaque_length = 5;
	offset += 2;

	for (i = 0; i < *opaque_length; ++i, ++offset) {
		rsp_buf[offset] = 5 + i;
	}

	for (i = 0; i < 5; ++i) {
		rsp_buf[offset + i] = i * 10;
	}

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
			&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS, false, &testing);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_SLOT_NUM, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_rsp_hash_update_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		true, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_hash_finish_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest3); ++i) {
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha256_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha384_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA384_HASH_LENGTH];
	uint8_t digest3[SHA384_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA384;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA384, 4, true, false, false, NULL, false, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha512_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA512_HASH_LENGTH];
	uint8_t digest3[SHA512_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA512;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA512, HASH_TYPE_SHA512, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA512, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha512,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_update_hash_prefix_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_update_hash_digest_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)), MOCK_ARG (sizeof (digest)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_hash_finish_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY, MOCK_ARG_NOT_NULL,
		MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_ecc_init_pub_key_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		ECC_ENGINE_NO_MEMORY, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_ecc_verify_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		ECC_ENGINE_NO_MEMORY, MOCK_ARG_SAVED_ARG (0),
		MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)), MOCK_ARG (sizeof (digest)),
		MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69), MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ECC_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_hash_compute_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)), MOCK_ARG (sizeof (measurement)),
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_only_pmr0_no_pmr0_digest_match (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH * 2];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		measurement[i] = 50 + i;
		measurement[i + SHA256_HASH_LENGTH] = 100 - i;
		digest3[i] = i * 4;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = true;
	testing.spdm_version = 1;
	testing.spdm_max_version = 1;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 5, SPDM_MEASUREMENT_OPERATION_GET_ALL_BLOCKS);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.calculate_sha256,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (measurement, sizeof (measurement)),
		MOCK_ARG (sizeof (measurement)), MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.primary_hash.mock, 2, digest3, sizeof (digest3), -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_get_next_measurement_or_measurement_data_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, CFM_NO_MEMORY,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, CFM_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_get_measurement_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = digest;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
	}

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_only_measurement_version_set_selector_invalid (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 65;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	TEST_START;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 0;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = measurement;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_VERSION_SET_SELECTOR_INVALID, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_only_measurement_version_set_selection_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_digests allowable_digests;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	container.measurement.digest.allowable_digests = &allowable_digests;

	container.measurement.digest.pmr_id = 0;
	container.measurement.digest.measurement_id = 1;
	container.measurement_type = CFM_MEASUREMENT_TYPE_DIGEST;
	container.measurement.digest.allowable_digests_count = 1;
	container.measurement.digest.allowable_digests[0].version_set = 1;
	container.measurement.digest.allowable_digests[0].digests.digest_count = 1;
	container.measurement.digest.allowable_digests[0].digests.hash_type = HASH_TYPE_SHA256;
	container.measurement.digest.allowable_digests[0].digests.digests = digest;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, false,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_ATTESTATION_RULE_FAIL, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_data_get_measurement_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 50;
	uint8_t measurement[SHA256_HASH_LENGTH];
	int status;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_data_raw_requested_but_response_digest (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.digest_instead_of_raw = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_MEAS_RSP_NOT_RAW, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_data_num_blocks_in_rsp_not_one (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t rq_buf[MCTP_BASE_PROTOCOL_MAX_MESSAGE_BODY] = {0};
	struct spdm_get_measurements_request *req = (struct spdm_get_measurements_request*) rq_buf;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 50;
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t *slot_id;
	uint8_t *nonce;
	int status;
	size_t i;

	req->header.spdm_minor_version = 2;
	req->header.spdm_major_version = SPDM_MAJOR_VERSION;
	req->header.req_rsp_code = SPDM_REQUEST_GET_MEASUREMENTS;

	req->sig_required = 1;
	req->raw_bit_stream_requested = true;
	req->measurement_operation = 1;

	slot_id = spdm_get_measurements_rq_slot_id_ptr (req);
	*slot_id = ATTESTATION_RIOT_SLOT_NUM;

	nonce = spdm_get_measurements_rq_nonce (req);

	for (i = 0; i < SPDM_NONCE_LEN; ++i) {
		nonce[i] = SPDM_NONCE_LEN - i;
	}

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (measurement2); ++i) {
		measurement2[i] = 51 + i;
	}

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.num_blocks_incorrect = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		8, 1, true, &testing);

	status = mock_expect (&testing.rng.mock, testing.rng.base.generate_random_buffer,
		&testing.rng, 0, MOCK_ARG (SPDM_NONCE_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.rng.mock, 1, spdm_get_measurements_rq_nonce (req),
		SPDM_NONCE_LEN, -1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (req, spdm_get_measurements_rq_length (req)),
		MOCK_ARG (spdm_get_measurements_rq_length (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNEXPECTED_NUM_MEAS_BLOCKS, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_data_unexpected_measurement_block (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement2[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data = measurement2;
	data.allowable_data[0].data_len = sizeof (measurement2);
	data.allowable_data[0].version_set = 1;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement2[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;
	testing.unexpected_measurement_block = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_MEAS_OPERATION_UNEXPECTED, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_measurement_only_measurement_data_version_set_selector_invalid (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-measurements signing";
	struct cfm_measurement_container container;
	struct cfm_allowable_data data;
	struct cfm_allowable_data_entry data_entry;
	uint32_t component_id = 101;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t measurement[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	data.allowable_data = &data_entry;

	data.bitmask = NULL;
	data.bitmask_length = 0;
	data.check = CFM_CHECK_EQUAL;
	data.big_endian = false;
	data.data_count = 1;
	data.allowable_data[0].data_len = sizeof (measurement);
	data.allowable_data[0].data = measurement;
	data.allowable_data[0].version_set = 0;

	container.measurement_type = CFM_MEASUREMENT_TYPE_DATA;
	container.measurement.data.pmr_id = 0;
	container.measurement.data.measurement_id = 1;
	container.measurement.data.data_checks = &data;
	container.measurement.data.data_checks_count = 1;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		measurement[i] = 51 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.challenge_unsupported = true;
	testing.get_all_blocks = false;
	testing.raw_rsp[0] = true;

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 0,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 3);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 4, true, false, false, false, NULL, component_id);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);

	attestation_requester_testing_send_and_receive_spdm_get_measurements_with_mocks (test, true,
		false, &testing, 8, 1);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, CFM_PMR_DIGEST_NOT_FOUND, MOCK_ARG (component_id), MOCK_ARG (0),
		MOCK_ARG_NOT_NULL);
	status |= mock_expect (&testing.cfm.mock,
		testing.cfm.base.get_next_measurement_or_measurement_data, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL, MOCK_ARG (1));
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &container,
		sizeof (struct cfm_measurement_container), -1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_measurement_container,
		&testing.cfm, 0, MOCK_ARG_NOT_NULL);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_CFM_VERSION_SET_SELECTOR_INVALID, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_ATTESTATION_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_update_routing_table (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REFRESH_ROUTING_TABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_update_routing_table_bridge_refresh_request (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_refresh_routing_table (&testing.test);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REFRESH_ROUTING_TABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_unknown_device (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 50;
	const struct pcr_config pcr_config[1] = {
		{
			.num_measurements = 0,
			.measurement_algo = HASH_TYPE_SHA256
		}
	};
	int status;

	memset (&testing, 0, sizeof (struct attestation_requester_testing));

	testing.cert_buffer_len = sizeof (struct spdm_certificate_chain);
	testing.max_protocol_version = 255;
	testing.spdm_version = 2;
	testing.spdm_min_version = 1;
	testing.spdm_max_version = 2;

	memset (testing.hash_len, SHA256_HASH_LENGTH, sizeof (testing.hash_len));
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.cert_buffer_len += SHA256_HASH_LENGTH;

	memcpy (&cert_buffer[testing.cert_buffer_len], X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN);

	testing.cert_buffer_len += X509_CERTSS_ECC_CA_NOPL_DER_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len], RIOT_CORE_DEVID_SIGNED_CERT,
		RIOT_CORE_DEVID_SIGNED_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_DEVID_SIGNED_CERT_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len],
		RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_ALIAS_CERT_LEN;

	status = hash_mock_init (&testing.primary_hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_init (&testing.secondary_hash);
	CuAssertIntEquals (test, 0, status);

	status = ecc_mock_init (&testing.ecc);
	CuAssertIntEquals (test, 0, status);

	status = rsa_mock_init (&testing.rsa);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&testing.rng);
	CuAssertIntEquals (test, 0, status);

	status = keystore_mock_init (&testing.keystore);
	CuAssertIntEquals (test, 0, status);

	status = cmd_channel_mock_init (&testing.channel, 0);
	CuAssertIntEquals (test, 0, status);

	status = firmware_update_control_mock_init (&testing.fw_update);
	CuAssertIntEquals (test, 0, status);

	status = attestation_responder_mock_init (&testing.attestation_responder);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&testing.store, pcr_config, ARRAY_SIZE (pcr_config));
	CuAssertIntEquals (test, 0, status);

	status = cmd_background_mock_init (&testing.background);
	CuAssertIntEquals (test, 0, status);

	status = cmd_authorization_mock_init (&testing.authorization);
	CuAssertIntEquals (test, 0, status);

	status = cmd_device_mock_init (&testing.device);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_mock_init (&testing.cfm_manager);
	CuAssertIntEquals (test, 0, status);

	status = cfm_mock_init (&testing.cfm);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.keystore.mock, testing.keystore.base.load_key,
		&testing.keystore, KEYSTORE_NO_KEY, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.keystore.mock, 1, &testing.dev_id_der,
		sizeof (testing.dev_id_der), -1);
	CuAssertIntEquals (test, 0, status);

	keys.alias_cert_length = RIOT_CORE_ALIAS_CERT_LEN;
	keys.devid_cert_length = RIOT_CORE_DEVID_CERT_LEN;
	keys.alias_key_length = RIOT_CORE_ALIAS_KEY_LEN;

	status = riot_key_manager_init_static (&testing.riot, &testing.keystore.base, &keys,
		&testing.x509.base);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_init (&testing.device_mgr, 1, 1, 1, DEVICE_MANAGER_PA_ROT_MODE,
		DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE, 1000, 1000, 1000, 0, 0, 0, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 0,
		MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 1, 0x0A, 0x20,
		1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_mctp_bridge_device_entry (&testing.device_mgr, 1, 0xAA, 0xBB,
		0xCC, 0xDD,	1, component_id, 1);
	CuAssertIntEquals (test, 0, status);

	fw_ver_list[0] = "1.1.1.1";
	testing.fw_version.count = 1;
	testing.fw_version.id = fw_ver_list;

	status = cmd_interface_system_init (&testing.cmd_cerberus, &testing.fw_update.base, NULL,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, &testing.attestation_responder.base,
		&testing.device_mgr, &testing.store, &testing.primary_hash.base,
		&testing.background.base, NULL, NULL, &testing.fw_version, &testing.riot,
		&testing.authorization.base, NULL, NULL, NULL,	NULL, NULL, NULL, &testing.device.base, 1,
		2, 3, 4, NULL);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_init (&testing.cmd_mctp, &testing.device_mgr, 0x1414, 4);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_init (&testing.cmd_spdm);
	CuAssertIntEquals (test, 0, status);

	status = mctp_interface_init (&testing.mctp, &testing.cmd_cerberus.base,
		&testing.cmd_mctp.base, &testing.cmd_spdm.base, &testing.device_mgr);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base,	&testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, NULL, &testing.x509.base, &testing.rng.base, &testing.riot,
		&testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_system_add_cerberus_protocol_observer (&testing.cmd_cerberus,
		&testing.test.cerberus_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_add_spdm_protocol_observer (&testing.cmd_spdm,
		&testing.test.spdm_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0xCC);
	CuAssertIntEquals (test, DEVICE_MGR_UNKNOWN_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_unsupported_attestation_protocol (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, (enum cfm_attestation_type) 2, ATTESTATION_RIOT_SLOT_NUM, 0);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_PROTOCOL, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_spdm_response_not_ready_unexpected_requested_command (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct spdm_get_version_request req;
	int status;

	memset (&req, 0, sizeof (struct spdm_get_version_request));

	req.header.spdm_minor_version = 0;
	req.header.spdm_major_version = SPDM_MAJOR_VERSION;
	req.header.req_rsp_code = SPDM_REQUEST_GET_VERSION;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, true, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, 0);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha384,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (&req, sizeof (req)),
		MOCK_ARG (sizeof (req)));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.cancel,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.rsp_not_ready_request = SPDM_REQUEST_GET_CAPABILITIES;

	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, true, false, false,
		0, &testing);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_cfm_contains_unsupported_hash_alg (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	uint32_t component_id = 101;
	struct cfm_component_device component_device;
	int status;

	component_device.attestation_protocol = CFM_ATTESTATION_DMTF_SPDM;
	component_device.cert_slot = ATTESTATION_RIOT_SLOT_NUM;
	component_device.component_id = component_id;
	component_device.num_pmr_ids = 1;
	component_device.pmr_id_list = pmr_id_list;
	component_device.measurement_hash_type = (enum hash_type) 4;
	component_device.transcript_hash_type = HASH_TYPE_SHA1;

	TEST_START;

	setup_attestation_requester_mock_attestation_test (test, &testing, false, false, true, true,
		HASH_TYPE_SHA384, HASH_TYPE_SHA384, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base, &testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, &testing.rsa.base, &testing.x509_mock.base, &testing.rng.base,
		&testing.riot, &testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 0);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	component_device.measurement_hash_type = HASH_TYPE_SHA1;
	component_device.transcript_hash_type = (enum hash_type) 4;

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_UNSUPPORTED_ALGORITHM, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_attest_device_invalid_arg (CuTest *test)
{
	int status;

	TEST_START;

	status = attestation_requester_attest_device (NULL, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);
}

static void attestation_requester_test_discover_device_invalid_arg (CuTest *test)
{
	int status;

	TEST_START;

	status = attestation_requester_discover_device (NULL, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);
}

static void attestation_requester_test_discover_device_spdm (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_NEVER_ATTESTED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_1_1 (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;
	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0, true, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		5, 5, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_NEVER_ATTESTED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_update_routing_table (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REFRESH_ROUTING_TABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_update_routing_table_bridge_refresh_request (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_refresh_routing_table (&testing.test);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REFRESH_ROUTING_TABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_no_mctp_bridge (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, true, true);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, DEVICE_MGR_UNKNOWN_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_get_msg_type_unexpected_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, true, 0,
		&testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_get_msg_type_no_rsp (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, false, false, 0,
		&testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_get_msg_type_rsp_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.rsp_fail = true;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_get_msg_type_no_attestation_protocols_supported (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_setup_device_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, true, false, false,
		1, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, true, false,
		4, 0xEF, true, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_1_1_get_measurement_num_indices_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;
	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, true, false,
		4, 0, true, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_1_1_get_measurement_fail (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_max_version = 1;
	testing.spdm_version = 1;
	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0, true, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, true, false,
		5, 5, true, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_device_id_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.device_id_fail = true;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_GET_DEVICE_ID_FAIL, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_has_no_pci_ids (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.device_id_block_short = true;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_vid_not_in_device_mgr (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_not_in_device_mgr (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_vid_not_in_device_mgr (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_id_not_in_device_mgr (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_missing (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.discovery_id_missing = true;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_vid_not_in_response (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.discovery_id_missing = 1;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_not_in_response (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.discovery_id_missing = 2;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_vid_not_in_response (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.discovery_id_missing = 3;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_id_not_in_response (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.discovery_id_missing = 4;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_discover_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	status = device_manager_get_device_state (&testing.device_mgr, 1);
	CuAssertIntEquals (test, DEVICE_MANAGER_UNIDENTIFIED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAA, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDD, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xBB, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAB, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_table_already_up_to_date (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_table_bridge_refresh_request_ignored (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAA, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDD, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xBB, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAB, status);

	attestation_requester_refresh_routing_table (&testing.test);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_invalid_arg (CuTest *test)
{
	int status;

	TEST_START;

	status = attestation_requester_get_mctp_routing_table (NULL);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);
}

static void attestation_requester_test_get_routing_table_no_mctp_bridge (CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, true, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, DEVICE_MGR_UNKNOWN_DEVICE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_get_routing_table_entries_unexpected_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, true, 0, 0,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, ATTESTATION_REQUEST_FAILED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_get_routing_table_entries_no_rsp (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, false, false, 0, 0,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_RESPONSE_TIMEOUT, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_get_routing_table_get_routing_table_entries_rsp_fail (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	testing.rsp_fail = true;

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, MCTP_BASE_PROTOCOL_ERROR_RESPONSE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_reset_authenticated_devices_on_cfm_activation_request (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	status = device_manager_update_device_state_by_eid (&testing.device_mgr, 0x0A,
		DEVICE_MANAGER_READY_FOR_ATTESTATION);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_attest (&testing.device_mgr);
	CuAssertIntEquals (test, 0x0A, status);

	status = device_manager_update_device_state_by_eid (&testing.device_mgr, 0x0A,
		DEVICE_MANAGER_AUTHENTICATED);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_eid_of_next_device_to_attest (&testing.device_mgr);
	CuAssertIntEquals (test, DEVICE_MGR_NO_DEVICES_AVAILABLE, status);

	testing.test.cfm_observer.on_cfm_activation_request (&testing.test.cfm_observer);

	status = device_manager_get_eid_of_next_device_to_attest (&testing.device_mgr);
	CuAssertIntEquals (test, 0x0A, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discovery_and_attestation_loop_single_device_invalid_pcr_measurement (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct pcr_measured_data pcr_cfm_valid_measured_data;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t attestation_status_expected[6] = {0x32, 0x00, 0x00, 0x00, 0x01, 0x00};
	uint8_t *attestation_status;
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;
	struct logging_mock logger;
	struct debug_log_entry_info entry = {
		.format = DEBUG_LOG_ENTRY_FORMAT,
		.severity = DEBUG_LOG_SEVERITY_ERROR,
		.component = DEBUG_LOG_COMPONENT_ATTESTATION,
		.msg_index = ATTESTATION_LOGGING_PCR_UPDATE_ERROR,
		.arg1 = PCR_MEASUREMENT (0, 0),
		.arg2 = HASH_ENGINE_START_SHA256_FAILED
	};

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	status = logging_mock_init (&logger);
	CuAssertIntEquals (test, 0, status);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 8);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 9, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 10);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, HASH_ENGINE_START_SHA256_FAILED);

	status |= mock_expect (&logger.mock, logger.base.create_entry, &logger, 0,
		MOCK_ARG_PTR_CONTAINS ((uint8_t*) &entry, LOG_ENTRY_SIZE_TIME_FIELD_NOT_INCLUDED),
		MOCK_ARG (sizeof (entry)));

	CuAssertIntEquals (test, 0, status);

	pcr_cfm_valid_measured_data.type = PCR_DATA_TYPE_MEMORY;
	pcr_cfm_valid_measured_data.data.memory.buffer = testing.device_mgr.attestation_status;
	pcr_cfm_valid_measured_data.data.memory.length = sizeof (attestation_status_expected);

	pcr_store_set_measurement_data (&testing.store, 0, &pcr_cfm_valid_measured_data);

	debug_log = &logger.base;

	attestation_requester_discovery_and_attestation_loop (&testing.test, &testing.store, 0, 0);

	debug_log = NULL;

	status = device_manager_get_attestation_status (&testing.device_mgr,
		(const uint8_t**) &attestation_status);
	CuAssertIntEquals (test, sizeof (attestation_status_expected), status);

	status = testing_validate_array (attestation_status_expected, attestation_status, status);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_get_measurement_data (&testing.store, 0, 0, attestation_status_expected,
		sizeof (attestation_status_expected));
	CuAssertIntEquals (test, sizeof (attestation_status_expected), status);

	status = testing_validate_array (attestation_status_expected, attestation_status, status);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);

	status = logging_mock_validate_and_release (&logger);
	CuAssertIntEquals (test, 0, status);
}

static void attestation_requester_test_discovery_and_attestation_loop_single_device (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct pcr_measured_data pcr_cfm_valid_measured_data;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t attestation_status_expected[6] = {0x32, 0x00, 0x00, 0x00, 0x01, 0x00};
	uint8_t attestation_status_expected_pcr[11] = {0};
	uint8_t pcr_event_version_info[5] = {0};
	uint8_t *attestation_status;
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t version[4] = {0};
	uint8_t event = 0;
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM,
		component_id);

	testing.spdm_discovery = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 5,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 8);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 9, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 10);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, 0);
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (version, sizeof (version)),
		MOCK_ARG (sizeof (version)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (&event, sizeof (event)),
		MOCK_ARG (sizeof (event)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (attestation_status_expected,
		sizeof (attestation_status_expected)), MOCK_ARG (sizeof (attestation_status_expected)));
	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.finish,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	pcr_cfm_valid_measured_data.type = PCR_DATA_TYPE_MEMORY;
	pcr_cfm_valid_measured_data.data.memory.buffer = testing.device_mgr.attestation_status;
	pcr_cfm_valid_measured_data.data.memory.length = sizeof (attestation_status_expected);

	pcr_store_set_measurement_data (&testing.store, 0, &pcr_cfm_valid_measured_data);

	attestation_requester_discovery_and_attestation_loop (&testing.test, &testing.store, 0, 0);

	status = device_manager_get_attestation_status (&testing.device_mgr,
		(const uint8_t**) &attestation_status);
	CuAssertIntEquals (test, sizeof (attestation_status_expected), status);

	status = testing_validate_array (attestation_status_expected, attestation_status, status);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_get_measurement_data (&testing.store, 0, 0, attestation_status_expected_pcr,
		sizeof (attestation_status_expected_pcr));
	CuAssertIntEquals (test, sizeof (attestation_status_expected_pcr), status);

	status = testing_validate_array (attestation_status_expected_pcr, pcr_event_version_info,
		sizeof (pcr_event_version_info));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (attestation_status_expected_pcr +
			sizeof (pcr_event_version_info),
		attestation_status, sizeof (attestation_status_expected));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discovery_and_attestation_loop_multiple_devices (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	struct pcr_measured_data pcr_cfm_valid_measured_data;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_component_device component_device;
	struct cfm_component_device component_device2;
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 50;
	uint32_t component_id2 = 1;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t attestation_status_expected[12] = {0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x01, 0x00};
	uint8_t attestation_status_expected_pcr[17] = {0};
	uint8_t pcr_event_version_info[5] = {0};
	uint8_t *attestation_status;
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	uint8_t version[4] = {0};
	uint8_t event = 0;
	int status;
	size_t i;
	const struct pcr_config pcr_config[1] = {
		{
			.num_measurements = 0,
			.measurement_algo = HASH_TYPE_SHA256
		}
	};

	TEST_START;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	component_device.attestation_protocol = CFM_ATTESTATION_DMTF_SPDM;
	component_device.cert_slot = ATTESTATION_RIOT_SLOT_NUM;
	component_device.component_id = component_id;
	component_device.num_pmr_ids = 1;
	component_device.pmr_id_list = pmr_id_list;
	component_device.transcript_hash_type = HASH_TYPE_SHA256;
	component_device.measurement_hash_type = HASH_TYPE_SHA256;

	component_device2.attestation_protocol = CFM_ATTESTATION_DMTF_SPDM;
	component_device2.cert_slot = ATTESTATION_RIOT_SLOT_NUM;
	component_device2.component_id = component_id2;
	component_device2.num_pmr_ids = 1;
	component_device2.pmr_id_list = pmr_id_list;
	component_device2.transcript_hash_type = HASH_TYPE_SHA256;
	component_device2.measurement_hash_type = HASH_TYPE_SHA256;

	memset (&testing, 0, sizeof (struct attestation_requester_testing));

	testing.cert_buffer_len = sizeof (struct spdm_certificate_chain);
	testing.max_protocol_version = 255;
	testing.spdm_version = 2;
	testing.spdm_min_version = 1;
	testing.spdm_max_version = 2;

	status = hash_mock_init (&testing.primary_hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_init (&testing.secondary_hash);
	CuAssertIntEquals (test, 0, status);

	status = ecc_mock_init (&testing.ecc);
	CuAssertIntEquals (test, 0, status);

	status = rsa_mock_init (&testing.rsa);
	CuAssertIntEquals (test, 0, status);

	status = x509_mock_init (&testing.x509_mock);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&testing.rng);
	CuAssertIntEquals (test, 0, status);

	status = keystore_mock_init (&testing.keystore);
	CuAssertIntEquals (test, 0, status);

	status = cmd_channel_mock_init (&testing.channel, 0);
	CuAssertIntEquals (test, 0, status);

	status = firmware_update_control_mock_init (&testing.fw_update);
	CuAssertIntEquals (test, 0, status);

	status = attestation_responder_mock_init (&testing.attestation_responder);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_init (&testing.store, pcr_config, ARRAY_SIZE (pcr_config));
	CuAssertIntEquals (test, 0, status);

	status = cmd_background_mock_init (&testing.background);
	CuAssertIntEquals (test, 0, status);

	status = cmd_authorization_mock_init (&testing.authorization);
	CuAssertIntEquals (test, 0, status);

	status = cmd_device_mock_init (&testing.device);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_mock_init (&testing.cfm_manager);
	CuAssertIntEquals (test, 0, status);

	status = cfm_mock_init (&testing.cfm);
	CuAssertIntEquals (test, 0, status);

	status = X509_TESTING_ENGINE_INIT (&testing.x509);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.keystore.mock, testing.keystore.base.load_key,
		&testing.keystore, KEYSTORE_NO_KEY, MOCK_ARG (0), MOCK_ARG_NOT_NULL, MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.keystore.mock, 1, &testing.dev_id_der,
		sizeof (testing.dev_id_der), -1);
	CuAssertIntEquals (test, 0, status);

	keys.alias_cert_length = RIOT_CORE_ALIAS_CERT_LEN;
	keys.devid_cert_length = RIOT_CORE_DEVID_CERT_LEN;
	keys.alias_key_length = RIOT_CORE_ALIAS_KEY_LEN;

	status = riot_key_manager_init_static (&testing.riot, &testing.keystore.base, &keys,
		&testing.x509_mock.base);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_init (&testing.device_mgr, 1, 2, 2,
		DEVICE_MANAGER_PA_ROT_MODE, DEVICE_MANAGER_MASTER_AND_SLAVE_BUS_ROLE, 10000, 10000, 10000,
		0, 0, 0, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 0,
		MCTP_BASE_PROTOCOL_PA_ROT_CTRL_EID, 0x41, 0);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_not_attestable_device_entry (&testing.device_mgr, 1, 0, 0x20, 1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_add_unidentified_device (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_add_unidentified_device (&testing.device_mgr, 0x0C);
	CuAssertIntEquals (test, 0, status);

	fw_ver_list[0] = "1.1.1.1";
	testing.fw_version.count = 1;
	testing.fw_version.id = fw_ver_list;

	status = cmd_interface_system_init (&testing.cmd_cerberus, &testing.fw_update.base, NULL,
		NULL, NULL, NULL, NULL, NULL, NULL, NULL, &testing.attestation_responder.base,
		&testing.device_mgr, &testing.store, &testing.primary_hash.base,
		&testing.background.base, NULL, NULL, &testing.fw_version, &testing.riot,
		&testing.authorization.base, NULL, NULL, NULL,	NULL, NULL, NULL, &testing.device.base, 1,
		2, 3, 4, NULL);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_init (&testing.cmd_mctp, &testing.device_mgr, 0x1414, 4);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_init (&testing.cmd_spdm);
	CuAssertIntEquals (test, 0, status);

	status = mctp_interface_init (&testing.mctp, &testing.cmd_cerberus.base, &testing.cmd_mctp.base,
		&testing.cmd_spdm.base, &testing.device_mgr);
	CuAssertIntEquals (test, 0, status);

	testing.max_cert_buffer_portion = SPDM_GET_CERTIFICATE_MAX_CERT_BUFFER;

	memset (testing.hash_len, SHA256_HASH_LENGTH, sizeof (testing.hash_len));
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;
	testing.cert_buffer_len += SHA256_HASH_LENGTH;

	memcpy (&cert_buffer[testing.cert_buffer_len], X509_CERTSS_ECC_CA_NOPL_DER,
		X509_CERTSS_ECC_CA_NOPL_DER_LEN);

	testing.cert_buffer_len += X509_CERTSS_ECC_CA_NOPL_DER_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len], RIOT_CORE_DEVID_SIGNED_CERT,
		RIOT_CORE_DEVID_SIGNED_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_DEVID_SIGNED_CERT_LEN;

	memcpy (&cert_buffer[testing.cert_buffer_len], RIOT_CORE_ALIAS_CERT, RIOT_CORE_ALIAS_CERT_LEN);

	testing.cert_buffer_len += RIOT_CORE_ALIAS_CERT_LEN;

	status = device_manager_update_mctp_bridge_device_entry (&testing.device_mgr, 1, 0xAA, 0xBB,
		0xCC, 0xDD,	1, component_id, 1);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_update_mctp_bridge_device_entry (&testing.device_mgr, 2, 0xAB, 0xBC,
		0xCD, 0xDE,	1, component_id2, 2);
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_init (&testing.test, &testing.state, &testing.mctp,
		&testing.channel.base,	&testing.primary_hash.base, &testing.secondary_hash.base,
		&testing.ecc.base, NULL, &testing.x509_mock.base, &testing.rng.base, &testing.riot,
		&testing.device_mgr, &testing.cfm_manager.base);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_system_add_cerberus_protocol_observer (&testing.cmd_cerberus,
		&testing.test.cerberus_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_spdm_add_spdm_protocol_observer (&testing.cmd_spdm,
		&testing.test.spdm_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cmd_interface_mctp_control_add_mctp_control_protocol_observer (&testing.cmd_mctp,
		&testing.test.mctp_rsp_observer);
	CuAssertIntEquals (test, 0, status);

	status = cfm_manager_add_observer (&testing.cfm_manager.base, &testing.test.cfm_observer);
	CuAssertIntEquals (test, 0, status);

	testing.spdm_discovery = true;
	testing.multiple_devices = true;
	testing.hashing_alg_requested = SPDM_TPM_ALG_SHA_256;
	testing.hashing_alg_supported = SPDM_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_supported = SPDM_MEAS_RSP_TPM_ALG_SHA_256;
	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256 | SPDM_TPM_ALG_SHA_384 |
		SPDM_TPM_ALG_SHA_512;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 0,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 1, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		2, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 3, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		4, 0xEF, true, &testing);

	status = device_manager_update_device_ids (&testing.device_mgr, 1, 0xAA, 0xBB, 0xCC, 0xDD);
	CuAssertIntEquals (test, 0, status);

	testing.second_device = true;

	attestation_requester_testing_send_and_receive_mctp_get_msg_type (test, true, false, 5,
		&testing);
	attestation_requester_testing_send_and_receive_spdm_get_version (test, true, false, false,
		false, 6, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_capabilities (test, true, false, false,
		7, &testing);
	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms (test, true, false,
		false, 8, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_measurements (test, true, false, false,
		9, 0xEF, true, &testing);

	testing.second_device = false;

	status = device_manager_update_device_ids (&testing.device_mgr, 2, 0xAB, 0xBC, 0xCD, 0xDE);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device, &testing.cfm, 0,
		MOCK_ARG (component_id), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 0);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	testing.meas_hashing_alg_requested = SPDM_TPM_ALG_SHA_256;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 10,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 13);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 14, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 15);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.get_active_cfm,
		&testing.cfm_manager, MOCK_RETURN_PTR (&testing.cfm.base));
	status |= mock_expect (&testing.cfm_manager.mock, testing.cfm_manager.base.free_cfm,
		&testing.cfm_manager, 0, MOCK_ARG_PTR (&testing.cfm.base));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_device, &testing.cfm, 0,
		MOCK_ARG (component_id2), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 1, &component_device2,
		sizeof (struct cfm_component_device), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 1, 2);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_device,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (2));
	CuAssertIntEquals (test, 0, status);

	testing.second_device = true;

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 16,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 19);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 20, true, false, false, false, NULL, component_id2);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 21);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 1);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id2), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 3);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (3));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.start_sha256,
		&testing.primary_hash, 0);
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (version, sizeof (version)),
		MOCK_ARG (sizeof (version)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS (&event, sizeof (event)),
		MOCK_ARG (sizeof (event)));
	status |= mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.update,
		&testing.primary_hash, 0, MOCK_ARG_PTR_CONTAINS_TMP (attestation_status_expected,
		sizeof (attestation_status_expected)), MOCK_ARG (sizeof (attestation_status_expected)));
	status = mock_expect (&testing.primary_hash.mock, testing.primary_hash.base.finish,
		&testing.primary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	pcr_cfm_valid_measured_data.type = PCR_DATA_TYPE_MEMORY;
	pcr_cfm_valid_measured_data.data.memory.buffer = testing.device_mgr.attestation_status;
	pcr_cfm_valid_measured_data.data.memory.length = sizeof (attestation_status_expected);

	pcr_store_set_measurement_data (&testing.store, 0, &pcr_cfm_valid_measured_data);

	attestation_requester_discovery_and_attestation_loop (&testing.test, &testing.store, 0, 0);

	status = device_manager_get_attestation_status (&testing.device_mgr,
		(const uint8_t**) &attestation_status);
	CuAssertIntEquals (test, sizeof (attestation_status_expected), status);

	status = testing_validate_array (attestation_status_expected, attestation_status, status);
	CuAssertIntEquals (test, 0, status);

	status = pcr_store_get_measurement_data (&testing.store, 0, 0, attestation_status_expected_pcr,
		sizeof (attestation_status_expected_pcr));
	CuAssertIntEquals (test, sizeof (attestation_status_expected_pcr), status);

	status = testing_validate_array (attestation_status_expected_pcr, pcr_event_version_info,
		sizeof (pcr_event_version_info));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (
		attestation_status_expected_pcr + sizeof (pcr_event_version_info), attestation_status,
		sizeof (attestation_status_expected));
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0C);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_discovery_and_attestation_loop_get_routing_table_before_discovery (
	CuTest *test)
{
	struct attestation_requester_testing testing;
	int status;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	attestation_requester_discovery_and_attestation_loop (&testing.test, &testing.store, 0, 0);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAA, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDE, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xDD, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xBB, status);

	status = device_manager_get_eid_of_next_device_to_discover (&testing.device_mgr);
	CuAssertIntEquals (test, 0xAB, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_mctp_bridge_was_reset (CuTest *test)
{
	struct attestation_requester_testing testing;
	uint8_t combined_spdm_prefix[SPDM_COMBINED_PREFIX_LEN] = {0};
	char spdm_prefix[] = "dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*dmtf-spdm-v1.2.*";
	char spdm_context[] = "responder-challenge_auth signing";
	struct cfm_pmr_digest pmr_digest;
	uint32_t component_id = 55;
	uint8_t digest[SHA256_HASH_LENGTH];
	uint8_t digest2[SHA256_HASH_LENGTH];
	uint8_t digest3[SHA256_HASH_LENGTH];
	uint8_t signature[ECC_KEY_LENGTH_256 * 2];
	uint8_t sig_der[ECC_DER_P256_ECDSA_MAX_LENGTH];
	int status;
	size_t i;

	pmr_digest.pmr_id = 0;
	pmr_digest.digests.hash_type = HASH_TYPE_SHA256;
	pmr_digest.digests.digest_count = 1;
	pmr_digest.digests.digests = digest3;

	for (i = 0; i < sizeof (digest); ++i) {
		digest[i] = i * 3;
		digest2[i] = i * 2;
		digest3[i] = 50 + i;
	}

	for (i = 0; i < (ECC_KEY_LENGTH_256 * 2); ++i) {
		signature[i] = i * 10;
	}

	TEST_START;

	status = ecc_der_encode_ecdsa_signature (signature,
		&signature[ECC_KEY_LENGTH_256], ECC_KEY_LENGTH_256, sig_der, sizeof (sig_der));
	CuAssertIntEquals (test, 69, status);

	strcpy ((char*) combined_spdm_prefix, spdm_prefix);
	strcpy ((char*) &combined_spdm_prefix[100 - strlen (spdm_context)], spdm_context);

	setup_attestation_requester_mock_attestation_test (test, &testing, true, true, true, true,
		HASH_TYPE_SHA256, HASH_TYPE_SHA256, CFM_ATTESTATION_DMTF_SPDM, ATTESTATION_RIOT_SLOT_NUM, component_id);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 0, 0,
		&testing);
	attestation_requester_testing_send_and_receive_mctp_get_routing_table (test, true, false, 1, 1,
		&testing);

	status = attestation_requester_get_mctp_routing_table (&testing.test);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_refresh_routing_table (&testing.test);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_testing_send_and_receive_spdm_negotiate_algorithms_with_mocks (test, 2,
		false, &testing);
	attestation_requester_testing_send_and_receive_spdm_get_digests_with_mocks (test, false, true,
		false, &testing, 5);
	attestation_requester_testing_send_and_receive_spdm_get_certificate_with_mocks_and_verify (test,
		&testing, HASH_TYPE_SHA256, 6, true, false, false, false, NULL, component_id);
	attestation_requester_testing_send_and_receive_spdm_challenge_with_mocks (test, false, false,
		&testing, 7);

	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest, sizeof (digest), -1);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.start_sha256,
		&testing.secondary_hash, 0);
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (combined_spdm_prefix,
			sizeof (combined_spdm_prefix)), MOCK_ARG (SPDM_COMBINED_PREFIX_LEN));
	status |= mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.update,
		&testing.secondary_hash, 0, MOCK_ARG_PTR_CONTAINS (digest, sizeof (digest)),
		MOCK_ARG (sizeof (digest)));
	status = mock_expect (&testing.secondary_hash.mock, testing.secondary_hash.base.finish,
		&testing.secondary_hash, 0, MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect_output_tmp (&testing.secondary_hash.mock, 0, digest2, sizeof (digest2),
		-1);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.ecc.mock, testing.ecc.base.init_public_key, &testing.ecc,
		0, MOCK_ARG_PTR_CONTAINS (RIOT_CORE_ALIAS_PUBLIC_KEY,
		RIOT_CORE_ALIAS_PUBLIC_KEY_LEN),
		MOCK_ARG (RIOT_CORE_ALIAS_PUBLIC_KEY_LEN), MOCK_ARG_NOT_NULL);
	status |= mock_expect_save_arg (&testing.ecc.mock, 2, 0);
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.verify, &testing.ecc,
		0, MOCK_ARG_SAVED_ARG (0), MOCK_ARG_PTR_CONTAINS_TMP (digest2, sizeof (digest2)),
		MOCK_ARG (sizeof (digest2)), MOCK_ARG_PTR_CONTAINS_TMP (sig_der, 69),
		MOCK_ARG (69));
	status |= mock_expect (&testing.ecc.mock, testing.ecc.base.release_key_pair, &testing.ecc, 0,
		MOCK_ARG_ANY, MOCK_ARG_SAVED_ARG (0));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&testing.cfm.mock, testing.cfm.base.get_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG (component_id), MOCK_ARG (0), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output_tmp (&testing.cfm.mock, 2, &pmr_digest,
		sizeof (struct cfm_pmr_digest), -1);
	status |= mock_expect_save_arg (&testing.cfm.mock, 2, 1);
	status |= mock_expect (&testing.cfm.mock, testing.cfm.base.free_component_pmr_digest,
		&testing.cfm, 0, MOCK_ARG_SAVED_ARG (1));
	CuAssertIntEquals (test, 0, status);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, 0, status);

	status = device_manager_get_device_state_by_eid (&testing.device_mgr, 0x0A);
	CuAssertIntEquals (test, DEVICE_MANAGER_AUTHENTICATED, status);

	status = attestation_requestor_mctp_bridge_was_reset (&testing.test);
	CuAssertIntEquals (test, 0, status);

	attestation_requester_refresh_routing_table (&testing.test);

	status = attestation_requester_attest_device (&testing.test, 0x0A);
	CuAssertIntEquals (test, ATTESTATION_REFRESH_ROUTING_TABLE, status);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requester_test_mctp_bridge_was_reset_invalid_arg (CuTest *test)
{
	int status;

	TEST_START;

	status = attestation_requestor_mctp_bridge_was_reset (NULL);
	CuAssertIntEquals (test, ATTESTATION_INVALID_ARGUMENT, status);
}

static void attestation_requester_test_refresh_routing_table_invalid_arg (CuTest *test)
{
	TEST_START;

	attestation_requester_refresh_routing_table (NULL);
}

static void attestation_requestor_test_wait_for_next_action (CuTest *test)
{
	struct attestation_requester_testing testing;

	TEST_START;

	setup_attestation_requester_mock_test (test, &testing, true, false, true);

	attestation_requester_refresh_routing_table (&testing.test);

	attestation_requestor_wait_for_next_action (&testing.test);

	attestation_requester_testing_receive_mctp_set_eid_request (test, &testing);

	attestation_requestor_wait_for_next_action (&testing.test);

	testing.test.cfm_observer.on_cfm_activation_request (&testing.test.cfm_observer);

	attestation_requestor_wait_for_next_action (&testing.test);

	complete_attestation_requester_mock_test (test, &testing, true);
}

static void attestation_requestor_test_wait_for_next_action_invalid_arg (CuTest *test)
{
	TEST_START;

	attestation_requestor_wait_for_next_action (NULL);
}


TEST_SUITE_START (attestation_requester);

TEST (attestation_requester_test_init);
TEST (attestation_requester_test_init_no_rsa);
TEST (attestation_requester_test_init_no_secondary_hash);
TEST (attestation_requester_test_init_invalid_arg);
TEST (attestation_requester_test_init_state);
TEST (attestation_requester_test_init_state_invalid_arg);
TEST (attestation_requester_test_deinit_null);
TEST (attestation_requester_test_attest_device_cerberus_ecc);
TEST (attestation_requester_test_attest_device_cerberus_ecc_vendor_root_ca);
TEST (attestation_requester_test_attest_device_cerberus_ecc_untrusted_root_ca);
TEST (attestation_requester_test_attest_device_cerberus_rsa);
TEST (attestation_requester_test_attest_device_cerberus_mbedtls_x509);
TEST (attestation_requester_test_attest_device_cerberus_already_authenticated);
TEST (attestation_requester_test_attest_device_cerberus_multiple_pmr0_digest_options);
TEST (attestation_requester_test_attest_device_cerberus_device_capabilities_unexpected_rsp);
TEST (attestation_requester_test_attest_device_cerberus_device_capabilities_no_rsp);
TEST (attestation_requester_test_attest_device_cerberus_device_capabilities_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_digest_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_digest_hash_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_digest_unexpected_rsp);
TEST (attestation_requester_test_attest_device_cerberus_get_digest_no_rsp);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_unexpected_rsp);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_unexpected_slot_num);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_init_ca_cert_store_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_no_riot_ca_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_hash_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_not_supported);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_vendor_root_ca_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_cerberus_add_intermediate_ca_fail);
TEST (attestation_requester_test_attest_device_cerberus_load_certificate_fail);
TEST (attestation_requester_test_attest_device_cerberus_authenticate_cert_chain_fail);
TEST (attestation_requester_test_attest_device_cerberus_hash_cert_chain_fail);
TEST (attestation_requester_test_attest_device_cerberus_compare_cert_chain_digest_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_public_key_type_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_public_key_fail);
TEST (attestation_requester_test_attest_device_cerberus_get_certificate_no_rsp);
TEST (attestation_requester_test_attest_device_cerberus_challenge_start_hash_fail);
TEST (attestation_requester_test_attest_device_cerberus_generate_challenge_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_hash_update_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_unexpected_slot_num);
TEST (attestation_requester_test_attest_device_cerberus_challenge_unexpected_hash_len);
TEST (attestation_requester_test_attest_device_cerberus_challenge_unexpected_min_protocol_version);
TEST (attestation_requester_test_attest_device_cerberus_challenge_unexpected_max_protocol_version);
TEST (attestation_requester_test_attest_device_cerberus_challenge_update_hash_rsp_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_hash_finish_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_ecc_init_pub_key_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_ecc_verify_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_rsa_not_supported);
TEST (attestation_requester_test_attest_device_cerberus_challenge_rsa_init_pub_key_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_rsa_verify_fail);
TEST (attestation_requester_test_attest_device_cerberus_challenge_unexpected_rsp);
TEST (attestation_requester_test_attest_device_cerberus_challenge_no_rsp);
TEST (attestation_requester_test_attest_device_cerberus_get_component_pmr_digest_fail);
TEST (attestation_requester_test_attest_device_cerberus_pmr0_digest_invalid_len);
TEST (attestation_requester_test_attest_device_cerberus_no_pmr0_digest_match);
TEST (attestation_requester_test_attest_device_spdm_different_measurement_hash_algo);
TEST (attestation_requester_test_attest_device_spdm_sha256_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha256_1_1_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha384_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha384_1_1_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha512_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha512_1_1_only_challenge);
TEST (attestation_requester_test_attest_device_spdm_sha256_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_sha256_only_pmr0_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_sha256_1_1_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_sha256_1_1_only_pmr0_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_sha384_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_sha384_1_1_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_sha512_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_sha512_1_1_only_pmr0);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_multiple_pmr0_options);
TEST (attestation_requester_test_attest_device_spdm_sha256_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha256_1_1_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha384_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha384_1_1_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha512_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha512_1_1_only_measurement);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_multiple_measurement_options);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_version_set_0_permitted);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_skip_inapplicable_version_set);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks_multiple_allowable_digests_for_different_version_sets);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_2_measurement_blocks_fail_on_second);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_equal_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_equal_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_equal_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_fail_second_data_entry);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_not_equal_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_less_than_or_equal_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_big_endian);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_greater_than_or_equal_with_bitmask_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_not_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_not_equal_fail);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_less_than);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_less_than_or_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_greater_than);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_measurement_options_greater_than_or_equal);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_2_data_checks);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_1_1);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_sha384);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_sha512);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_2_measurement_blocks);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_version_set_0_permitted);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_skip_inapplicable_version_set);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_multiple_data_entries_for_different_version_sets);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_2_measurement_blocks_fail_on_second);
TEST (attestation_requester_test_attest_device_spdm_only_measurement_data_no_checks);
TEST (attestation_requester_test_attest_device_spdm_measurement_then_measurement_data);
TEST (attestation_requester_test_attest_device_spdm_measurement_data_then_measurement);
TEST (attestation_requester_test_attest_device_spdm_sha256_no_cert_retrieval);
TEST (attestation_requester_test_attest_device_spdm_sha384_no_cert_retrieval);
TEST (attestation_requester_test_attest_device_spdm_sha512_no_cert_retrieval);
TEST (attestation_requester_test_attest_device_spdm_sha256_update_cert_chain);
TEST (attestation_requester_test_attest_device_spdm_sha384_update_cert_chain);
TEST (attestation_requester_test_attest_device_spdm_sha512_update_cert_chain);
TEST (attestation_requester_test_attest_device_spdm_vendor_root_ca);
TEST (attestation_requester_test_attest_device_spdm_riot_root_ca);
TEST (attestation_requester_test_attest_device_spdm_mbedtls_x509);
TEST (attestation_requester_test_attest_device_spdm_already_authenticated);
TEST (attestation_requester_test_attest_device_spdm_cert_retrieval_more_than_one_transaction);
TEST (attestation_requester_test_attest_device_spdm_multiple_pmr0_digest_options);
TEST (attestation_requester_test_attest_device_spdm_no_secondary_hash);
TEST (attestation_requester_test_attest_device_spdm_start_hash_sha256_fail);
TEST (attestation_requester_test_attest_device_spdm_start_hash_sha384_fail);
TEST (attestation_requester_test_attest_device_spdm_start_hash_sha512_fail);
TEST (attestation_requester_test_attest_device_spdm_get_version_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_version_fail);
TEST (attestation_requester_test_attest_device_spdm_get_version_response_not_ready);
TEST (attestation_requester_test_attest_device_spdm_get_version_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_version_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_version_unsupported_major_version);
TEST (attestation_requester_test_attest_device_spdm_get_version_unsupported_minor_version);
TEST (attestation_requester_test_attest_device_spdm_get_version_unsupported_prerelease_version);
TEST (attestation_requester_test_attest_device_spdm_get_version_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_fail);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_response_not_ready);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_not_supported);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_supported_without_sig);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_measurement_cap_supported_with_sig_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_challenge_supported_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_get_capabilities_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_fail);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_response_not_ready);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_measurement_spec);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_mismatched_base_asym_key_sig_alg);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_supported_base_asym_key_sig_alg_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_supported_hash_alg_get_cert_unsupported);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_hash_alg);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_hash_alg);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unsupported_meas_hash_alg);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_unexpected_meas_hash_alg);
TEST (attestation_requester_test_attest_device_spdm_negotiate_algorithms_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_digests_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_digests_fail);
TEST (attestation_requester_test_attest_device_spdm_get_digests_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_digests_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_digests_invalid_rsp_len);
TEST (attestation_requester_test_attest_device_spdm_get_digests_req_slot_empty);
TEST (attestation_requester_test_attest_device_spdm_get_digests_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_digests_rsp_not_ready);
TEST (attestation_requester_test_attest_device_spdm_get_digests_rsp_not_ready_too_many_retries);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_fail);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_rsp_unexpected_slot_num);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_rsp_rsp_too_large);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_non_contiguous_mask_single);
TEST (attestation_requester_test_attest_device_spdm_get_certificate_non_contiguous_mask_multiple);
TEST (attestation_requester_test_attest_device_spdm_init_ca_cert_store_fail);
TEST (attestation_requester_test_attest_device_spdm_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_spdm_no_riot_ca_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_spdm_get_vendor_root_ca_fail);
TEST (attestation_requester_test_attest_device_spdm_vendor_root_ca_hash_fail);
TEST (attestation_requester_test_attest_device_spdm_vendor_root_ca_not_supported);
TEST (attestation_requester_test_attest_device_spdm_vendor_root_ca_add_root_ca_fail);
TEST (attestation_requester_test_attest_device_spdm_add_intermediate_ca_fail);
TEST (attestation_requester_test_attest_device_spdm_load_certificate_fail);
TEST (attestation_requester_test_attest_device_spdm_authenticate_cert_chain_fail);
TEST (attestation_requester_test_attest_device_spdm_sha256_hash_cert_chain_fail);
TEST (attestation_requester_test_attest_device_spdm_sha384_hash_cert_chain_fail);
TEST (attestation_requester_test_attest_device_spdm_sha512_hash_cert_chain_fail);
TEST (attestation_requester_test_attest_device_spdm_compare_cert_chain_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_get_public_key_type_fail);
TEST (attestation_requester_test_attest_device_spdm_get_public_key_fail);
TEST (attestation_requester_test_attest_device_spdm_generate_random_buffer_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_rsp_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_challenge_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_challenge_rsp_unexpected_slot_num);
TEST (attestation_requester_test_attest_device_spdm_challenge_rsp_unsupported_mutual_auth);
TEST (attestation_requester_test_attest_device_spdm_challenge_rsp_req_slot_empty);
TEST (attestation_requester_test_attest_device_spdm_challenge_invalid_rsp_len);
TEST (attestation_requester_test_attest_device_spdm_challenge_compare_cert_chain_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_hash_finish_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha256_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha384_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_start_hash_sha512_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_update_hash_prefix_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_update_hash_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_1_2_hash_format_hash_finish_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_ecc_init_pub_key_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_ecc_verify_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_get_component_pmr_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_challenge_pmr0_digest_invalid_len);
TEST (attestation_requester_test_attest_device_spdm_challenge_no_pmr0_digest_match);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_get_pmr_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_start_hash_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_1_2_setup_device_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_generate_random_buffer_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_req_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_rsp_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_no_rsp);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_unexpected_rsp);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_rsp_unexpected_slot_num);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_rsp_hash_update_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_hash_finish_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha256_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha384_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_start_hash_sha512_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_update_hash_prefix_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_update_hash_digest_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_1_2_hash_format_hash_finish_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_ecc_init_pub_key_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_ecc_verify_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_pmr0_hash_compute_fail);
TEST (attestation_requester_test_attest_device_spdm_only_pmr0_no_pmr0_digest_match);
TEST (attestation_requester_test_attest_device_spdm_measurement_get_next_measurement_or_measurement_data_fail);
TEST (attestation_requester_test_attest_device_spdm_measurement_get_measurement_fail);
TEST (attestation_requester_test_attest_device_spdm_measurement_only_measurement_version_set_selector_invalid);
TEST (attestation_requester_test_attest_device_spdm_measurement_only_measurement_version_set_selection_fail);
TEST (attestation_requester_test_attest_device_spdm_measurement_data_get_measurement_fail);
TEST (attestation_requester_test_attest_device_spdm_measurement_data_raw_requested_but_response_digest);
TEST (attestation_requester_test_attest_device_spdm_measurement_data_num_blocks_in_rsp_not_one);
TEST (attestation_requester_test_attest_device_spdm_measurement_data_unexpected_measurement_block);
TEST (attestation_requester_test_attest_device_spdm_measurement_only_measurement_data_version_set_selector_invalid);
TEST (attestation_requester_test_attest_device_update_routing_table);
TEST (attestation_requester_test_attest_device_update_routing_table_bridge_refresh_request);
TEST (attestation_requester_test_attest_device_unknown_device);
TEST (attestation_requester_test_attest_device_unsupported_attestation_protocol);
TEST (attestation_requester_test_attest_device_spdm_response_not_ready_unexpected_requested_command);
TEST (attestation_requester_test_attest_device_cfm_contains_unsupported_hash_alg);
TEST (attestation_requester_test_attest_device_invalid_arg);
TEST (attestation_requester_test_discover_device_spdm);
TEST (attestation_requester_test_discover_device_spdm_1_1);
TEST (attestation_requester_test_discover_device_spdm_update_routing_table);
TEST (attestation_requester_test_discover_device_spdm_update_routing_table_bridge_refresh_request);
TEST (attestation_requester_test_discover_device_invalid_arg);
TEST (attestation_requester_test_discover_device_no_mctp_bridge);
TEST (attestation_requester_test_discover_device_get_msg_type_unexpected_rsp);
TEST (attestation_requester_test_discover_device_get_msg_type_no_rsp);
TEST (attestation_requester_test_discover_device_get_msg_type_rsp_fail);
TEST (attestation_requester_test_discover_device_get_msg_type_no_attestation_protocols_supported);
TEST (attestation_requester_test_discover_device_spdm_setup_device_fail);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_fail);
TEST (attestation_requester_test_discover_device_spdm_1_1_get_measurement_num_indices_fail);
TEST (attestation_requester_test_discover_device_spdm_1_1_get_measurement_fail);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_device_id_fail);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_has_no_pci_ids);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_vid_not_in_device_mgr);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_not_in_device_mgr);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_vid_not_in_device_mgr);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_id_not_in_device_mgr);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_missing);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_vid_not_in_response);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_id_not_in_response);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_vid_not_in_response);
TEST (attestation_requester_test_discover_device_spdm_get_measurement_rsp_pci_subsystem_id_not_in_response);
TEST (attestation_requester_test_get_routing_table);
TEST (attestation_requester_test_get_routing_table_table_already_up_to_date);
TEST (attestation_requester_test_get_routing_table_table_bridge_refresh_request_ignored);
TEST (attestation_requester_test_get_routing_table_invalid_arg);
TEST (attestation_requester_test_get_routing_table_no_mctp_bridge);
TEST (attestation_requester_test_get_routing_table_get_routing_table_entries_unexpected_rsp);
TEST (attestation_requester_test_get_routing_table_get_routing_table_entries_no_rsp);
TEST (attestation_requester_test_get_routing_table_get_routing_table_entries_rsp_fail);
TEST (attestation_requester_test_reset_authenticated_devices_on_cfm_activation_request);
TEST (attestation_requester_test_discovery_and_attestation_loop_single_device);
TEST (attestation_requester_test_discovery_and_attestation_loop_single_device_invalid_pcr_measurement);
TEST (attestation_requester_test_discovery_and_attestation_loop_multiple_devices);
TEST (attestation_requester_test_discovery_and_attestation_loop_get_routing_table_before_discovery);
TEST (attestation_requester_test_mctp_bridge_was_reset);
TEST (attestation_requester_test_mctp_bridge_was_reset_invalid_arg);
TEST (attestation_requester_test_refresh_routing_table_invalid_arg);
TEST (attestation_requestor_test_wait_for_next_action);
TEST (attestation_requestor_test_wait_for_next_action_invalid_arg);

TEST_SUITE_END;
