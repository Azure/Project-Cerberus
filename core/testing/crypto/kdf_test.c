// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include "platform_api.h"
#include "testing.h"
#include "crypto/kdf.h"
#include "testing/mock/crypto/hash_mock.h"
#include "testing/engines/hash_testing_engine.h"


TEST_SUITE_LABEL ("kdf");


static const uint8_t kdo_sha1[] = {
	0x06,0x3b,0x74,0x13,0x1d,0xf3,0xf9,0xb2,0xf7,0x25,0x4e,0xab,0xae,0xd3,0xc4,0x9b,
	0x20,0xf5,0x22,0x61
};

static const uint8_t kdo_sha256_32[] = {
	0xe6,0x48,0xd4,0xc7,0x0d,0xc1,0x59,0x75,0xa1,0x4b,0x0a,0x91,0x75,0xd9,0x17,0x10,
	0x21,0x75,0xbc,0x9a,0x92,0x6f,0x6d,0x24,0x93,0xda,0xf3,0x98,0x11,0xc3,0x97,0xf8
};

static const uint8_t kdo_sha256_64[] = {
	0x42,0xa1,0xd9,0x7c,0x1b,0xb4,0x83,0x78,0xc1,0xa9,0xb9,0xb0,0xc6,0x13,0xfc,0x5d,
	0xa4,0xab,0x5c,0x9e,0x69,0xe2,0xc8,0xfd,0x72,0xa3,0x32,0x8f,0xb9,0x20,0xf9,0x0a,
	0x76,0x4d,0xa3,0xb8,0x4c,0xa1,0x77,0x03,0xad,0xbc,0xa0,0x57,0x05,0xb0,0xb1,0x61,
	0x9f,0x7b,0x97,0xc7,0x33,0xd6,0xfa,0xe1,0xf1,0x8a,0xc5,0xdc,0x64,0x79,0xdc,0x5a
};

static const uint8_t kdo_sha256_96[] = {
	0x63,0x8e,0x99,0x88,0x0c,0xe0,0x2f,0x4c,0xde,0xc2,0xb5,0xac,0x39,0x81,0x17,0xc7,
	0x0c,0x97,0x9c,0x97,0xee,0x69,0xe5,0xda,0x00,0x5e,0x6c,0x2c,0x02,0x26,0x79,0x3a,
	0xc8,0x99,0x1c,0x1a,0x2f,0xa7,0x5e,0x8c,0x08,0x2f,0xf5,0x88,0x7e,0xc3,0xea,0xea,
	0x39,0x8c,0xd0,0xa0,0x83,0xcc,0xf4,0x59,0x0a,0x72,0xb3,0x34,0xf6,0x69,0x3c,0x90,
	0x6b,0x3e,0x31,0x5f,0x68,0x22,0x3b,0x9e,0x59,0x3a,0xee,0xb6,0x82,0x5f,0xb4,0x6d,
	0x2e,0x3d,0x3d,0x99,0x84,0x86,0xcc,0xee,0x93,0x35,0x97,0x4a,0x0a,0x1a,0x65,0x20
};

static const uint8_t kdo_sha256_50[] = {
	0x0d,0xec,0xbe,0xd2,0x23,0x8f,0x09,0x54,0xb9,0x2c,0xe6,0xff,0x44,0x48,0xd9,0x08,
	0xa4,0x52,0x96,0x19,0x30,0x63,0x80,0x15,0x0d,0x5a,0xfe,0x42,0xd4,0x93,0xee,0xe9,
	0x27,0x4a,0x75,0xae,0x2b,0x07,0x88,0x28,0x9a,0x91,0xb1,0xbc,0x05,0x0e,0x18,0xd4,
	0x5b,0x00
};

static const uint8_t okm_sha256_32[] = {
	0x8d,0xa4,0xe7,0x75,0xa5,0x63,0xc1,0x8f,0x71,0x5f,0x80,0x2a,0x06,0x3c,0x5a,0x31,
	0xb8,0xa1,0x1f,0x5c,0x5e,0xe1,0x87,0x9e,0xc3,0x45,0x4e,0x5f,0x3c,0x73,0x8d,0x2d,
};

static const uint8_t okm_sha256_82[] = {
	0xbc,0xc6,0x71,0x47,0xe9,0x1c,0x9a,0x6e,0xe4,0x1f,0x85,0xd2,0x72,0x4c,0x90,0x94,
	0x76,0x6d,0xa1,0x28,0x0b,0xfe,0x71,0x1a,0x0a,0x64,0x68,0xc3,0x62,0x83,0xb6,0xcb,
	0x3a,0x13,0x3f,0x7e,0xc5,0xdc,0xd3,0x3b,0x3d,0x6c,0x43,0x42,0xba,0xdd,0x36,0x46,
	0x1d,0x3a,0x1a,0xdb,0x92,0x38,0x28,0x57,0xd9,0x09,0x89,0x67,0x8c,0x46,0x8b,0x3f,
	0x16,0xca,0xbe,0x2d,0xe8,0xbf,0xb7,0x33,0xa5,0xc9,0x95,0xb0,0x5b,0xbc,0x40,0x56,
	0x81,0xa5,
};

static const uint8_t okm_sha256_30[] = {
	0xbc,0xc6,0x71,0x47,0xe9,0x1c,0x9a,0x6e,0xe4,0x1f,0x85,0xd2,0x72,0x4c,0x90,0x94,
	0x76,0x6d,0xa1,0x28,0x0b,0xfe,0x71,0x1a,0x0a,0x64,0x68,0xc3,0x62,0x83,
};

static const uint8_t okm_with_info_sha256_32[] = {
	0x3c,0xb2,0x5f,0x25,0xfa,0xac,0xd5,0x7a,0x90,0x43,0x4f,0x64,0xd0,0x36,0x2f,0x2a,
	0x2d,0x2d,0x0a,0x90,0xcf,0x1a,0x5a,0x4c,0x5d,0xb0,0x2d,0x56,0xec,0xc4,0xc5,0xbf,
};

static const uint8_t okm_with_info_sha256_82[] = {
	0xdb,0xe9,0x79,0x18,0x44,0xda,0x73,0xe6,0x62,0x31,0x49,0x6f,0xbb,0x2e,0x71,0xf5,
	0x53,0x01,0x7d,0x0d,0xdc,0x0a,0xda,0xde,0xf8,0x0e,0x97,0x1b,0xaf,0x44,0xd6,0xb0,
	0xec,0x4f,0x26,0xd7,0x90,0xee,0xc9,0x1b,0xbe,0xef,0x53,0x45,0xa7,0xce,0x45,0x75,
	0x6e,0xa9,0xc8,0xa9,0x4d,0xb2,0xe8,0xf5,0x43,0x25,0x6c,0x52,0x87,0x74,0x24,0x79,
	0x50,0xba,0xba,0xed,0x45,0xc5,0x64,0x26,0xc1,0xea,0x30,0xfa,0x72,0x78,0x35,0xb5,
	0xef,0x03
};

static const uint8_t okm_with_info_sha256_30[] = {
	0xdb,0xe9,0x79,0x18,0x44,0xda,0x73,0xe6,0x62,0x31,0x49,0x6f,0xbb,0x2e,0x71,0xf5,
	0x53,0x01,0x7d,0x0d,0xdc,0x0a,0xda,0xde,0xf8,0x0e,0x97,0x1b,0xaf,0x44,
};

static const uint8_t okm_sha384_48[] = {
	0xf2,0x28,0xb8,0x14,0x80,0xa2,0xd1,0xfd,0x24,0xfd,0x6f,0x0b,0x87,0xbb,0x3b,0x39,
	0xa9,0x24,0x19,0xd8,0x88,0x78,0x86,0x60,0x08,0x9a,0xa2,0xce,0x28,0xd3,0xb7,0xef,
	0x04,0xbc,0x67,0x4a,0x49,0x7b,0x92,0xe9,0x7c,0x9b,0x0a,0xec,0xf8,0x32,0x1f,0x24,
};

static const uint8_t okm_sha384_82[] = {
	0xf2,0x28,0xb8,0x14,0x80,0xa2,0xd1,0xfd,0x24,0xfd,0x6f,0x0b,0x87,0xbb,0x3b,0x39,
	0xa9,0x24,0x19,0xd8,0x88,0x78,0x86,0x60,0x08,0x9a,0xa2,0xce,0x28,0xd3,0xb7,0xef,
	0x04,0xbc,0x67,0x4a,0x49,0x7b,0x92,0xe9,0x7c,0x9b,0x0a,0xec,0xf8,0x32,0x1f,0x24,
	0x98,0x89,0xc9,0x39,0x67,0xd9,0x08,0xda,0x42,0x0d,0xd3,0x21,0x86,0x83,0xa0,0x04,
	0xed,0xa2,0xbb,0x6a,0xcf,0x48,0xf4,0xdb,0x14,0xfb,0x15,0xc9,0xd0,0x56,0x2f,0x77,
	0x96,0x9e,
};

static const uint8_t okm_sha384_42[] = {
	0xf2,0x28,0xb8,0x14,0x80,0xa2,0xd1,0xfd,0x24,0xfd,0x6f,0x0b,0x87,0xbb,0x3b,0x39,
	0xa9,0x24,0x19,0xd8,0x88,0x78,0x86,0x60,0x08,0x9a,0xa2,0xce,0x28,0xd3,0xb7,0xef,
	0x04,0xbc,0x67,0x4a,0x49,0x7b,0x92,0xe9,0x7c,0x9b,
};

static const uint8_t okm_with_info_sha384_48[] = {
	0xd5,0x2a,0x9c,0x23,0xd8,0x53,0x27,0x76,0x6b,0x5a,0x22,0x1e,0x15,0x88,0x1d,0x71,
	0xf9,0x06,0x56,0x54,0x6a,0x07,0x38,0x8f,0x6d,0x6d,0x4b,0xba,0x96,0x29,0xd3,0x7e,
	0x5d,0x0d,0x64,0xe6,0xb5,0x27,0x8e,0xdf,0x89,0x3a,0xe4,0x3a,0x63,0x60,0x63,0x23,
};

static const uint8_t okm_with_info_sha384_82[] = {
	0xd5,0x2a,0x9c,0x23,0xd8,0x53,0x27,0x76,0x6b,0x5a,0x22,0x1e,0x15,0x88,0x1d,0x71,
	0xf9,0x06,0x56,0x54,0x6a,0x07,0x38,0x8f,0x6d,0x6d,0x4b,0xba,0x96,0x29,0xd3,0x7e,
	0x5d,0x0d,0x64,0xe6,0xb5,0x27,0x8e,0xdf,0x89,0x3a,0xe4,0x3a,0x63,0x60,0x63,0x23,
	0x6b,0x7d,0x90,0x5d,0x1b,0xfc,0x1a,0x4d,0x97,0x7b,0x7e,0x45,0xce,0x98,0xe6,0x4e,
	0xfe,0x6d,0xa8,0x8f,0x62,0xe8,0xfb,0x4a,0x8a,0xd2,0x19,0x10,0xba,0x57,0xfe,0x63,
	0x26,0x1d,
};

static const uint8_t okm_with_info_sha384_42[] = {
	0xd5,0x2a,0x9c,0x23,0xd8,0x53,0x27,0x76,0x6b,0x5a,0x22,0x1e,0x15,0x88,0x1d,0x71,
	0xf9,0x06,0x56,0x54,0x6a,0x07,0x38,0x8f,0x6d,0x6d,0x4b,0xba,0x96,0x29,0xd3,0x7e,
	0x5d,0x0d,0x64,0xe6,0xb5,0x27,0x8e,0xdf,0x89,0x3a,
};

/**
 * Set up expectations for running a NIST800-108 counter mode KDF with a mock hash engine.
 *
 * @param hash The hash mock being used.
 * @param hash_algo The hash algorithm to use for the KDF.
 * @param ki The input HMAC key for the KDF.
 * @param ki_length Length of the input key.
 * @param round The KDF round being executed.
 * @param label The KDF Label value.
 * @param label_length Length of the KDF Label.
 * @param context The KDF Context value.  Null if no Context is expected.
 * @param context_length Length of the KDF Context.
 * @param bytes_out The number of bytes being requested for the KDF.
 * @param result Output to provide from at the end of the KDF round.
 * @param result_length Length of the KDF output.
 *
 * @return 0 if the expectations were set up successfully or non-zero on error.
 */
int kdf_testing_expect_nist800_108_counter_mode (struct hash_engine_mock *hash,
	enum hash_type hash_algo, const uint8_t *ki, size_t ki_length, uint32_t round,
	const uint8_t *label, size_t label_length, const uint8_t *context, size_t context_length,
	uint32_t bytes_out, const uint8_t *result, size_t result_length)
{
	uint8_t separator = 0;
	int status;

	round = platform_htonl (round);
	bytes_out = platform_htonl (bytes_out * 8);

	status = hash_mock_expect_hmac_init (hash, ki, ki_length, hash_algo);

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&round, sizeof (round)), MOCK_ARG (sizeof (round)));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (label, label_length), MOCK_ARG (label_length));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&separator, sizeof (separator)), MOCK_ARG (sizeof (separator)));

	if (context != NULL) {
		status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
			MOCK_ARG_PTR_CONTAINS_TMP (context, context_length), MOCK_ARG (context_length));
	}

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&bytes_out, sizeof (bytes_out)), MOCK_ARG (sizeof (bytes_out)));

	status |= hash_mock_expect_hmac_finish (hash, ki, ki_length, NULL, result_length, hash_algo,
		result, result_length);

	return status;
}


/*******************
 * Test cases
 *******************/

static void kdf_test_nist800_108_counter_mode_sha1 (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA1_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA1, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (kdo_sha1, ko, sizeof (kdo_sha1));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_nist800_108_counter_mode_sha256 (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (kdo_sha256_32, ko, sizeof (kdo_sha256_32));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_nist800_108_counter_mode_key_larger_than_hash (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH * 2];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (kdo_sha256_64, ko, sizeof (kdo_sha256_64));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_nist800_108_counter_mode_key_larger_than_hash_2 (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH * 3];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (kdo_sha256_96, ko, sizeof (kdo_sha256_96));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_nist800_108_counter_mode_key_larger_than_hash_not_exact_multiple (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[50];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (kdo_sha256_50, ko, sizeof (kdo_sha256_50));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_nist800_108_counter_mode_init_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&hash.mock, hash.base.start_sha256, &hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);

}

static void kdf_test_nist800_108_counter_mode_update_index_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_update_label_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&label, sizeof (label)), MOCK_ARG (sizeof (label)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_update_separator_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint8_t separator = 0;
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&label, sizeof (label)), MOCK_ARG (sizeof (label)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&separator, sizeof (separator)), MOCK_ARG (sizeof (separator)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_update_context_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint8_t separator = 0;
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&label, sizeof (label)), MOCK_ARG (sizeof (label)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&separator, sizeof (separator)), MOCK_ARG (sizeof (separator)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&context, sizeof (context)), MOCK_ARG (sizeof (context)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_update_ko_len_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint8_t separator = 0;
	uint32_t L = platform_htonl (SHA256_HASH_LENGTH * 8);
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&label, sizeof (label)), MOCK_ARG (sizeof (label)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&separator, sizeof (separator)), MOCK_ARG (sizeof (separator)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&context, sizeof (context)), MOCK_ARG (sizeof (context)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&L, sizeof (L)), MOCK_ARG (sizeof (L)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_finish_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	uint8_t separator = 0;
	uint32_t L = platform_htonl (SHA256_HASH_LENGTH * 8);
	uint32_t i_1 = platform_htonl (1);
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ki, sizeof (ki), HASH_TYPE_SHA256);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&i_1, sizeof (i_1)), MOCK_ARG (sizeof (i_1)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&label, sizeof (label)), MOCK_ARG (sizeof (label)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&separator, sizeof (separator)), MOCK_ARG (sizeof (separator)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&context, sizeof (context)), MOCK_ARG (sizeof (context)));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&L, sizeof (L)), MOCK_ARG (sizeof (L)));
	status |= mock_expect (&hash.mock, hash.base.finish, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_NOT_NULL, MOCK_ARG (SHA512_HASH_LENGTH));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_nist800_108_counter_mode_invalid_arg (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t ki[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6
	};
	uint8_t label[] = {
		0x0e,0x9a,0x37,0xff,0x3e,0xa0,0x02,0x75,0x73,0xc5,0x54,0x10,0xad,0xd5,0xc5,0xc6,
		0xf1,0x3b,0x43,0x16,0x2c,0xe4,0x05,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04
	};
	uint8_t context[] = {
		0xf1,0x3b,0x43,0x16,0x2c,0x0e,0x9a,0x37,0xe4,0x05,0x75,0x73,0xc5,0x54,0x10,0xad,
		0xff,0x3e,0xa0,0x02,0x34,0xd6,0x41,0x80,0xfa,0x1a,0x0e,0x0a,0x04,0xd5,0xc5,0xc6
	};
	uint8_t ko[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_nist800_108_counter_mode (NULL, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, NULL, sizeof (ki), label,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), NULL,
		sizeof (label), context, sizeof (context), ko, sizeof (ko));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = kdf_nist800_108_counter_mode (&hash.base, HMAC_SHA256, ki, sizeof (ki), label,
		sizeof (label), context, sizeof (context), NULL, sizeof (ko));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_sha256 (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x19,0xef,0x24,0xa3,0x2c,0x71,0x7b,0x16,0x7f,0x33,0xa9,0x1d,0x6f,0x64,0x8b,0xdf,
		0x96,0x59,0x67,0x76,0xaf,0xdb,0x63,0x77,0xac,0x43,0x4c,0x1c,0x29,0x3c,0xcb,0x04
	};
	uint8_t okm[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha256_32, okm, sizeof (okm_sha256_32));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha256_longer_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x06,0xa6,0xb8,0x8c,0x58,0x53,0x36,0x1a,0x06,0x10,0x4c,0x9c,0xeb,0x35,0xb4,0x5c,
		0xef,0x76,0x00,0x14,0x90,0x46,0x71,0x01,0x4a,0x19,0x3f,0x40,0xc1,0x5f,0xc2,0x44
	};
	uint8_t okm[sizeof (okm_sha256_82)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha256_82, okm, sizeof (okm_sha256_82));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha256_shorter_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x06,0xa6,0xb8,0x8c,0x58,0x53,0x36,0x1a,0x06,0x10,0x4c,0x9c,0xeb,0x35,0xb4,0x5c,
		0xef,0x76,0x00,0x14,0x90,0x46,0x71,0x01,0x4a,0x19,0x3f,0x40,0xc1,0x5f,0xc2,0x44
	};
	uint8_t okm[sizeof (okm_sha256_30)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha256_30, okm, sizeof (okm_sha256_30));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha256_with_info (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x07,0x77,0x09,0x36,0x2c,0x2e,0x32,0xdf,0x0d,0xdc,0x3f,0x0d,0xc4,0x7b,0xba,0x63,
		0x90,0xb6,0xc7,0x3b,0xb5,0x0f,0x9c,0x31,0x22,0xec,0x84,0x4a,0xd7,0xc2,0xb3,0xe5
	};
	uint8_t info[] = {0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9};
	uint8_t okm[SHA256_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha256_32, okm,
		sizeof (okm_with_info_sha256_32));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha256_with_info_longer_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x07,0x77,0x09,0x36,0x2c,0x2e,0x32,0xdf,0x0d,0xdc,0x3f,0x0d,0xc4,0x7b,0xba,0x63,
		0x90,0xb6,0xc7,0x3b,0xb5,0x0f,0x9c,0x31,0x22,0xec,0x84,0x4a,0xd7,0xc2,0xb3,0xe5
	};
	uint8_t info[] = {
		0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
		0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
		0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
		0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
		0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
		};
	uint8_t okm[sizeof (okm_with_info_sha256_82)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha256_82, okm,
		sizeof (okm_with_info_sha256_82));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha256_with_info_shorter_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0x07,0x77,0x09,0x36,0x2c,0x2e,0x32,0xdf,0x0d,0xdc,0x3f,0x0d,0xc4,0x7b,0xba,0x63,
		0x90,0xb6,0xc7,0x3b,0xb5,0x0f,0x9c,0x31,0x22,0xec,0x84,0x4a,0xd7,0xc2,0xb3,0xe5
	};
	uint8_t info[] = {
		0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
		0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
		0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
		0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
		0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
		};
	uint8_t okm[sizeof (okm_with_info_sha256_30)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA256, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha256_30, okm,
		sizeof (okm_with_info_sha256_30));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384 (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha384_48, okm, sizeof (okm_sha384_48));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384_longer_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[sizeof (okm_sha384_82)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha384_82, okm, sizeof (okm_sha384_82));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384_shorter_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[sizeof (okm_sha384_42)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_sha384_42, okm, sizeof (okm_sha384_42));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384_with_info (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t info[] = {0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9};
	uint8_t okm[SHA384_HASH_LENGTH];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha384_48, okm,
		sizeof (okm_with_info_sha384_48));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384_with_info_longer_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t info[] = {0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9};
	uint8_t okm[sizeof (okm_with_info_sha384_82)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha384_82, okm,
		sizeof (okm_with_info_sha384_82));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_sha384_with_info_shorter_output (CuTest *test)
{
	HASH_TESTING_ENGINE hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t info[] = {0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9};
	uint8_t okm[sizeof (okm_with_info_sha384_42)];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, sizeof (info), okm,
		sizeof (okm));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (okm_with_info_sha384_42, okm,
		sizeof (okm_with_info_sha384_42));
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void kdf_test_hkdf_expand_init_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&hash.mock, hash.base.start_sha384, &hash, HASH_ENGINE_NO_MEMORY);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_update_t_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	uint8_t t[HASH_MAX_HASH_LEN] = {0};
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, prk, sizeof (prk), HASH_TYPE_SHA384);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (t, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_update_info_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	uint8_t t[HASH_MAX_HASH_LEN] = {0};
	int status;
	const uint8_t *info = NULL;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, prk, sizeof (prk), HASH_TYPE_SHA384);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (t, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&info, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_update_constant_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	uint8_t t[HASH_MAX_HASH_LEN] = {0};
	int status;
	const uint8_t *info = NULL;
	unsigned char c = 1;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, prk, sizeof (prk), HASH_TYPE_SHA384);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (t, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&info, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_PTR_CONTAINS (&c, sizeof (c)), MOCK_ARG (sizeof (c)));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_update_finish_hmac_fail (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	uint8_t t[HASH_MAX_HASH_LEN] = {0};
	int status;
	const uint8_t *info = NULL;
	unsigned char c = 1;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, prk, sizeof (prk), HASH_TYPE_SHA384);
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (t, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&info, 0), MOCK_ARG (0));
	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&c, sizeof (c)), MOCK_ARG (sizeof (c)));
	status |= mock_expect (&hash.mock, hash.base.finish, &hash, HASH_ENGINE_NO_MEMORY,
		MOCK_ARG_NOT_NULL, MOCK_ARG (HASH_MAX_HASH_LEN));
	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), info, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, HASH_ENGINE_NO_MEMORY, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void kdf_test_hkdf_expand_invalid_arg (CuTest *test)
{
	struct hash_engine_mock hash;
	uint8_t prk[] = {
		0xb5,0x7d,0xc5,0x23,0x54,0xaf,0xee,0x11,0xed,0xb4,0xc9,0x05,0x2a,0x52,0x83,0x44,0x34,0x8b,
		0x2c,0x6b,0x6c,0x39,0xf3,0x21,0x33,0xed,0x3b,0xb7,0x20,0x35,0xa4,0xab,0x55,0xd6,0x64,0x8c,
		0x15,0x29,0xef,0x7a,0x91,0x70,0xfe,0xc9,0xef,0x26,0xa8,0x1e,
	};
	uint8_t okm[SHA384_HASH_LENGTH];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = kdf_hkdf_expand (NULL, HMAC_SHA384, prk, sizeof (prk), NULL, 0, okm, sizeof (okm));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, NULL, sizeof (prk), NULL, 0, okm,
		sizeof (okm));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = kdf_hkdf_expand (&hash.base, HMAC_SHA384, prk, sizeof (prk), NULL, 0, NULL,
		sizeof (okm));
	CuAssertIntEquals (test, KDF_INVALID_ARGUMENT, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}


TEST_SUITE_START (kdf);

TEST (kdf_test_nist800_108_counter_mode_sha1);
TEST (kdf_test_nist800_108_counter_mode_sha256);
TEST (kdf_test_nist800_108_counter_mode_key_larger_than_hash);
TEST (kdf_test_nist800_108_counter_mode_key_larger_than_hash_2);
TEST (kdf_test_nist800_108_counter_mode_key_larger_than_hash_not_exact_multiple);
TEST (kdf_test_nist800_108_counter_mode_init_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_update_index_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_update_label_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_update_separator_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_update_context_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_update_ko_len_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_finish_hmac_fail);
TEST (kdf_test_nist800_108_counter_mode_invalid_arg);
TEST (kdf_test_hkdf_expand_sha256);
TEST (kdf_test_hkdf_expand_sha256_longer_output);
TEST (kdf_test_hkdf_expand_sha256_shorter_output);
TEST (kdf_test_hkdf_expand_sha256_with_info);
TEST (kdf_test_hkdf_expand_sha256_with_info_longer_output);
TEST (kdf_test_hkdf_expand_sha256_with_info_shorter_output);
TEST (kdf_test_hkdf_expand_sha384);
TEST (kdf_test_hkdf_expand_sha384_longer_output);
TEST (kdf_test_hkdf_expand_sha384_shorter_output);
TEST (kdf_test_hkdf_expand_sha384_with_info);
TEST (kdf_test_hkdf_expand_sha384_with_info_longer_output);
TEST (kdf_test_hkdf_expand_sha384_with_info_shorter_output);
TEST (kdf_test_hkdf_expand_init_hmac_fail);
TEST (kdf_test_hkdf_expand_update_t_hmac_fail);
TEST (kdf_test_hkdf_expand_update_info_hmac_fail);
TEST (kdf_test_hkdf_expand_update_constant_hmac_fail);
TEST (kdf_test_hkdf_expand_update_finish_hmac_fail);
TEST (kdf_test_hkdf_expand_invalid_arg);

TEST_SUITE_END;
