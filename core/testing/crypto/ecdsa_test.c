// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>
#include "platform_api.h"
#include "testing.h"
#include "crypto/ecdsa.h"
#include "crypto/signature_verification.h"
#include "testing/crypto/ecc_testing.h"
#include "testing/crypto/hash_testing.h"
#include "testing/engines/ecc_testing_engine.h"
#include "testing/engines/hash_testing_engine.h"
#include "testing/mock/crypto/ecc_hw_mock.h"
#include "testing/mock/crypto/ecc_mock.h"
#include "testing/mock/crypto/hash_mock.h"
#include "testing/mock/crypto/rng_mock.h"


TEST_SUITE_LABEL ("ecdsa");


/**
 * Initial K value for the ECDSA DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/**
 * Initial V value for the ECDSA DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V[] = {
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
};

/**
 * Intermediate K value during instantiation using SHA256_TEST_HASH and ECC_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0[] = {
	0xe7, 0xd1, 0x86, 0x4d, 0x2c, 0xb7, 0x2a, 0xf5, 0x09, 0x98, 0xbe, 0xb5, 0x40, 0xbe, 0xf6, 0x3d,
	0x14, 0x63, 0xdf, 0x18, 0xae, 0x88, 0x20, 0xf6, 0xf8, 0x1a, 0x73, 0x5d, 0xd7, 0x84, 0x53, 0x4a
};

/**
 * Intermediate derived V value during instantiation using SHA256_TEST_HASH and ECC_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0[] = {
	0xe0, 0xb6, 0x0f, 0x54, 0x48, 0x8d, 0x82, 0x43, 0xb6, 0x5d, 0xed, 0x01, 0xc1, 0xa3, 0xd4, 0x04,
	0x91, 0x0e, 0xaa, 0x8c, 0xb8, 0x03, 0xe6, 0xce, 0xe4, 0x9f, 0x72, 0x2f, 0x0f, 0x99, 0xf3, 0x4d
};

/**
 * Final K value from instantiation using SHA256_TEST_HASH and ECC_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1[] = {
	0xc5, 0x40, 0x16, 0xaa, 0xca, 0xb5, 0xd9, 0xd6, 0xad, 0x45, 0x6e, 0x2a, 0xd7, 0x3c, 0x87, 0x94,
	0x73, 0x1a, 0xed, 0x5f, 0x29, 0x23, 0xad, 0xec, 0xe7, 0x1d, 0xca, 0x65, 0x8f, 0xdc, 0xf3, 0x16
};

/**
 * Final V value from instantiation using SHA256_TEST_HASH and ECC_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1[] = {
	0xde, 0x3e, 0x61, 0xb3, 0x83, 0x80, 0x0d, 0x74, 0x17, 0x62, 0x2a, 0xf5, 0xb5, 0x9a, 0x20, 0x9b,
	0x1a, 0x97, 0x22, 0xcd, 0xac, 0x66, 0x2d, 0x16, 0x48, 0x50, 0xcf, 0x44, 0x1c, 0x3a, 0x77, 0xb3
};

/**
 * First ECDSA k value generated by the ECC-256 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0[] = {
	0x38, 0xb0, 0xb2, 0x3f, 0x23, 0xa4, 0x8f, 0x68, 0x02, 0xd1, 0xd9, 0x24, 0x76, 0x21, 0x4a, 0x7d,
	0xce, 0x5c, 0xc3, 0x07, 0xd5, 0x99, 0x9c, 0x45, 0x93, 0x68, 0xd6, 0x7b, 0x58, 0x8b, 0xbc, 0xfe
};

/**
 * Updated K value after k generation from the ECC-256 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K2[] = {
	0x4d, 0x10, 0xd8, 0xa1, 0x7d, 0xd3, 0x02, 0x06, 0x57, 0xd0, 0x88, 0xf1, 0x35, 0xa6, 0x4e, 0x9f,
	0x0e, 0xe7, 0xa5, 0x41, 0x76, 0x73, 0xc4, 0xf8, 0x8a, 0x1d, 0x51, 0x8e, 0x23, 0x4b, 0x06, 0xda
};

/**
 * Updated V value after k generation from the ECC-256 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V2[] = {
	0x58, 0xff, 0x41, 0x95, 0x84, 0x56, 0xf2, 0x8d, 0xae, 0xaa, 0xd1, 0x0a, 0x8d, 0xf0, 0x5f, 0xab,
	0x21, 0xb7, 0xa6, 0x89, 0x86, 0x15, 0xba, 0x4a, 0xb6, 0x91, 0xdb, 0x80, 0x8c, 0x2d, 0xbd, 0x06
};

/**
 * Second ECDSA k value generated by the ECC-256 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_1[] = {
	0x5b, 0xe3, 0x19, 0x3d, 0x02, 0xb3, 0xf9, 0x1b, 0x89, 0xdc, 0x54, 0x17, 0x53, 0xb9, 0xae, 0x5e,
	0x33, 0x14, 0x0b, 0xa6, 0xc6, 0x30, 0x3f, 0x51, 0x7a, 0xfc, 0x32, 0x67, 0x39, 0x65, 0x25, 0xec
};

/**
 * Intermediate K value during instantiation using SHA384_TEST_HASH and ECC384_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_K0[] = {
	0x03, 0xb7, 0xa3, 0x0f, 0xdc, 0x86, 0x89, 0xd3, 0x6d, 0xd3, 0x1d, 0xc7, 0xc0, 0xe5, 0x56, 0x47,
	0xbd, 0x01, 0x44, 0x8b, 0x41, 0xad, 0xda, 0x9d, 0x66, 0xc9, 0x93, 0xf9, 0x1e, 0x2d, 0x07, 0x6f,
	0x62, 0x7c, 0x67, 0x29, 0x75, 0x4b, 0xe0, 0xb0, 0xd8, 0x34, 0x16, 0x76, 0xe2, 0xad, 0x28, 0xc9
};

/**
 * Intermediate derived V value during instantiation using SHA384_TEST_HASH and ECC384_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_V0[] = {
	0x1c, 0x8a, 0xa6, 0xc6, 0xdb, 0x1d, 0x3f, 0x0f, 0x15, 0x5e, 0x6d, 0xdb, 0xf8, 0x3a, 0x3e, 0xe5,
	0xdd, 0x59, 0xbb, 0xb8, 0x7d, 0xfc, 0x6f, 0x57, 0x6a, 0xff, 0x42, 0x9e, 0xec, 0x3d, 0xcd, 0x9c,
	0xc4, 0x58, 0x3e, 0xb0, 0x52, 0xc3, 0xa7, 0xc1, 0x6f, 0x91, 0x34, 0x16, 0x65, 0x6f, 0x37, 0x29
};

/**
 * Final K value from instantiation using SHA384_TEST_HASH and ECC384_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_K1[] = {
	0xd4, 0x55, 0x05, 0x99, 0x37, 0x24, 0x1f, 0xa4, 0x00, 0xde, 0xc0, 0x12, 0xc0, 0x9b, 0xf3, 0xce,
	0xf5, 0x97, 0x9d, 0xcf, 0x8f, 0xf1, 0xc4, 0x71, 0x92, 0x81, 0xbf, 0xa0, 0x7b, 0x33, 0x1d, 0x0a,
	0x33, 0xf0, 0xe8, 0x50, 0xe7, 0xaa, 0x62, 0xad, 0xe6, 0x65, 0x78, 0x29, 0x97, 0xe5, 0x85, 0xb6
};

/**
 * Final V value from instantiation using SHA384_TEST_HASH and ECC384_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_V1[] = {
	0xb9, 0xc7, 0x90, 0x4c, 0x71, 0x16, 0x4c, 0x1f, 0xde, 0x1c, 0x46, 0x8a, 0xc9, 0x34, 0x43, 0x6d,
	0x6c, 0x6b, 0x3d, 0x9a, 0xb5, 0x62, 0x33, 0x6a, 0x86, 0xa9, 0xf0, 0x6e, 0xe7, 0x89, 0x1c, 0x08,
	0xaa, 0x30, 0x2a, 0x20, 0x5c, 0xbd, 0x83, 0x0f, 0x0b, 0x68, 0xb8, 0x58, 0xa2, 0xa6, 0x68, 0xc1
};

/**
 * First ECDSA k value generated by the ECC-384 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC384_K_OUT_0[] = {
	0x75, 0x57, 0x7f, 0x31, 0x07, 0x66, 0x75, 0xdf, 0x3f, 0x5c, 0xe9, 0x77, 0x90, 0x87, 0x7f, 0xec,
	0xfb, 0x8a, 0xda, 0x76, 0xfe, 0x89, 0x1c, 0xed, 0x45, 0x3d, 0x7c, 0xe6, 0x79, 0x75, 0x63, 0x9d,
	0x21, 0xe8, 0xb7, 0x50, 0xa8, 0x2b, 0xe3, 0xde, 0x87, 0x93, 0xc0, 0x9c, 0xf6, 0x31, 0x02, 0xd4
};

/**
 * Updated K value after k generation from the ECC-384 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_K2[] = {
	0xc0, 0xea, 0xe8, 0x4d, 0x79, 0xa2, 0x0e, 0x0f, 0xaa, 0xf5, 0xe5, 0x88, 0x98, 0xe2, 0x7b, 0x03,
	0x3f, 0x47, 0x87, 0x80, 0xb9, 0xb3, 0xb4, 0xba, 0xe5, 0xd2, 0x81, 0x0f, 0xe4, 0x21, 0x4b, 0x8d,
	0x90, 0xc6, 0xd8, 0xfe, 0x44, 0x61, 0xa9, 0x45, 0xb0, 0x80, 0x78, 0x1b, 0x39, 0x3a, 0xeb, 0x58
};

/**
 * Updated V value after k generation from the ECC-384 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_V2[] = {
	0x34, 0x69, 0xd7, 0xa6, 0x7f, 0x0f, 0x3e, 0x66, 0x64, 0x49, 0x2f, 0x91, 0x94, 0x43, 0x80, 0x7b,
	0x9d, 0x5f, 0x5b, 0x22, 0x2f, 0xf1, 0x34, 0x16, 0xcb, 0x8c, 0x59, 0x30, 0x70, 0xf7, 0x10, 0x3b,
	0xa6, 0x37, 0x39, 0x1d, 0x87, 0x77, 0x1b, 0x65, 0x93, 0x50, 0xfa, 0x71, 0x15, 0x2c, 0x65, 0x97
};

/**
 * Second ECDSA k value generated by the ECC-384 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC384_K_OUT_1[] = {
	0x2c, 0x6d, 0x1f, 0x83, 0x75, 0x09, 0x17, 0x54, 0xa0, 0xfb, 0x4d, 0x87, 0x28, 0xf6, 0x87, 0x49,
	0xcf, 0xa2, 0x36, 0x02, 0x4f, 0x5f, 0xca, 0x9d, 0x5a, 0x6c, 0x3f, 0x57, 0x94, 0xfe, 0xea, 0xd5,
	0xba, 0x97, 0xfc, 0xff, 0xdb, 0x81, 0x74, 0x3b, 0x9f, 0xe1, 0x8b, 0x03, 0x1a, 0x92, 0x23, 0xc7
};

/**
 * Intermediate K value during instantiation using SHA512_TEST_HASH and ECC521_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K0[] = {
	0x6d, 0x7e, 0x1f, 0xe7, 0x30, 0x2f, 0x75, 0xd3, 0xa8, 0x36, 0xf9, 0x9e, 0xc8, 0x2b, 0xaf, 0x88,
	0x14, 0x37, 0xf4, 0x68, 0x74, 0x77, 0x2b, 0x0e, 0xca, 0xc9, 0xbd, 0x99, 0x48, 0x6e, 0x0a, 0x62,
	0x70, 0x38, 0x08, 0x13, 0x15, 0x40, 0x3a, 0xef, 0xaa, 0x15, 0x24, 0xf0, 0xb1, 0x44, 0xce, 0x2a,
	0xe6, 0xa9, 0xc0, 0xf5, 0xb3, 0xfe, 0x78, 0x8d, 0x53, 0x96, 0x69, 0x8c, 0xa2, 0x5c, 0xe5, 0x70
};

/**
 * Intermediate derived V value during instantiation using SHA512_TEST_HASH and ECC521_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_V0[] = {
	0xc1, 0xab, 0x4e, 0x3e, 0xb2, 0xd3, 0x3e, 0xc6, 0xf4, 0xd3, 0x09, 0xdf, 0x30, 0x8d, 0xb9, 0xf3,
	0x50, 0xe6, 0xd0, 0x57, 0x9f, 0x8e, 0x92, 0xe8, 0xcf, 0x77, 0xbd, 0x7f, 0x09, 0x1a, 0xbd, 0x44,
	0xc7, 0x38, 0x00, 0xc6, 0x81, 0xef, 0x16, 0xb2, 0x8e, 0x6f, 0xa0, 0x31, 0xb9, 0xb5, 0x71, 0x40,
	0x1a, 0xa4, 0xd6, 0x95, 0x85, 0x44, 0xc7, 0xe0, 0x4b, 0xe3, 0xfa, 0x65, 0xa1, 0xc3, 0x1d, 0xd7
};

/**
 * Final K value from instantiation using SHA512_TEST_HASH and ECC521_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K1[] = {
	0x85, 0xd1, 0x11, 0xf5, 0x41, 0xc3, 0x6a, 0x70, 0xf6, 0x09, 0x2f, 0xd4, 0x9d, 0x6c, 0x55, 0xd1,
	0x22, 0x39, 0xf4, 0x8a, 0x14, 0xa7, 0x8d, 0xec, 0x12, 0x22, 0x46, 0xa0, 0xbd, 0x7e, 0xaa, 0xbe,
	0xc1, 0x05, 0x25, 0xe9, 0x04, 0xf5, 0x14, 0x8e, 0x26, 0x47, 0x83, 0xce, 0x0e, 0xd2, 0xb3, 0x38,
	0x91, 0x41, 0xf2, 0x49, 0x83, 0x6a, 0x0e, 0x7a, 0x93, 0xf8, 0x5d, 0x74, 0xb8, 0x9d, 0xac, 0x6d
};

/**
 * Final V value from instantiation using SHA512_TEST_HASH and ECC521_PRIVKEY.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_V1[] = {
	0x9e, 0x2e, 0x1d, 0x80, 0x32, 0xe0, 0xb3, 0xbc, 0x33, 0x81, 0x0b, 0x97, 0x6f, 0x80, 0x6d, 0xbc,
	0x33, 0x6a, 0xb9, 0x1f, 0x80, 0x35, 0x48, 0xe9, 0x9a, 0x5f, 0x3b, 0xe0, 0x6a, 0x76, 0x04, 0x17,
	0xbe, 0xc4, 0x2d, 0x67, 0x79, 0x2f, 0xdb, 0x67, 0x19, 0x64, 0x40, 0x4a, 0xd8, 0xe0, 0x8e, 0xa2,
	0x9a, 0xae, 0x87, 0x34, 0xae, 0x38, 0xc6, 0xf8, 0x75, 0x75, 0x7c, 0x72, 0xff, 0xce, 0xf4, 0x8b
};

/**
 * First ECDSA k value generated by the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC521_K_OUT_0[] = {
	0x00, 0xf3, 0x77, 0x2e, 0xdb, 0x20, 0x2a, 0xb9, 0x87, 0x2c, 0xfe, 0xdb, 0xf2, 0xf2, 0x6a, 0xf0,
	0x84, 0x1a, 0xcd, 0x01, 0x48, 0xf2, 0x95, 0xe9, 0xbf, 0xfb, 0x2d, 0x32, 0x4b, 0x2e, 0x93, 0x4a,
	0x5c, 0x88, 0x20, 0x7d, 0x34, 0x93, 0x69, 0x88, 0x74, 0x78, 0xe9, 0x04, 0x0a, 0x90, 0xd2, 0xf3,
	0xd6, 0x2e, 0x4e, 0xfc, 0xed, 0xf6, 0x01, 0x51, 0x51, 0xeb, 0x79, 0x77, 0xfc, 0x8d, 0x6b, 0x6a,
	0xc6, 0xe5
};

/**
 * Intermediate V after the first k value generation for the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K_OUT_0_V0[] = {
	0x79, 0xbb, 0x97, 0x6d, 0x90, 0x15, 0x5c, 0xc3, 0x96, 0x7f, 0x6d, 0xf9, 0x79, 0x35, 0x78, 0x42,
	0x0d, 0x66, 0x80, 0xa4, 0x79, 0x4a, 0xf4, 0xdf, 0xfd, 0x96, 0x99, 0x25, 0x97, 0x49, 0xa5, 0x2e,
	0x44, 0x10, 0x3e, 0x9a, 0x49, 0xb4, 0xc4, 0x3a, 0x3c, 0x74, 0x82, 0x05, 0x48, 0x69, 0x79, 0xeb,
	0x17, 0x27, 0x7e, 0x76, 0xfb, 0x00, 0xa8, 0xa8, 0xf5, 0xbc, 0xbb, 0xfe, 0x46, 0xb5, 0xb5, 0x63
};

/**
 * Final V after the first k value generation for the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K_OUT_0_V1[] = {
	0x72, 0xcb, 0xcb, 0x35, 0xec, 0x54, 0x90, 0xab, 0x90, 0x37, 0xdb, 0xb3, 0xd3, 0x0c, 0x3f, 0xc0,
	0x5a, 0x45, 0x48, 0xcc, 0x55, 0x02, 0x3e, 0x28, 0xc5, 0x7c, 0x3f, 0xfe, 0x92, 0x41, 0x8a, 0xec,
	0xd7, 0x9c, 0x81, 0xec, 0x0e, 0x08, 0x95, 0xd5, 0xa9, 0x04, 0xf3, 0x5a, 0x61, 0xb1, 0xf9, 0x76,
	0x3c, 0x91, 0x0b, 0x03, 0xcf, 0x50, 0x12, 0xe7, 0x57, 0x78, 0x86, 0x17, 0x00, 0x5c, 0xd5, 0x32
};

/**
 * Updated K value after k generation from the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K2[] = {
	0x2d, 0x5b, 0x7b, 0x09, 0xde, 0x03, 0x73, 0x2b, 0xd5, 0x50, 0xab, 0x0c, 0x63, 0xc6, 0x79, 0x02,
	0xa0, 0xbb, 0xbd, 0x5f, 0xdd, 0xee, 0x3c, 0xff, 0xbc, 0x30, 0x49, 0x14, 0x5d, 0x4f, 0x68, 0x78,
	0xd0, 0x24, 0x26, 0x40, 0xb7, 0x16, 0xdd, 0x64, 0x7e, 0x6d, 0xf9, 0x56, 0x40, 0x3d, 0x1c, 0xf4,
	0x81, 0x84, 0xcb, 0x93, 0x38, 0x97, 0xdd, 0x92, 0x7a, 0x2a, 0x8c, 0x9d, 0x26, 0x3a, 0x9f, 0xbe
};

/**
 * Updated V value after k generation from the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_V2[] = {
	0xc7, 0xe7, 0xaa, 0x47, 0x15, 0xb7, 0x22, 0xe0, 0xc7, 0x27, 0xee, 0x78, 0xd1, 0x4c, 0x47, 0xac,
	0xcc, 0x2f, 0x3f, 0x68, 0x86, 0xa6, 0x0f, 0xb9, 0x3f, 0x14, 0xd5, 0xd6, 0x85, 0x7c, 0x3c, 0x9e,
	0x1c, 0x10, 0x9e, 0xb6, 0x66, 0x6e, 0xa7, 0x6b, 0x98, 0x42, 0x8c, 0x40, 0xb6, 0xbd, 0x08, 0xc0,
	0xca, 0xc0, 0xf8, 0x04, 0xd0, 0x50, 0xd5, 0xf2, 0x35, 0x23, 0x27, 0xa2, 0xee, 0xc3, 0x2e, 0x3a
};

/**
 * Second ECDSA k value generated by the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC521_K_OUT_1[] = {
	0x00, 0xa1, 0x47, 0xf8, 0x67, 0x37, 0xec, 0xf0, 0x28, 0xee, 0x77, 0xc2, 0x80, 0x13, 0xa9, 0xb5,
	0xc3, 0x81, 0x8d, 0xb4, 0x0f, 0xb7, 0x94, 0x34, 0xa9, 0x5a, 0xae, 0x93, 0x4c, 0x3e, 0x20, 0x4a,
	0x39, 0x82, 0xbb, 0x83, 0x1e, 0x08, 0x31, 0x88, 0xb2, 0x2a, 0x43, 0x45, 0xd5, 0x18, 0xe7, 0xcd,
	0x19, 0x50, 0x1c, 0x0d, 0x2a, 0x84, 0xc3, 0xf9, 0x31, 0xff, 0xd7, 0x03, 0x3c, 0xac, 0xb6, 0x6e,
	0x1b, 0xf9
};

/**
 * Intermediate V after the second k value generation for the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K_OUT_1_V0[] = {
	0x50, 0xa3, 0xfc, 0x33, 0x9b, 0xf6, 0x78, 0x14, 0x77, 0x3b, 0xe1, 0x40, 0x09, 0xd4, 0xda, 0xe1,
	0xc0, 0xc6, 0xda, 0x07, 0xdb, 0xca, 0x1a, 0x54, 0xad, 0x57, 0x49, 0xa6, 0x1f, 0x10, 0x25, 0x1c,
	0xc1, 0x5d, 0xc1, 0x8f, 0x04, 0x18, 0xc4, 0x59, 0x15, 0x21, 0xa2, 0xea, 0x8c, 0x73, 0xe6, 0x8c,
	0xa8, 0x0e, 0x06, 0x95, 0x42, 0x61, 0xfc, 0x98, 0xff, 0xeb, 0x81, 0x9e, 0x56, 0x5b, 0x37, 0x0d
};

/**
 * Final V after the second k value generation for the ECC-521 DRBG.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K_OUT_1_V1[] = {
	0xfc, 0x9b, 0x37, 0x27, 0xf6, 0xec, 0x94, 0xfb, 0x26, 0xd5, 0x7b, 0x75, 0x52, 0x18, 0x72, 0x0f,
	0x9f, 0x56, 0x7a, 0xf0, 0x03, 0x6e, 0x90, 0x0e, 0x42, 0x31, 0x18, 0x0e, 0x31, 0x41, 0x46, 0x17,
	0x3a, 0xe0, 0xc1, 0x53, 0xe2, 0x5a, 0xe7, 0x2c, 0x8a, 0x34, 0xa2, 0x26, 0x6a, 0x78, 0x67, 0x57,
	0xb7, 0xe1, 0x95, 0xe8, 0x13, 0xb2, 0x8a, 0x4e, 0xb7, 0x4b, 0xa7, 0xf0, 0x75, 0xba, 0x7b, 0x20
};

/**
 * Message digest from the RFC 6979 test vectors.  SHA-256 hash of "sample".
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA256_DIGEST[] = {
	0xaf, 0x2b, 0xdb, 0xe1, 0xaa, 0x9b, 0x6e, 0xc1, 0xe2, 0xad, 0xe1, 0xd6, 0x94, 0xf4, 0x1f, 0xc7,
	0x1a, 0x83, 0x1d, 0x02, 0x68, 0xe9, 0x89, 0x15, 0x62, 0x11, 0x3d, 0x8a, 0x62, 0xad, 0xd1, 0xbf
};

/**
 * ECC P-256 private key from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC256_PRIV_KEY[] = {
	0xc9, 0xaf, 0xa9, 0xd8, 0x45, 0xba, 0x75, 0x16, 0x6b, 0x5c, 0x21, 0x57, 0x67, 0xb1, 0xd6, 0x93,
	0x4e, 0x50, 0xc3, 0xdb, 0x36, 0xe8, 0x9b, 0x12, 0x7b, 0x8a, 0x62, 0x2b, 0x12, 0x0f, 0x67, 0x21
};

/**
 * ECC P-256 k value from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC256_K_OUT[] = {
	0xa6, 0xe3, 0xc5, 0x7d, 0xd0, 0x1a, 0xbe, 0x90, 0x08, 0x65, 0x38, 0x39, 0x83, 0x55, 0xdd, 0x4c,
	0x3b, 0x17, 0xaa, 0x87, 0x33, 0x82, 0xb0, 0xf2, 0x4d, 0x61, 0x29, 0x49, 0x3d, 0x8a, 0xad, 0x60
};

/**
 * Message digest from the RFC 6979 test vectors.  SHA-384 hash of "sample".
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA384_DIGEST[] = {
	0x9a, 0x90, 0x83, 0x50, 0x5b, 0xc9, 0x22, 0x76, 0xae, 0xc4, 0xbe, 0x31, 0x26, 0x96, 0xef, 0x7b,
	0xf3, 0xbf, 0x60, 0x3f, 0x4b, 0xbd, 0x38, 0x11, 0x96, 0xa0, 0x29, 0xf3, 0x40, 0x58, 0x53, 0x12,
	0x31, 0x3b, 0xca, 0x4a, 0x9b, 0x5b, 0x89, 0x0e, 0xfe, 0xe4, 0x2c, 0x77, 0xb1, 0xee, 0x25, 0xfe
};

/**
 * ECC P-384 private key from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC384_PRIV_KEY[] = {
	0x6b, 0x9d, 0x3d, 0xad, 0x2e, 0x1b, 0x8c, 0x1c, 0x05, 0xb1, 0x98, 0x75, 0xb6, 0x65, 0x9f, 0x4d,
	0xe2, 0x3c, 0x3b, 0x66, 0x7b, 0xf2, 0x97, 0xba, 0x9a, 0xa4, 0x77, 0x40, 0x78, 0x71, 0x37, 0xd8,
	0x96, 0xd5, 0x72, 0x4e, 0x4c, 0x70, 0xa8, 0x25, 0xf8, 0x72, 0xc9, 0xea, 0x60, 0xd2, 0xed, 0xf5
};

/**
 * ECC P-384 k value from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC384_K_OUT[] = {
	0x94, 0xed, 0x91, 0x0d, 0x1a, 0x09, 0x9d, 0xad, 0x32, 0x54, 0xe9, 0x24, 0x2a, 0xe8, 0x5a, 0xbd,
	0xe4, 0xba, 0x15, 0x16, 0x8e, 0xaf, 0x0c, 0xa8, 0x7a, 0x55, 0x5f, 0xd5, 0x6d, 0x10, 0xfb, 0xca,
	0x29, 0x07, 0xe3, 0xe8, 0x3b, 0xa9, 0x53, 0x68, 0x62, 0x3b, 0x8c, 0x46, 0x86, 0x91, 0x5c, 0xf9
};

/**
 * Message digest from the RFC 6979 test vectors.  SHA-512 hash of "sample", expanded to match the
 * key length.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA512_DIGEST[] = {
	0x00, 0x00, 0x39, 0xa5, 0xe0, 0x4a, 0xaf, 0xf7, 0x45, 0x5d, 0x98, 0x50, 0xc6, 0x05, 0x36, 0x4f,
	0x51, 0x4c, 0x11, 0x32, 0x4c, 0xe6, 0x40, 0x16, 0x96, 0x0d, 0x23, 0xd5, 0xdc, 0x57, 0xd3, 0xff,
	0xd8, 0xf4, 0x9a, 0x73, 0x94, 0x68, 0xab, 0x80, 0x49, 0xbf, 0x18, 0xee, 0xf8, 0x20, 0xcd, 0xb1,
	0xad, 0x6c, 0x90, 0x15, 0xf8, 0x38, 0x55, 0x6b, 0xc7, 0xfa, 0xd4, 0x13, 0x8b, 0x23, 0xfd, 0xf9,
	0x86, 0xc7
};

/**
 * ECC P-521 private key from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC521_PRIV_KEY[] = {
	0x00, 0xfa, 0xd0, 0x6d, 0xaa, 0x62, 0xba, 0x3b, 0x25, 0xd2, 0xfb, 0x40, 0x13, 0x3d, 0xa7, 0x57,
	0x20, 0x5d, 0xe6, 0x7f, 0x5b, 0xb0, 0x01, 0x8f, 0xee, 0x8c, 0x86, 0xe1, 0xb6, 0x8c, 0x7e, 0x75,
	0xca, 0xa8, 0x96, 0xeb, 0x32, 0xf1, 0xf4, 0x7c, 0x70, 0x85, 0x58, 0x36, 0xa6, 0xd1, 0x6f, 0xcc,
	0x14, 0x66, 0xf6, 0xd8, 0xfb, 0xec, 0x67, 0xdb, 0x89, 0xec, 0x0c, 0x08, 0xb0, 0xe9, 0x96, 0xb8,
	0x35, 0x38
};

/**
 * ECC P-521 k value from the RFC 6979 test vectors.
 */
const uint8_t ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC521_K_OUT[] = {
	0x01, 0xda, 0xe2, 0xea, 0x07, 0x1f, 0x81, 0x10, 0xdc, 0x26, 0x88, 0x2d, 0x4d, 0x5e, 0xae, 0x06,
	0x21, 0xa3, 0x25, 0x6f, 0xc8, 0x84, 0x7f, 0xb9, 0x02, 0x2e, 0x2b, 0x7d, 0x28, 0xe6, 0xf1, 0x01,
	0x98, 0xb1, 0x57, 0x4f, 0xdd, 0x03, 0xa9, 0x05, 0x3c, 0x08, 0xa1, 0x85, 0x4a, 0x16, 0x8a, 0xa5,
	0xa5, 0x74, 0x70, 0xec, 0x97, 0xdd, 0x5c, 0xe0, 0x90, 0x12, 0x4e, 0xf5, 0x2a, 0x2f, 0x7e, 0xcb,
	0xff, 0xd3
};


/**
 * Test dependencies for ECDSA.
 */
struct ecdsa_testing {
	ECC_TESTING_ENGINE (ecc);			/**< ECC engine for test. */
	HASH_TESTING_ENGINE (hash);			/**< Hash engine for test. */
	struct hash_engine_mock hash_mock;	/**< Mock for the hash engine. */
	struct ecc_engine_mock ecc_mock;	/**< Mock for the ECC engine. */
	struct ecc_hw_mock ecc_hw;			/**< Mock for the ECC HW driver. */
	struct rng_engine_mock rng;			/**< Mock for the RNG. */
};


/**
 * Helper to initialize all dependencies for testing.
 *
 * @param test The test framework.
 * @param ecdsa Testing dependencies to initialize.
 */
static void ecdsa_testing_init_dependencies (CuTest *test, struct ecdsa_testing *ecdsa)
{
	int status;

	status = ECC_TESTING_ENGINE_INIT (&ecdsa->ecc);
	CuAssertIntEquals (test, 0, status);

	status = HASH_TESTING_ENGINE_INIT (&ecdsa->hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_init (&ecdsa->hash_mock);
	CuAssertIntEquals (test, 0, status);

	status = ecc_mock_init (&ecdsa->ecc_mock);
	CuAssertIntEquals (test, 0, status);

	status = ecc_hw_mock_init (&ecdsa->ecc_hw);
	CuAssertIntEquals (test, 0, status);

	status = rng_mock_init (&ecdsa->rng);
	CuAssertIntEquals (test, 0, status);
}

/**
 * Helper to release all testing dependencies.
 *
 * @param test The test framework.
 * @param ecdsa Testing dependencies to release.
 */
static void ecdsa_testing_release_dependencies (CuTest *test, struct ecdsa_testing *ecdsa)
{
	int status;

	status = hash_mock_validate_and_release (&ecdsa->hash_mock);
	status |= ecc_mock_validate_and_release (&ecdsa->ecc_mock);
	status |= ecc_hw_mock_validate_and_release (&ecdsa->ecc_hw);
	status |= rng_mock_validate_and_release (&ecdsa->rng);

	CuAssertIntEquals (test, 0, status);

	ECC_TESTING_ENGINE_RELEASE (&ecdsa->ecc);
	HASH_TESTING_ENGINE_RELEASE (&ecdsa->hash);
}

/**
 * Set up mock expectations to instantiate a deterministic k DRBG.
 *
 * K and V values must be the same length, which is determined by the hash algorithm.
 *
 * @param hash The hash mock to set expectations on.
 * @param hmac_algo The hash algorithm used for HMAC.
 * @param digest Expected message digest.
 * @param digest_length Digest length.
 * @param priv_key Expected ECC private key.
 * @param key_length Key length.
 * @param k0 Expected intermediate K value.
 * @param v0 Expected intermediate V value.
 * @param k1 Expected final K value.
 * @param v1 Expected final V value.
 *
 * @return 0 if the expectations were set up successfully or an error code.
 */
int ecdsa_testing_expect_deterministic_k_drbg_instantiate (struct hash_engine_mock *hash,
	enum hash_type hmac_algo, const uint8_t *digest, size_t digest_length, const uint8_t *priv_key,
	size_t key_length, const uint8_t *k0, const uint8_t *v0, const uint8_t *k1, const uint8_t *v1)
{
	size_t length;
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	length = hash_get_hash_length (hmac_algo);

	status = hash_mock_expect_hmac_init (hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K, length,
		hmac_algo);

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, length),
		MOCK_ARG (length));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (priv_key, key_length), MOCK_ARG (key_length));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (digest, digest_length), MOCK_ARG (digest_length));

	status |= hash_mock_expect_hmac_finish (hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		length, NULL, 0, hmac_algo, k0, length);

	status |= hash_mock_expect_hmac (hash, k0, length, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V,
		length, NULL, 0, hmac_algo, v0, length);

	status |= hash_mock_expect_hmac_init (hash, k0, length, hmac_algo);

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (v0, length), MOCK_ARG (length));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS_TMP (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (priv_key, key_length), MOCK_ARG (key_length));

	status |= mock_expect (&hash->mock, hash->base.update, hash, 0,
		MOCK_ARG_PTR_CONTAINS (digest, digest_length), MOCK_ARG (digest_length));

	status |= hash_mock_expect_hmac_finish (hash, k0, length, NULL, 0, hmac_algo, k1, length);

	status |= hash_mock_expect_hmac (hash, k1, length, v0, length, NULL, 0, hmac_algo, v1, length);

	return status;
}


/*******************
 * Test cases
 *******************/

static void ecdsa_test_deterministic_k_drbg_instantiate_ecc256_sha256 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, drbg.key,
		SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, drbg.value,
		SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_ecc384_sha384 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA384,
		SHA384_TEST_HASH, SHA384_HASH_LENGTH, ECC384_PRIVKEY, ECC_KEY_LENGTH_384);
#ifdef HASH_ENABLE_SHA384
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_K1, drbg.key,
		SHA384_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA384_V1, drbg.value,
		SHA384_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_ecc521_sha512 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA512,
		SHA512_TEST_HASH, SHA512_HASH_LENGTH, ECC521_PRIVKEY, ECC_KEY_LENGTH_521);
#ifdef HASH_ENABLE_SHA512
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_K1, drbg.key,
		SHA512_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA512_V1, drbg.value,
		SHA512_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_null (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (NULL, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, NULL, HMAC_SHA256, SHA256_TEST_HASH,
		SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256, NULL,
		SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, NULL, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_invalid_hmac_algorithm (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_INVALID,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_init_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_v_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_octet_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_priv_key_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_message_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_finish_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.finish, &hash, HASH_ENGINE_FINISH_FAILED,
		MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_v0_hmac_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_init_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_v_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet = 0;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_octet_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_priv_key_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_message_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_finish_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.finish, &hash, HASH_ENGINE_FINISH_FAILED,
		MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_instantiate_v1_hmac_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	uint8_t octet0 = 0;
	uint8_t octet1 = 1;
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet0, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_K,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_INITIAL_V, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH);

	status |= hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet1, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_KEY_LENGTH_256), MOCK_ARG (ECC_KEY_LENGTH_256));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH);

	status |= mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_ecc256_sha256 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, k,
		ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_generate_ecc256_sha256_second_k (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_1, k,
		ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_deterministic_k_drbg_generate_ecc384_sha384 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_384];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA384,
		SHA384_TEST_HASH, SHA384_HASH_LENGTH, ECC384_PRIVKEY, ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC384_K_OUT_0, k,
		ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_generate_ecc384_sha384_second_k (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_384];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA384,
		SHA384_TEST_HASH, SHA384_HASH_LENGTH, ECC384_PRIVKEY, ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC384_K_OUT_1, k,
		ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_deterministic_k_drbg_generate_ecc521_sha512 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_521];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA512,
		SHA512_TEST_HASH, SHA512_HASH_LENGTH, ECC521_PRIVKEY, ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC521_K_OUT_0, k,
		ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_generate_ecc521_sha512_second_k (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_521];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA512,
		SHA512_TEST_HASH, SHA512_HASH_LENGTH, ECC521_PRIVKEY, ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC521_K_OUT_1, k,
		ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}
#endif

static void ecdsa_test_deterministic_k_drbg_generate_null (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (NULL, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, NULL, k, sizeof (k));
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, NULL, sizeof (k));
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_generate_invalid_hmac_algorithm (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	/* Manipulate the DRBG context. */
	drbg.hmac_algo = HMAC_INVALID;

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

static void ecdsa_test_deterministic_k_drbg_generate_first_k_hmac_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_init_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_update_v_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0,
		SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_update_octet_error (
	CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t octet = 0;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0,
		SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_finish_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t octet = 0;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0,
		SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= mock_expect (&hash.mock, hash.base.finish, &hash, HASH_ENGINE_FINISH_FAILED,
		MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.cancel, &hash, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_generate_second_k_value_hmac_error (CuTest *test)
{
	struct hash_engine_mock hash;
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t octet = 0;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = hash_mock_init (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_testing_expect_deterministic_k_drbg_instantiate (&hash, HASH_TYPE_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K0, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V0,
		ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		SHA256_TEST_HASH, SHA256_HASH_LENGTH, ECC_PRIVKEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_V1, SHA256_HASH_LENGTH, NULL,
		0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = hash_mock_expect_hmac_init (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, HASH_TYPE_SHA256);

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (ECDSA_TESTING_DETERMINISTIC_K_DRBG_ECC256_K_OUT_0,
		SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH));

	status |= mock_expect (&hash.mock, hash.base.update, &hash, 0,
		MOCK_ARG_PTR_CONTAINS (&octet, 1), MOCK_ARG (1));

	status |= hash_mock_expect_hmac_finish (&hash, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K1,
		SHA256_HASH_LENGTH, NULL, 0, HASH_TYPE_SHA256, ECDSA_TESTING_DETERMINISTIC_K_DRBG_SHA256_K2,
		SHA256_HASH_LENGTH);

	status |= mock_expect (&hash.mock, hash.base.start_sha256, &hash,
		HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	status = hash_mock_validate_and_release (&hash);
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_clear (CuTest *test)
{
	struct ecdsa_deterministic_k_drbg drbg;
	struct ecdsa_deterministic_k_drbg zero = {0};
	int status;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	ecdsa_deterministic_k_drbg_clear (&drbg);

	status = testing_validate_array (&zero, &drbg, sizeof (drbg));
	CuAssertIntEquals (test, 0, status);
}

static void ecdsa_test_deterministic_k_drbg_clear_null (CuTest *test)
{
	struct ecdsa_deterministic_k_drbg drbg;

	TEST_START;

	memset (&drbg, 0x55, sizeof (drbg));

	ecdsa_deterministic_k_drbg_clear (NULL);
}

static void ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc256 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_256];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA256,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA256_DIGEST, SHA256_HASH_LENGTH,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC256_PRIV_KEY, ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC256_K_OUT, k,
		ECC_KEY_LENGTH_256);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc384 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_384];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA384,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA384_DIGEST, SHA384_HASH_LENGTH,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC384_PRIV_KEY, ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC384_K_OUT, k,
		ECC_KEY_LENGTH_384);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}
#endif

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc521 (CuTest *test)
{
	HASH_TESTING_ENGINE (hash);
	struct ecdsa_deterministic_k_drbg drbg;
	uint8_t k[ECC_KEY_LENGTH_521];
	int status;

	TEST_START;

	status = HASH_TESTING_ENGINE_INIT (&hash);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_instantiate (&drbg, &hash.base, HMAC_SHA512,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_SHA512_DIGEST, ECC_KEY_LENGTH_521,
		ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC521_PRIV_KEY, ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_deterministic_k_drbg_generate (&drbg, &hash.base, k, sizeof (k));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (ECDSA_TESTING_DETERMINISTIC_K_RFC6979_ECC521_K_OUT, k,
		ECC_KEY_LENGTH_521);
	CuAssertIntEquals (test, 0, status);

	HASH_TESTING_ENGINE_RELEASE (&hash);
}
#endif

static void ecdsa_test_verify_message_p256_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN,
		ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p256_sha256_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PRIVKEY_DER, ECC_PRIVKEY_DER_LEN,
		ECC_SIGNATURE_TEST2, ECC_SIG_TEST2_LEN);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p256_sha256_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_BAD,
		ECC_SIG_BAD_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p384_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		(uint8_t*) message, strlen (message), ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN,
		ECC384_SIGNATURE_TEST, ECC384_SIG_TEST_LEN);

#if (defined HASH_ENABLE_SHA384) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p384_sha384_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		(uint8_t*) message, strlen (message), ECC384_PRIVKEY_DER, ECC384_PRIVKEY_DER_LEN,
		ECC384_SIGNATURE_TEST2, ECC384_SIG_TEST2_LEN);

#if (defined HASH_ENABLE_SHA384) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p384_sha384_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		(uint8_t*) message, strlen (message), ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN,
		ECC384_SIGNATURE_BAD, ECC384_SIG_BAD_LEN);

#if (defined HASH_ENABLE_SHA384) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p521_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		(uint8_t*) message, strlen (message), ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN,
		ECC521_SIGNATURE_TEST, ECC521_SIG_TEST_LEN);

#if (defined HASH_ENABLE_SHA512) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p521_sha512_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		(uint8_t*) message, strlen (message), ECC521_PRIVKEY_DER, ECC521_PRIVKEY_DER_LEN,
		ECC521_SIGNATURE_TEST2, ECC521_SIG_TEST2_LEN);

#if (defined HASH_ENABLE_SHA512) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_p521_sha512_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		(uint8_t*) message, strlen (message), ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN,
		ECC521_SIGNATURE_BAD, ECC521_SIG_BAD_LEN);

#if (defined HASH_ENABLE_SHA512) && (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#elif (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_null_verificiation_init (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, (uint8_t*) message,
		strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), NULL, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST,
		ECC_SIG_TEST_LEN);
	/* Fails during verification without a key set. */
	CuAssertIntEquals (test, SIG_VERIFICATION_NO_KEY, status);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, 0, ECC_SIGNATURE_TEST,
		ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INCONSISTENT_KEY, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_null_sig_verification (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, NULL, HASH_TYPE_SHA256, (uint8_t*) message,
		strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, NULL,
		strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, NULL,
		ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN,
		ECC_SIGNATURE_TEST, 0);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_message_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_message (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		(uint8_t*) message, strlen (message), ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN,
		ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p256_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p256_sha256_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PRIVKEY_DER, ECC_PRIVKEY_DER_LEN, ECC_SIGNATURE_TEST2, ECC_SIG_TEST2_LEN);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p256_sha256_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_BAD, ECC_SIG_BAD_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_verify_hash_p384_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA384_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN, ECC384_SIGNATURE_TEST, ECC384_SIG_TEST_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA384_TEST_TEST_HASH, digest, SHA384_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p384_sha384_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PRIVKEY_DER, ECC384_PRIVKEY_DER_LEN, ECC384_SIGNATURE_TEST2, ECC384_SIG_TEST2_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p384_sha384_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN, ECC384_SIGNATURE_BAD, ECC384_SIG_BAD_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_verify_hash_p521_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA512_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN, ECC521_SIGNATURE_TEST, ECC521_SIG_TEST_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA512_TEST_TEST_HASH, digest, SHA512_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p521_sha512_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PRIVKEY_DER, ECC521_PRIVKEY_DER_LEN, ECC521_SIGNATURE_TEST2, ECC521_SIG_TEST2_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_p521_sha512_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN, ECC521_SIGNATURE_BAD, ECC521_SIG_BAD_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_verify_hash_null_verificiation_init (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, NULL,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	/* Fails during verification without a key set. */
	CuAssertIntEquals (test, SIG_VERIFICATION_NO_KEY, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		0, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INCONSISTENT_KEY, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_null_sig_verification (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, NULL, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, NULL, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, 0);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p256_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p256_sha256_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PRIVKEY_DER, ECC_PRIVKEY_DER_LEN, ECC_SIGNATURE_TEST2, ECC_SIG_TEST2_LEN);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p256_sha256_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_BAD, ECC_SIG_BAD_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_verify_hash_and_finish_p384_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN, ECC384_SIGNATURE_TEST, ECC384_SIG_TEST_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p384_sha384_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PRIVKEY_DER, ECC384_PRIVKEY_DER_LEN, ECC384_SIGNATURE_TEST2, ECC384_SIG_TEST2_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p384_sha384_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		ECC384_PUBKEY_DER, ECC384_PUBKEY_DER_LEN, ECC384_SIGNATURE_BAD, ECC384_SIG_BAD_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_384)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_verify_hash_and_finish_p521_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN, ECC521_SIGNATURE_TEST, ECC521_SIG_TEST_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p521_sha512_private_key (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test2";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PRIVKEY_DER, ECC521_PRIVKEY_DER_LEN, ECC521_SIGNATURE_TEST2, ECC521_SIG_TEST2_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_p521_sha512_bad_signature (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		ECC521_PUBKEY_DER, ECC521_PUBKEY_DER_LEN, ECC521_SIGNATURE_BAD, ECC521_SIG_BAD_LEN);
#if (ECC_MAX_KEY_LENGTH >= ECC_KEY_LENGTH_521)
	CuAssertIntEquals (test, SIG_VERIFICATION_BAD_SIGNATURE, status);
#else
	CuAssertIntEquals (test, ECC_ENGINE_UNSUPPORTED_KEY_LENGTH, status)
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_verify_hash_and_finish_null_verificiation_init (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		NULL, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	/* Fails during verification without a key set. */
	CuAssertIntEquals (test, SIG_VERIFICATION_NO_KEY, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PUBKEY_DER, 0, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INCONSISTENT_KEY, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_null_sig_verification (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, NULL, HASH_TYPE_SHA256, ECC_PUBKEY_DER,
		ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, NULL, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, 0);
	CuAssertIntEquals (test, SIG_VERIFICATION_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_verify_hash_and_finish_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_verify_hash_and_finish (&ecdsa.ecc.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		ECC_PUBKEY_DER, ECC_PUBKEY_DER_LEN, ECC_SIGNATURE_TEST, ECC_SIG_TEST_LEN);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_FULL_BLOCK_1024_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA384_FULL_BLOCK_1024_HASH, SHA384_HASH_LENGTH),
		MOCK_ARG (SHA384_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
#ifdef HASH_ENABLE_SHA384
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA512_FULL_BLOCK_1024_HASH, SHA512_HASH_LENGTH),
		MOCK_ARG (SHA512_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
#ifdef HASH_ENABLE_SHA512
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_no_rng (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_FULL_BLOCK_1024_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH), MOCK_ARG_PTR (NULL), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		NULL, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_sign_message (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, &ecdsa.rng.base,
		ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256, &ecdsa.rng.base,
		ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, NULL, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, NULL, HASH_TESTING_FULL_BLOCK_1024_LEN,
		&signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_hash_start_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_hash_update_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, 0);

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.update, &ecdsa.hash_mock,
		HASH_ENGINE_UPDATE_FAILED,
		MOCK_ARG_PTR_CONTAINS (HASH_TESTING_FULL_BLOCK_1024, HASH_TESTING_FULL_BLOCK_1024_LEN),
		MOCK_ARG (HASH_TESTING_FULL_BLOCK_1024_LEN));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_hash_finish_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, 0);

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.update, &ecdsa.hash_mock, 0,
		MOCK_ARG_PTR_CONTAINS (HASH_TESTING_FULL_BLOCK_1024, HASH_TESTING_FULL_BLOCK_1024_LEN),
		MOCK_ARG (HASH_TESTING_FULL_BLOCK_1024_LEN));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.finish, &ecdsa.hash_mock,
		HASH_ENGINE_FINISH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_message_sign_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_SIGN_FAILED, MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN),
		MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_FULL_BLOCK_1024_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, HASH_TESTING_FULL_BLOCK_1024,
		HASH_TESTING_FULL_BLOCK_1024_LEN, &signature);
	CuAssertIntEquals (test, ECC_HW_ECDSA_SIGN_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_ecc_hw_sign_hash_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};
	uint8_t digest[SHA384_HASH_LENGTH];

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA384_TEST_HASH, SHA384_HASH_LENGTH), MOCK_ARG (SHA384_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA384_TEST_TEST_HASH, digest, SHA384_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_ecc_hw_sign_hash_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};
	uint8_t digest[SHA512_HASH_LENGTH];

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA512_TEST_HASH, SHA512_HASH_LENGTH), MOCK_ARG (SHA512_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA512_TEST_TEST_HASH, digest, SHA512_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_ecc_hw_sign_hash_no_rng (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH),
		MOCK_ARG_PTR (NULL), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256, NULL,
		ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_sign_hash (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, &ecdsa.rng.base,
		ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256, &ecdsa.rng.base,
		ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, NULL, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_get_hash_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.get_hash, &ecdsa.hash_mock,
		HASH_ENGINE_GET_HASH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_GET_HASH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_sign_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_SIGN_FAILED, MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN),
		MOCK_ARG (ECC_PRIVKEY_LEN), MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECC_HW_ECDSA_SIGN_FAILED, status);

	ecdsa.hash.base.cancel (&ecdsa.hash.base);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA256, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_ecc_hw_sign_hash_and_finish_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA384_TEST_HASH, SHA384_HASH_LENGTH), MOCK_ARG (SHA384_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA384, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_ecc_hw_sign_hash_and_finish_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA512_TEST_HASH, SHA512_HASH_LENGTH), MOCK_ARG (SHA512_HASH_LENGTH),
		MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA512, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_ecc_hw_sign_hash_and_finish_no_rng (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	struct ecc_ecdsa_signature expected;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	memset (expected.r, 0x55, sizeof (expected.r));
	memset (expected.s, 0xaa, sizeof (expected.s));
	expected.length = ECC_KEY_LENGTH_256;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN), MOCK_ARG (ECC_PRIVKEY_LEN),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH), MOCK_ARG (SHA256_HASH_LENGTH),
		MOCK_ARG_PTR (NULL), MOCK_ARG_NOT_NULL);
	status |= mock_expect_output (&ecdsa.ecc_hw.mock, 5, &expected, sizeof (expected), -1);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA256, NULL, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, 0, status);
	CuAssertIntEquals (test, ECC_KEY_LENGTH_256, signature.length);

	status = testing_validate_array (expected.r, signature.r, signature.length);
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (expected.s, signature.s, signature.length);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	/* NULL ECC */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (NULL, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = mock_validate (&ecdsa.hash_mock.mock);
	CuAssertIntEquals (test, 0, status);

	/* NULL Key */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, &ecdsa.rng.base, NULL, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = mock_validate (&ecdsa.hash_mock.mock);
	CuAssertIntEquals (test, 0, status);

	/* NULL Signature */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_null_hash (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256,
		&ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_INVALID, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_hash_finish_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.finish, &ecdsa.hash_mock,
		HASH_ENGINE_FINISH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_sign_hash_and_finish_sign_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	struct ecc_ecdsa_signature signature = {0};

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_sign, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_SIGN_FAILED, MOCK_ARG_PTR_CONTAINS (ECC_PRIVKEY, ECC_PRIVKEY_LEN),
		MOCK_ARG (ECC_PRIVKEY_LEN), MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH), MOCK_ARG_PTR (&ecdsa.rng), MOCK_ARG_NOT_NULL);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_sign_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA256, &ecdsa.rng.base, ECC_PRIVKEY, ECC_PRIVKEY_LEN, &signature);
	CuAssertIntEquals (test, ECC_HW_ECDSA_SIGN_FAILED, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA384_TEST_HASH, SHA384_HASH_LENGTH),
		MOCK_ARG (SHA384_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
#ifdef HASH_ENABLE_SHA384
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA512_TEST_HASH, SHA512_HASH_LENGTH),
		MOCK_ARG (SHA512_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
#ifdef HASH_ENABLE_SHA512
	CuAssertIntEquals (test, 0, status);
#else
	CuAssertIntEquals (test, HASH_ENGINE_UNSUPPORTED_HASH, status);
#endif

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_verify_message (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		NULL, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), NULL, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_hash_start_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, HASH_ENGINE_START_SHA256_FAILED);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, (uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT,
		&ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_START_SHA256_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_hash_update_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, 0);

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.update, &ecdsa.hash_mock,
		HASH_ENGINE_UPDATE_FAILED, MOCK_ARG_PTR_CONTAINS (message, strlen (message)),
		MOCK_ARG (strlen (message)));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, (uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT,
		&ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_UPDATE_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_hash_finish_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.start_sha256,
		&ecdsa.hash_mock, 0);

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.update, &ecdsa.hash_mock, 0,
		MOCK_ARG_PTR_CONTAINS (message, strlen (message)), MOCK_ARG (strlen (message)));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.finish, &ecdsa.hash_mock,
		HASH_ENGINE_FINISH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, (uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT,
		&ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_message_verify_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_VERIFY_FAILED, MOCK_ARG_PTR (&ECC_PUBKEY_POINT),
		MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_message (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		(uint8_t*) message, strlen (message), &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECC_HW_ECDSA_VERIFY_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_ecc_hw_verify_hash_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA384_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA384_TEST_HASH, SHA384_HASH_LENGTH),
		MOCK_ARG (SHA384_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA384,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA384_TEST_TEST_HASH, digest, SHA384_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_ecc_hw_verify_hash_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA512_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA512_TEST_HASH, SHA512_HASH_LENGTH),
		MOCK_ARG (SHA512_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA512,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA512_TEST_TEST_HASH, digest, SHA512_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_ecc_hw_verify_hash_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_verify_hash (NULL, &ecdsa.hash.base, HASH_TYPE_SHA256, &ECC_PUBKEY_POINT,
		&ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256, NULL,
		&ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;
	uint8_t digest[SHA256_HASH_LENGTH];

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_INVALID,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should still be active. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.finish (&ecdsa.hash.base, digest, sizeof (digest));
	CuAssertIntEquals (test, 0, status);

	status = testing_validate_array (SHA256_TEST_TEST_HASH, digest, SHA256_HASH_LENGTH);
	CuAssertIntEquals (test, 0, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_get_hash_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.get_hash, &ecdsa.hash_mock,
		HASH_ENGINE_GET_HASH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_GET_HASH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_verify_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_VERIFY_FAILED, MOCK_ARG_PTR (&ECC_PUBKEY_POINT),
		MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash (&ecdsa.ecc_hw.base, &ecdsa.hash.base, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECC_HW_ECDSA_VERIFY_FAILED, status);

	ecdsa.hash.base.cancel (&ecdsa.hash.base);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_and_finish_sha256 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA256, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

#ifdef HASH_ENABLE_SHA384
static void ecdsa_test_ecc_hw_verify_hash_and_finish_sha384 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha384 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA384_TEST_HASH, SHA384_HASH_LENGTH),
		MOCK_ARG (SHA384_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA384, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

#ifdef HASH_ENABLE_SHA512
static void ecdsa_test_ecc_hw_verify_hash_and_finish_sha512 (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha512 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw, 0,
		MOCK_ARG_PTR (&ECC_PUBKEY_POINT), MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA512_TEST_HASH, SHA512_HASH_LENGTH),
		MOCK_ARG (SHA512_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA512, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, 0, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}
#endif

static void ecdsa_test_ecc_hw_verify_hash_and_finish_null (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	/* NULL ECC */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (NULL, &ecdsa.hash_mock.base, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = mock_validate (&ecdsa.hash_mock.mock);
	CuAssertIntEquals (test, 0, status);

	/* NULL Key */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, NULL, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	status = mock_validate (&ecdsa.hash_mock.mock);
	CuAssertIntEquals (test, 0, status);

	/* NULL Signature */
	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, &ECC_PUBKEY_POINT, NULL);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_and_finish_null_hash (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, NULL, HASH_TYPE_SHA256,
		&ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECDSA_INVALID_ARGUMENT, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_and_finish_unknown_hash_algorithm (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_INVALID, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_UNKNOWN_HASH, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_and_finish_hash_finish_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.finish, &ecdsa.hash_mock,
		HASH_ENGINE_FINISH_FAILED, MOCK_ARG_NOT_NULL, MOCK_ARG_AT_LEAST (SHA256_HASH_LENGTH));

	status |= mock_expect (&ecdsa.hash_mock.mock, ecdsa.hash_mock.base.cancel, &ecdsa.hash_mock, 0);

	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash_mock.base,
		HASH_TYPE_SHA256, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, HASH_ENGINE_FINISH_FAILED, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}

static void ecdsa_test_ecc_hw_verify_hash_and_finish_verify_error (CuTest *test)
{
	struct ecdsa_testing ecdsa;
	const char *message = "Test";
	int status;

	TEST_START;

	ecdsa_testing_init_dependencies (test, &ecdsa);

	status = ecdsa.hash.base.start_sha256 (&ecdsa.hash.base);
	CuAssertIntEquals (test, 0, status);

	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, 0, status);

	status = mock_expect (&ecdsa.ecc_hw.mock, ecdsa.ecc_hw.base.ecdsa_verify, &ecdsa.ecc_hw,
		ECC_HW_ECDSA_VERIFY_FAILED, MOCK_ARG_PTR (&ECC_PUBKEY_POINT),
		MOCK_ARG_PTR (&ECC_SIGNATURE_TEST_STRUCT),
		MOCK_ARG_PTR_CONTAINS (SHA256_TEST_HASH, SHA256_HASH_LENGTH),
		MOCK_ARG (SHA256_HASH_LENGTH));
	CuAssertIntEquals (test, 0, status);

	status = ecdsa_ecc_hw_verify_hash_and_finish (&ecdsa.ecc_hw.base, &ecdsa.hash.base,
		HASH_TYPE_SHA256, &ECC_PUBKEY_POINT, &ECC_SIGNATURE_TEST_STRUCT);
	CuAssertIntEquals (test, ECC_HW_ECDSA_VERIFY_FAILED, status);

	/* The hash context should be closed. */
	status = ecdsa.hash.base.update (&ecdsa.hash.base, (uint8_t*) message, strlen (message));
	CuAssertIntEquals (test, HASH_ENGINE_NO_ACTIVE_HASH, status);

	ecdsa_testing_release_dependencies (test, &ecdsa);
}


// *INDENT-OFF*
TEST_SUITE_START (ecdsa);

TEST (ecdsa_test_deterministic_k_drbg_instantiate_ecc256_sha256);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_ecc384_sha384);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_ecc521_sha512);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_null);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_invalid_hmac_algorithm);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_init_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_v_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_octet_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_priv_key_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_update_message_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k0_hmac_finish_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_v0_hmac_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_init_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_v_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_octet_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_priv_key_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_update_message_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_k1_hmac_finish_error);
TEST (ecdsa_test_deterministic_k_drbg_instantiate_v1_hmac_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc256_sha256);
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc256_sha256_second_k);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc384_sha384);
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc384_sha384_second_k);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc521_sha512);
TEST (ecdsa_test_deterministic_k_drbg_generate_ecc521_sha512_second_k);
#endif
TEST (ecdsa_test_deterministic_k_drbg_generate_null);
TEST (ecdsa_test_deterministic_k_drbg_generate_invalid_hmac_algorithm);
TEST (ecdsa_test_deterministic_k_drbg_generate_first_k_hmac_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_init_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_update_v_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_update_octet_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_second_k_key_hmac_finish_error);
TEST (ecdsa_test_deterministic_k_drbg_generate_second_k_value_hmac_error);
TEST (ecdsa_test_deterministic_k_drbg_clear);
TEST (ecdsa_test_deterministic_k_drbg_clear_null);
TEST (ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc256);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc384);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_deterministic_k_drbg_rfc6979_test_vector_ecc521);
#endif
TEST (ecdsa_test_verify_message_p256_sha256);
TEST (ecdsa_test_verify_message_p256_sha256_private_key);
TEST (ecdsa_test_verify_message_p256_sha256_bad_signature);
TEST (ecdsa_test_verify_message_p384_sha384);
TEST (ecdsa_test_verify_message_p384_sha384_private_key);
TEST (ecdsa_test_verify_message_p384_sha384_bad_signature);
TEST (ecdsa_test_verify_message_p521_sha512);
TEST (ecdsa_test_verify_message_p521_sha512_private_key);
TEST (ecdsa_test_verify_message_p521_sha512_bad_signature);
TEST (ecdsa_test_verify_message_null_verificiation_init);
TEST (ecdsa_test_verify_message_null_sig_verification);
TEST (ecdsa_test_verify_message_unknown_hash_algorithm);
TEST (ecdsa_test_verify_hash_p256_sha256);
TEST (ecdsa_test_verify_hash_p256_sha256_private_key);
TEST (ecdsa_test_verify_hash_p256_sha256_bad_signature);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_verify_hash_p384_sha384);
TEST (ecdsa_test_verify_hash_p384_sha384_private_key);
TEST (ecdsa_test_verify_hash_p384_sha384_bad_signature);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_verify_hash_p521_sha512);
TEST (ecdsa_test_verify_hash_p521_sha512_private_key);
TEST (ecdsa_test_verify_hash_p521_sha512_bad_signature);
#endif
TEST (ecdsa_test_verify_hash_null_verificiation_init);
TEST (ecdsa_test_verify_hash_null_sig_verification);
TEST (ecdsa_test_verify_hash_unknown_hash_algorithm);
TEST (ecdsa_test_verify_hash_and_finish_p256_sha256);
TEST (ecdsa_test_verify_hash_and_finish_p256_sha256_private_key);
TEST (ecdsa_test_verify_hash_and_finish_p256_sha256_bad_signature);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_verify_hash_and_finish_p384_sha384);
TEST (ecdsa_test_verify_hash_and_finish_p384_sha384_private_key);
TEST (ecdsa_test_verify_hash_and_finish_p384_sha384_bad_signature);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_verify_hash_and_finish_p521_sha512);
TEST (ecdsa_test_verify_hash_and_finish_p521_sha512_private_key);
TEST (ecdsa_test_verify_hash_and_finish_p521_sha512_bad_signature);
#endif
TEST (ecdsa_test_verify_hash_and_finish_null_verificiation_init);
TEST (ecdsa_test_verify_hash_and_finish_null_sig_verification);
TEST (ecdsa_test_verify_hash_and_finish_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_sign_message_sha256);
TEST (ecdsa_test_ecc_hw_sign_message_sha384);
TEST (ecdsa_test_ecc_hw_sign_message_sha512);
TEST (ecdsa_test_ecc_hw_sign_message_no_rng);
TEST (ecdsa_test_ecc_hw_sign_message_null);
TEST (ecdsa_test_ecc_hw_sign_message_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_sign_message_hash_start_error);
TEST (ecdsa_test_ecc_hw_sign_message_hash_update_error);
TEST (ecdsa_test_ecc_hw_sign_message_hash_finish_error);
TEST (ecdsa_test_ecc_hw_sign_message_sign_error);
TEST (ecdsa_test_ecc_hw_sign_hash_sha256);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_ecc_hw_sign_hash_sha384);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_ecc_hw_sign_hash_sha512);
#endif
TEST (ecdsa_test_ecc_hw_sign_hash_no_rng);
TEST (ecdsa_test_ecc_hw_sign_hash_null);
TEST (ecdsa_test_ecc_hw_sign_hash_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_sign_hash_get_hash_error);
TEST (ecdsa_test_ecc_hw_sign_hash_sign_error);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_sha256);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_sha384);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_sha512);
#endif
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_no_rng);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_null);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_null_hash);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_hash_finish_error);
TEST (ecdsa_test_ecc_hw_sign_hash_and_finish_sign_error);
TEST (ecdsa_test_ecc_hw_verify_message_sha256);
TEST (ecdsa_test_ecc_hw_verify_message_sha384);
TEST (ecdsa_test_ecc_hw_verify_message_sha512);
TEST (ecdsa_test_ecc_hw_verify_message_null);
TEST (ecdsa_test_ecc_hw_verify_message_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_verify_message_hash_start_error);
TEST (ecdsa_test_ecc_hw_verify_message_hash_update_error);
TEST (ecdsa_test_ecc_hw_verify_message_hash_finish_error);
TEST (ecdsa_test_ecc_hw_verify_message_verify_error);
TEST (ecdsa_test_ecc_hw_verify_hash_sha256);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_ecc_hw_verify_hash_sha384);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_ecc_hw_verify_hash_sha512);
#endif
TEST (ecdsa_test_ecc_hw_verify_hash_null);
TEST (ecdsa_test_ecc_hw_verify_hash_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_verify_hash_get_hash_error);
TEST (ecdsa_test_ecc_hw_verify_hash_verify_error);
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_sha256);
#ifdef HASH_ENABLE_SHA384
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_sha384);
#endif
#ifdef HASH_ENABLE_SHA512
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_sha512);
#endif
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_null);
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_null_hash);
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_unknown_hash_algorithm);
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_hash_finish_error);
TEST (ecdsa_test_ecc_hw_verify_hash_and_finish_verify_error);

TEST_SUITE_END;
// *INDENT-ON*
