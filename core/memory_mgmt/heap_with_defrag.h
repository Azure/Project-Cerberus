// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef HEAP_WITH_DEFRAG_H_
#define HEAP_WITH_DEFRAG_H_

#include <stddef.h>
#include <stdint.h>
#include "status/rot_status.h"

/* Module for a basic heap memory allocator.  Allocator supports stdlib malloc, calloc, realloc, and
 * free equivalents with the same API.  Allocation sizes are 4-byte aligned, and free operations
 * have basic defragmentation by combining freed block with contiguous preceding or succeeding
 * blocks.  This implementation is not thread-safe.  Memory is allocated from the end of the first
 * large enough free block, so allocations will start from the end of the heap */

/**
 * Heap allocation control block header
 *
 * The heap allocator will have two doubly linked lists, one for allocated blocks and another for
 * free blocks.  Each linked list node will be of heap_with_defrag_ctrl_block type.  The memory
 * block handled by the control block will be right after end of control block.
 */
struct heap_with_defrag_ctrl_block {
	uint32_t magic;								/**< Magic ID to determine valid blocks. */
	size_t size;								/**< Size of block, not including control block. */
	struct heap_with_defrag_ctrl_block *next;	/**< Pointer to next control block. */
	struct heap_with_defrag_ctrl_block *prev;	/**< Pointer to previous control block. */
};


#define HEAP_WITH_DEFRAG_CTRL_BLOCK_HEADER_LEN                  \
		(sizeof (struct heap_with_defrag_ctrl_block))

/**
 * Get address of control block header from block contents.
 *
 * @param ptr Pointer to block contents
 */
#define heap_with_defrag_get_ctrl_block_header(ptr)             \
	((struct heap_with_defrag_ctrl_block*) (((uint8_t*) ptr) - HEAP_WITH_DEFRAG_CTRL_BLOCK_HEADER_LEN))

/**
 * A container for memory allocator statistics.
 */
struct heap_with_defrag_stats {
	int num_allocated_blocks;				/**< Number of allocated blocks. */
	size_t total_allocated_size;			/**< Total usable size of allocated blocks. */
	size_t total_allocated_size_w_overhead;	/**< Total size of allocated blocks including overhead. */
	int num_free_blocks;					/**< Number of free blocks. */
	size_t total_free_size;					/**< Total usable size of free blocks. */
	size_t total_free_size_w_overhead;		/**< Total size of free blocks including overhead. */
};


int heap_with_defrag_init (const void *heap_addr, size_t heap_len);

void* heap_with_defrag_allocate (size_t size);
void* heap_with_defrag_allocate_zeroize (size_t num_items, size_t size);
void* heap_with_defrag_reallocate (void *addr, size_t size);
void heap_with_defrag_free (void *addr);

int heap_with_defrag_get_stats (struct heap_with_defrag_stats *stats);


#define	HEAP_WITH_DEFRAG_ERROR(\
	code)									 ROT_ERROR (ROT_MODULE_HEAP_WITH_DEFRAG, code)

/**
 * Error codes that can be generated by heap management.
 */
enum {
	HEAP_WITH_DEFRAG_INVALID_ARGUMENT = HEAP_WITH_DEFRAG_ERROR (0x00),	/**< Input parameter is null or not valid. */
	HEAP_WITH_DEFRAG_NO_MEMORY = HEAP_WITH_DEFRAG_ERROR (0x01),			/**< Memory allocation failed. */
};


#endif	/* HEAP_WITH_DEFRAG_H_ */
