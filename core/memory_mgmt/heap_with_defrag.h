// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef HEAP_WITH_DEFRAG_H_
#define HEAP_WITH_DEFRAG_H_

#include <stdint.h>
#include <stddef.h>
#include "status/rot_status.h"

/* Module for a basic heap memory allocator.  Allocator supports stdlib malloc, calloc, realloc, and
 * free equivalents with the same API.  Allocation sizes are 4-byte aligned, and free operations
 * have basic defragmentation by combining freed block with contiguous preceding or succeeding
 * blocks.  This implementation is not thread-safe.  Memory is allocated from the end of the first
 * large enough free block, so allocations will start from the end of the heap */

/**
 * Heap allocation control block header
 *
 * The heap allocator will have two doubly linked lists, one for allocated blocks and another for
 * free blocks.  Each linked list node will be of heap_with_defrag_ctrl_block type.  The memory
 * block handled by the control block will be right after end of control block.
 */
struct heap_with_defrag_ctrl_block {
	uint32_t magic;												/**< Magic ID to determine valid blocks. */
	size_t size;												/**< Size of block, not including control block. */
	struct heap_with_defrag_ctrl_block *next;					/**< Pointer to next control block. */
	struct heap_with_defrag_ctrl_block *prev;					/**< Pointer to previous control block. */
};

#define HEAP_WITH_DEFRAG_CTRL_BLOCK_HEADER_LEN					(sizeof (struct heap_with_defrag_ctrl_block))

/**
 * Get address of control block header from block contents.
 *
 * @param ptr Pointer to block contents
 */
#define heap_with_defrag_get_ctrl_block_header(ptr)				\
	((struct heap_with_defrag_ctrl_block*) (((uint8_t*) ptr) - HEAP_WITH_DEFRAG_CTRL_BLOCK_HEADER_LEN))

/**
 * A container for memory allocator statistics.
 */
struct heap_with_defrag_stats {
	int num_allocated_blocks;									/**< Number of allocated blocks. */
	size_t total_allocated_size;								/**< Total usable size of allocated blocks. */
	size_t total_allocated_size_w_overhead;						/**< Total size of allocated blocks including overhead. */
	int num_free_blocks;										/**< Number of free blocks. */
	size_t total_free_size;										/**< Total usable size of free blocks. */
	size_t total_free_size_w_overhead;							/**< Total size of free blocks including overhead. */
};


int heap_with_defrag_init (const void *heap_addr, size_t heap_len);

void* heap_with_defrag_allocate (size_t size);
void* heap_with_defrag_allocate_zeroize (size_t num_items, size_t size);
void* heap_with_defrag_reallocate (void *addr, size_t size);
void heap_with_defrag_free (void *addr);

int heap_with_defrag_get_stats (struct heap_with_defrag_stats *stats);


#define	HEAP_WITH_DEFRAG_ERROR(code)									ROT_ERROR (ROT_MODULE_HEAP_WITH_DEFRAG, code)

/**
 * Error codes that can be generated by heap management.
 */
enum {
	HEAP_WITH_DEFRAG_INVALID_ARGUMENT = HEAP_WITH_DEFRAG_ERROR (0x00),	/**< Input parameter is null or not valid. */
	HEAP_WITH_DEFRAG_NO_MEMORY = HEAP_WITH_DEFRAG_ERROR (0x01),			/**< Memory allocation failed. */
};


#endif /* HEAP_WITH_DEFRAG_H_ */
