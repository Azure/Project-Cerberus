// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef RIOT_CORE_H_
#define RIOT_CORE_H_

#include <stddef.h>
#include <stdint.h>
#include "status/rot_status.h"


extern const uint8_t RIOT_CORE_SERIAL_NUM_KDF_DATA[];
extern const size_t RIOT_CORE_SERIAL_NUM_KDF_DATA_LENGTH;


void riot_core_clear (void *data, size_t length);


/**
 * The interface to execute DICE layer 0 functionality.
 */
struct riot_core {
	/**
	 * Generate the Device ID key from the CDI.
	 *
	 * Once this operation has completed, the CDI is no longer necessary and doesn't need to be
	 * maintained by the calling application.  However, in order to accommodate any situation with
	 * respect to storage of the CDI, the value of the CDI is not cleared by the DICE handler.  THE
	 * CALLING APPLICATION MUST BE SURE THE CDI VALUE IS WIPED OUT PRIOR TO STARTING THE NEXT
	 * APPLICATION STAGE.
	 *
	 * @param riot The DICE layer 0 handler.
	 * @param cdi The CDI for the device.  No validation will be done against this pointer, since
	 * where the CDI is stored is platform defined.  The platform may choose to put the CDI in
	 * memory locations that are typically invalid, such as address 0.
	 * @param length The length of the CDI.
	 *
	 * @return 0 if the Device ID was successfully generated or an error code.
	 */
	int (*generate_device_id) (const struct riot_core *riot, const uint8_t *cdi, size_t length);

	/**
	 * Get the Certificate Signing Request for the Device ID.
	 *
	 * @param riot The DICE layer 0 handler to query.
	 * @param oid A custom OID to add to the Extended Key Usage extension of the CSR.  This is
	 * optional and can be set to null.
	 * @param oid_length Length of the custom EKU OID to add.
	 * @param csr Output for the CSR data.  This will be DER encoded in a dynamically allocated
	 * buffer.  It is the caller's responsibility to free the buffer.
	 * @param length Output for the length of the CSR data.
	 *
	 * @return 0 if the CSR was successfully retrieved or an error code.
	 */
	int (*get_device_id_csr) (const struct riot_core *riot, const uint8_t *oid, size_t oid_length,
		uint8_t **csr, size_t *length);

	/**
	 * Get the X.509 certificate for the Device ID.  This certificate will be self-signed.
	 *
	 * @param riot The DICE layer 0 handler to query.
	 * @param device_id Output for the certificate data.  This will be DER encoded in a dynamically
	 * allocated buffer.  It is the caller's responsibility to free the buffer.
	 * @param length Output for the length of the certificate data.
	 *
	 * @return 0 if the Device ID certificate was successfully retrieved or an error code.
	 */
	int (*get_device_id_cert) (const struct riot_core *riot, uint8_t **device_id, size_t *length);

	/**
	 * Generate the Alias key from the Firmware ID.  The Device ID must have already been
	 * generated.
	 *
	 * @param riot The DICE layer 0 handler.
	 * @param fwid The FWID value that should be used to derive the Alias key.
	 * @param length Length of the Alias FWID.
	 *
	 * @return 0 if the Alias Key was successfully generated or an error code.
	 */
	int (*generate_alias_key) (const struct riot_core *riot, const uint8_t *fwid, size_t length);

	/**
	 * Get the Alias private key.
	 *
	 * @param riot The DICE layer 0 handler to query.
	 * @param key Output for the private key.  This will be DER encoded in a dynamically allocated
	 * buffer.  It is the caller's responsibility to free the buffer.
	 * @param length The length of the key data.
	 *
	 * @return 0 if the Alias private key was successfully retrieved or an error code.
	 */
	int (*get_alias_key) (const struct riot_core *riot, uint8_t **key, size_t *length);

	/**
	 * Get the X.509 certificate for the Alias key.  This certificate will be signed by the Device
	 * ID.
	 *
	 * @param riot The DICE layer 0 handler to query.
	 * @param alias_key Output for the certificate data.  This will be DER encoded in a dynamically
	 * allocated buffer.  It is the caller's responsibility to free the buffer.
	 * @param length Output for the length of the certificate data.
	 *
	 * @return 0 if the Alias key certificate was successfully retrieved or an error code.
	 */
	int (*get_alias_key_cert) (const struct riot_core *riot, uint8_t **alias_key, size_t *length);
};


#define	RIOT_CORE_ERROR(code)		ROT_ERROR (ROT_MODULE_RIOT_CORE, code)

/**
 * Error codes that can be generated by RIoT Core.
 */
enum {
	RIOT_CORE_INVALID_ARGUMENT = RIOT_CORE_ERROR (0x00),		/**< Input parameter is null or not valid. */
	RIOT_CORE_NO_MEMORY = RIOT_CORE_ERROR (0x01),				/**< Memory allocation failed. */
	RIOT_CORE_NO_DEVICE_ID = RIOT_CORE_ERROR (0x02),			/**< No Device ID has been generated. */
	RIOT_CORE_NO_ALIAS_KEY = RIOT_CORE_ERROR (0x03),			/**< No Alias Key has been generated. */
	RIOT_CORE_BAD_FWID_LENGTH = RIOT_CORE_ERROR (0x04),			/**< The FWID is not the right length. */
	RIOT_CORE_NO_CDI = RIOT_CORE_ERROR (0x05),					/**< The CDI is not available for use. */
	RIOT_CORE_BAD_CDI = RIOT_CORE_ERROR (0x06),					/**< The CDI was determined to be invalid. */
	RIOT_CORE_UNSUPPORTED_KEY_LENGTH = RIOT_CORE_ERROR (0x07),	/**< The DICE key length is not supported. */
	RIOT_CORE_BAD_PATHLEN_CONSTRAINT = RIOT_CORE_ERROR (0x08),	/**< A DICE CA path length is not valid. */
};


#endif	/* RIOT_CORE_H_ */
