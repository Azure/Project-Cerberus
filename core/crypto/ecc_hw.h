// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#ifndef ECC_HW_H_
#define ECC_HW_H_

#include <stddef.h>
#include <stdint.h>
#include "platform_api.h"
#include "crypto/ecc.h"
#include "crypto/rng.h"
#include "status/rot_status.h"


/**
 * Driver interface to an ECC hardware accelerator.
 */
struct ecc_hw {
	/**
	 * Generate the public key for a specified ECC private key.
	 *
	 * @param ecc_hw The ECC HW engine to use for calculating the key.
	 * @param priv_key The ECC private key.
	 * @param key_length Length of the private key.  This will determine the curve to use.
	 * @param pub_key Output buffer for the ECC public key.
	 *
	 * @return 0 if the public key was successfully generated or an error code.
	 */
	int (*get_ecc_public_key) (const struct ecc_hw *ecc_hw, const uint8_t *priv_key,
		size_t key_length, struct ecc_point_public_key *pub_key);

	/**
	 * Verify that the public key is valid.
	 *
	 * It can be guaranteed that the public key provided to this call is not the point at infinity,
	 * but no other validity checks can be assumed outside of this call.
	 *
	 * @param ecc_hw The ECC HW engine to use for public key validation.
	 * @param pub_key The public key to validate.
	 *
	 * @return 0 if the public key is valid or an error code.
	 */
	int (*verify_ecc_public_key) (const struct ecc_hw *ecc_hw,
		const struct ecc_point_public_key *pub_key);

	/**
	 * Generate a random ECC key pair.
	 *
	 * @param ecc_hw The ECC HW engine to use for generating the key pair.
	 * @param key_length Length of the private key to generate.  This will determine the key length
	 * and curve to use for generation.
	 * @param priv_key Output buffer for the generated private key.
	 * @param pub_key Output buffer for the ECC public key
	 *
	 * @return 0 if the key was successfully generated or an error code.
	 */
	int (*generate_ecc_key_pair) (const struct ecc_hw *ecc_hw, size_t key_length, uint8_t *priv_key,
		struct ecc_point_public_key *pub_key);

	/**
	 * Generate an ECDSA signature for a digest using an ECC private key.
	 *
	 * @param ecc_hw The ECC HW engine to use for generating the signature.
	 * @param priv_key The ECC private key.
	 * @param key_length Length of the private key.  This will determine the curve to use.
	 * @param digest The digest to generate the signature for.
	 * @param digest_length Length of the digest.
	 * @param rng The random number generator to use for generating the random 'r' value in the
	 * signature.  If this is null, the ECC instance will use a default RNG for this operation, if
	 * one is available to the instance.
	 * @param signature Output buffer for the ECDSA signature.
	 *
	 * @return 0 if the signature was successfully generated or an error code.
	 */
	int (*ecdsa_sign) (const struct ecc_hw *ecc_hw, const uint8_t *priv_key, size_t key_length,
		const uint8_t *digest, size_t digest_length, const struct rng_engine *rng,
		struct ecc_ecdsa_signature *signature);

	/**
	 * Verify an ECDSA signature for a digest using an ECC public key.
	 *
	 * @param ecc_hw The ECC HW engine to use for verifying the signature.
	 * @param pub_key The ECC public key.
	 * @param signature The signature to use for verification.
	 * @param digest The digest to verify.
	 * @param digest_length Length of the digest.
	 *
	 * @return 0 if the signature is valid or an error code.
	 */
	int (*ecdsa_verify) (const struct ecc_hw *ecc_hw, const struct ecc_point_public_key *pub_key,
		const struct ecc_ecdsa_signature *signature, const uint8_t *digest, size_t digest_length);

	/**
	 * Compute the ECDH shared secret for a pair of ECC keys.
	 *
	 * @param ecc_hw The ECC HW engine that will execute the ECDH exchange.
	 * @param priv_key The ECC private key to use for the exchange.
	 * @param key_length Length of the private key.  This will determine the curve to use.
	 * @param pub_key The ECC public key to use for the exchange.
	 * @param secret Output buffer for the ECDH shared secret for the keys.  This will be the same
	 * length as the private key.
	 * @param length Size of the shared secret output buffer.
	 *
	 * @return 0 if the shared secret was successfully calculated or an error code.
	 */
	int (*ecdh_compute) (const struct ecc_hw *ecc_hw, const uint8_t *priv_key, size_t key_length,
		const struct ecc_point_public_key *pub_key, uint8_t *secret, size_t length);
};


#define	ECC_HW_ERROR(code)		ROT_ERROR (ROT_MODULE_ECC_HW, code)

/**
 * Error codes that can be generated by the ECC HW.
 */
enum {
	ECC_HW_INVALID_ARGUMENT = ECC_HW_ERROR (0x00),			/**< Input parameter is null or not valid. */
	ECC_HW_NO_MEMORY = ECC_HW_ERROR (0x01),					/**< Memory allocation failed. */
	ECC_HW_ECC_PUBLIC_FAILED = ECC_HW_ERROR (0x02),			/**< Failed to calculate an ECC public key. */
	ECC_HW_ECC_GENERATE_FAILED = ECC_HW_ERROR (0x03),		/**< Failed to generate a random ECC key pair. */
	ECC_HW_ECDSA_SIGN_FAILED = ECC_HW_ERROR (0x04),			/**< Failed to generate an ECDSA signature. */
	ECC_HW_ECDSA_VERIFY_FAILED = ECC_HW_ERROR (0x05),		/**< Failed to verify an ECDSA signature. */
	ECC_HW_ECDH_COMPUTE_FAILED = ECC_HW_ERROR (0x06),		/**< Failed to compute an ECDH secret. */
	ECC_HW_MONT_CONST_FAILED = ECC_HW_ERROR (0x07),			/**< Montgomery constant calculation failed. */
	ECC_HW_INVALID_ADDRESS = ECC_HW_ERROR (0x08),			/**< A buffer is not in memory accessible to the hardware. */
	ECC_HW_CMD_NOT_STARTED = ECC_HW_ERROR (0x09),			/**< The ECC HW did not accept a submitted command. */
	ECC_HW_ADDRESS_NOT_ALIGNED = ECC_HW_ERROR (0x0a),		/**< A buffer address is not word aligned. */
	ECC_HW_ECDSA_BAD_SIGNATURE = ECC_HW_ERROR (0x0b),		/**< An ECDSA signature is not valid for the digest. */
	ECC_HW_UNSUPPORTED_KEY_LENGTH = ECC_HW_ERROR (0x0c),	/**< The private key length is not supported. */
	ECC_HW_PUBLIC_KEY_TOO_SMALL = ECC_HW_ERROR (0x0d),		/**< The public key buffer is too small for the key length. */
	ECC_HW_DIGEST_TOO_LONG = ECC_HW_ERROR (0x0e),			/**< The digest is too long for the key length. */
	ECC_HW_SIGNATURE_TOO_SMALL = ECC_HW_ERROR (0x0f),		/**< The ECDSA signature buffer is too small for the key length. */
	ECC_HW_ECDH_TOO_SMALL = ECC_HW_ERROR (0x10),			/**< The ECDH secret buffer is too small for the key length. */
	ECC_HW_SIGNATURE_WRONG_LENGTH = ECC_HW_ERROR (0x11),	/**< An ECDSA signature does not match the public key length. */
	ECC_HW_PUBLIC_WRONG_LENGTH = ECC_HW_ERROR (0x12),		/**< An ECC public key does not match the private key length. */
	ECC_HW_SELF_TEST_FAILED = ECC_HW_ERROR (0x13),			/**< A self-test of the ECC HW failed. */
	ECC_HW_FREE_CHECK_FAILED = ECC_HW_ERROR (0x14),			/**< An error occurred while checking if ECC HW is free. */
	ECC_HW_MEM_WIPE_FAILED = ECC_HW_ERROR (0x15),			/**< An error occurred while attempting to wipe internal memory for the ECC hardware. */
	ECC_HW_UNSUPPORTED_OP = ECC_HW_ERROR (0x16),			/**< The ECC HW does not support this command. */
	ECC_HW_INT_TO_MONT_FAILED = ECC_HW_ERROR (0x17),		/**< Failed to convert to Montgomery representation. */
	ECC_HW_MONT_TO_INT_FAILED = ECC_HW_ERROR (0x18),		/**< Failed to convert from Montgomery representation. */
	ECC_HW_MOD_INVERSE_FAILED = ECC_HW_ERROR (0x19),		/**< Failed a modular inversion calculation. */
	ECC_HW_MOD_MULTIPLY_FAILED = ECC_HW_ERROR (0x1a),		/**< Failed a modular multiplication. */
	ECC_HW_MOD_ADD_FAILED = ECC_HW_ERROR (0x1b),			/**< Failed a modular addition. */
	ECC_HW_MOD_REDUCE_FAILED = ECC_HW_ERROR (0x1c),			/**< Failed a modular reduction. */
	ECC_HW_PRIV_KEY_GEN_FAILED = ECC_HW_ERROR (0x1d),		/**< Failed to generate a valid private key for the curve. */
	ECC_HW_VERIFY_PUBLIC_FAILED = ECC_HW_ERROR (0x1e),		/**< Failed to verify an ECC public key. */
	ECC_HW_INVALID_PUBLIC_KEY = ECC_HW_ERROR (0x1f),		/**< The ECC public key is not valid. */

	/* Error codes >0x80 are reserved for reporting HW status bits. */
};


#endif	/* ECC_HW_H_ */
