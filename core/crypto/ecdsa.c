// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <string.h>
#include "ecc.h"
#include "ecdsa.h"
#include "common/buffer_util.h"


/**
 * Instantiate an HMAC_DRBG per RFC 6979 that can be used for generating the k value needed for
 * ECDSA signatures in a deterministic way.
 *
 * @param hash The hash engine to used for HMAC operations.
 * @param hmac_algo The HMAC algorithm that should be used by the DRBG.
 * @param message_digest Digest of the message that is being signed with ECDSA.  This can be either
 * the raw digest of the message data or the truncated/padded version used during signature
 * generation.
 * @param digest_length Length of the message digest.
 * @param priv_key The private key being used to sign the message.
 * @param key_length Length of the private key.
 * @param drbg Output for the instantiated ECDSA DRBG.  This must be wiped using
 * ecdsa_deterministic_k_drbg_clear after the signing process has completed.
 *
 * @return 0 if the ECDSA DRBG was instantiated successfully or an error code.
 */
int ecdsa_deterministic_k_drbg_instantiate (struct hash_engine *hash, enum hmac_hash hmac_algo,
	const uint8_t *message_digest, size_t digest_length, const uint8_t *priv_key, size_t key_length,
	struct ecdsa_deterministic_k_drbg *drbg)
{
	struct hmac_engine hmac;
	int hash_length;
	uint8_t internal_octet;
	int status;

	if ((hash == NULL) || (message_digest == NULL) || (priv_key == NULL) || (drbg == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	hash_length = hash_hmac_get_hmac_length (hmac_algo);
	if (hash_length == HASH_ENGINE_UNKNOWN_HASH) {
		return hash_length;
	}

	/* Set the initial values for K (0's) and V (1's). */
	memset (drbg->key, 0, sizeof (drbg->key));
	memset (drbg->value, 1, sizeof (drbg->value));
	drbg->first = true;
	drbg->hmac_algo = hmac_algo;

	for (internal_octet = 0; internal_octet < 2; internal_octet++) {
		/* Derive a new K from the private key and message digest. */
		status = hash_hmac_init (&hmac, hash, hmac_algo, drbg->key, hash_length);
		if (status != 0) {
			goto erase_context;
		}

		status = hash_hmac_update (&hmac, drbg->value, hash_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, &internal_octet, 1);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, priv_key, key_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, message_digest, digest_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_finish (&hmac, drbg->key, sizeof (drbg->key));
		if (status != 0) {
			goto erase_context;
		}

		/* Derive the new V using the updated K. */
		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			goto erase_context;
		}
	}

	return 0;

hmac_cancel:
	hash_hmac_cancel (&hmac);

erase_context:
	buffer_zeroize (drbg, sizeof (*drbg));

	return status;
}

/**
 * Generate a k value that can be used for ECDSA signatures following the deterministic generation
 * algorithm specified in RFC 6979.  ecdsa_instantiate_deterministic_k_drbg must be called prior to
 * generating any k values.
 *
 * No checking of the resultant value against curve order is done, nor is it proven to generate a
 * valid r value.  It is up to the caller to ensure the generated k value is valid and call this
 * function again if a new k is needed.
 *
 * If this call fails, the DRBG is left in an indeterminate state.  The DRBG context should be
 * cleared and reinstantiated for additional attempts to generate a k value.
 *
 * @param hash The hash engine to use for HMAC operations.
 * @param drbg The instantiated DRBG to use for k generation.  The DRBG context will be updated,
 * allowing for multiple calls to be made if invalid k values are produced.
 * @param k Output for the k value generated by the DRBG.
 * @param k_length The number of bytes to generate for k.
 *
 * @return 0 if k was generated successfully or an error code.
 */
int ecdsa_deterministic_k_drbg_generate (struct hash_engine *hash,
	struct ecdsa_deterministic_k_drbg *drbg, uint8_t *k, size_t k_length)
{
	struct hmac_engine hmac;
	uint8_t zero = 0x00;
	int hash_length;
	uint8_t *pos = k;
	size_t remaining = k_length;
	int status;

	if ((hash == NULL) || (drbg == NULL) || (k == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	hash_length = hash_hmac_get_hmac_length (drbg->hmac_algo);
	if (hash_length == HASH_ENGINE_UNKNOWN_HASH) {
		return hash_length;
	}

	if (!drbg->first) {
		/* For subsequent requests, new K and V values need to be calculated. */
		status = hash_hmac_init (&hmac, hash, drbg->hmac_algo, drbg->key, hash_length);
		if (status != 0) {
			return status;
		}

		status = hash_hmac_update (&hmac, drbg->value, hash_length);
		if (status != 0) {
			hash_hmac_cancel (&hmac);

			return status;
		}

		status = hash_hmac_update (&hmac, &zero, 1);
		if (status != 0) {
			hash_hmac_cancel (&hmac);

			return status;
		}

		status = hash_hmac_finish (&hmac, drbg->key, sizeof (drbg->key));
		if (status != 0) {
			return status;
		}

		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			drbg->hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			return status;
		}
	}

	drbg->first = false;

	while (remaining > 0) {
		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			drbg->hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			return status;
		}

		pos += buffer_copy (drbg->value, hash_length, NULL, &remaining, pos);
	}

	/* This does not strictly follow the RFC for ECC-521 keys.  Since the key length is not an even
	 * multiple of bytes, 7 bits need to get dropped from the generated data.  Per the RFC, this
	 * would be the last 7 bits, but that would require right shifting the entire array.  Instead,
	 * a shortcut is taken by just masking out the first 7 bits that are generated. */
	if (k_length == ECC_KEY_LENGTH_521) {
		k[0] &= 0x01;
	}

	return 0;
}

/**
 * Erase the DRBG context used for ECDSA signature k generation.
 *
 * @param drbg The DRBG context to clear.
 */
void ecdsa_deterministic_k_drbg_clear (struct ecdsa_deterministic_k_drbg *drbg)
{
	buffer_zeroize (drbg, sizeof (*drbg));
}

/**
 * Generate an ECDSA signature for a specified message using an ECC hardware implementation.
 *
 * @param ecc_hw The ECC hardware instance to use for signature generation.
 * @param hash The hash engine that will be used to calculate the message digest.
 * @param hash_algo Algorithm that should be used for message hashing.
 * @param rng The random number generator that will be used to generate the random 'r' value in the
 * signature.  If this is null, the ECC hardware instance will use a default RNG, if one is
 * available.
 * @param priv_key Raw ECC private key to use for signing.
 * @param key_length Length of the ECC private key.  This will determine the curve to use.
 * @param message The raw message data that should be signed.
 * @param msg_length Length of the message.
 * @param signature Output buffer for the ECDSA signature.
 *
 * @return 0 if the signature was generated successfully or an error code.
 */
int ecdsa_ecc_hw_sign_message (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, struct rng_engine *rng, const uint8_t *priv_key, size_t key_length,
	const uint8_t *message, size_t msg_length, struct ecc_ecdsa_signature *signature)
{
	int status;

	if ((ecc_hw == NULL) || (hash == NULL) || (priv_key == NULL) || (message == NULL) ||
		(signature == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	status = hash_start_new_hash (hash, hash_algo);
	if (status != 0) {
		return status;
	}

	status = hash->update (hash, message, msg_length);
	if (status != 0) {
		hash->cancel (hash);
		return status;
	}

	return ecdsa_ecc_hw_sign_hash_and_finish (ecc_hw, hash, hash_algo, rng, priv_key, key_length,
		signature);
}

/**
 * Generate an ECDSA signature for an active hash context using an ECC hardware implementation.
 *
 * The hash context will remain active after signature generation, allowing additional updates to be
 * made.  Not all hash implementations support this type of behavior, so it should only be used in
 * scenarios which require it.  Most scenarios should use ecdsa_ecc_hw_sign_hash_and_finish instead.
 *
 * @param ecc_hw The ECC hardware instance to use for signature generation.
 * @param hash The hash engine that contains the active context to sign.
 * @param hash_algo Hash algorithm being used by the active context.
 * @param rng The random number generator that will be used to generate the random 'r' value in the
 * signature.  If this is null, the ECC hardware instance will use a default RNG, if one is
 * available.
 * @param priv_key Raw ECC private key to use for signing.
 * @param key_length Length of the ECC private key.  This will determine the curve to use.
 * @param signature Output buffer for the ECDSA signature.
 *
 * @return 0 if the signature was generated successfully or an error code.
 */
int ecdsa_ecc_hw_sign_hash (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, struct rng_engine *rng, const uint8_t *priv_key, size_t key_length,
	struct ecc_ecdsa_signature *signature)
{
	uint8_t digest[HASH_MAX_HASH_LEN];
	size_t digest_length;
	int status;

	if ((ecc_hw == NULL) || (hash == NULL) || (priv_key == NULL) || (signature == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	digest_length = hash_get_hash_length (hash_algo);
	if (digest_length == HASH_ENGINE_UNKNOWN_HASH) {
		return HASH_ENGINE_UNKNOWN_HASH;
	}

	status = hash->get_hash (hash, digest, sizeof (digest));
	if (status != 0) {
		return status;
	}

	return ecc_hw->ecdsa_sign (ecc_hw, priv_key, key_length, digest, digest_length, rng, signature);
}

/**
 * Generate an ECDSA signature for an active hash context using an ECC hardware implementation.
 *
 * The hash context will be finished as part of signature generation.  No additional updates can be
 * made to the hash context, regardless of whether the signature generation was successful or not.
 *
 * @param ecc_hw The ECC hardware instance to use for signature generation.
 * @param hash The hash engine that contains the active context to sign.  The active context will
 * always be terminated upon returning from this call.
 * @param hash_algo Hash algorithm being used by the active context.
 * @param rng The random number generator that will be used to generate the random 'r' value in the
 * signature.  If this is null, the ECC hardware instance will use a default RNG, if one is
 * available.
 * @param priv_key Raw ECC private key to use for signing.
 * @param key_length Length of the ECC private key.  This will determine the curve to use.
 * @param signature Output buffer for the ECDSA signature.
 *
 * @return 0 if the signature was generated successfully or an error code.
 */
int ecdsa_ecc_hw_sign_hash_and_finish (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, struct rng_engine *rng, const uint8_t *priv_key, size_t key_length,
	struct ecc_ecdsa_signature *signature)
{
	uint8_t digest[HASH_MAX_HASH_LEN];
	size_t digest_length;
	int status;

	if (hash == NULL) {
		return ECDSA_INVALID_ARGUMENT;
	}

	if ((ecc_hw == NULL) || (priv_key == NULL) || (signature == NULL)) {
		status = ECDSA_INVALID_ARGUMENT;
		goto hash_cancel;
	}

	digest_length = hash_get_hash_length (hash_algo);
	if (digest_length == HASH_ENGINE_UNKNOWN_HASH) {
		status = digest_length;
		goto hash_cancel;
	}

	status = hash->finish (hash, digest, sizeof (digest));
	if (status != 0) {
		goto hash_cancel;
	}

	return ecc_hw->ecdsa_sign (ecc_hw, priv_key, key_length, digest, digest_length, rng, signature);

hash_cancel:
	hash->cancel (hash);

	return status;
}

/**
 * Verify a specified message with an ECDSA signature using an ECC hardware implementation.
 *
 * @param ecc_hw The ECC hardware instance to use for signature verification.
 * @param hash The hash engine that will be used to calculate the message digest.
 * @param hash_algo Algorithm that should be used for message hashing.
 * @param message The raw message data that should be verified.
 * @param msg_length Length of the message.
 * @param pub_key Public key to use for verification.  The key length will determine the curve to
 * use.
 * @param signature The ECDSA signature for the message data.
 *
 * @return 0 if the message was verified successfully or an error code.
 */
int ecdsa_ecc_hw_verify_message (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, const uint8_t *message, size_t msg_length,
	const struct ecc_point_public_key *pub_key, const struct ecc_ecdsa_signature *signature)
{
	int status;

	if ((ecc_hw == NULL) || (hash == NULL) || (message == NULL) || (pub_key == NULL) ||
		(signature == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	status = hash_start_new_hash (hash, hash_algo);
	if (status != 0) {
		return status;
	}

	status = hash->update (hash, message, msg_length);
	if (status != 0) {
		hash->cancel (hash);
		return status;
	}

	return ecdsa_ecc_hw_verify_hash_and_finish (ecc_hw, hash, hash_algo, pub_key, signature);
}

/**
 * Verify an active hash context with an ECDSA signature using an ECC hardware implementation.
 *
 * The hash context will remain active after signature verification, allowing additional updates to
 * be made.  Not all hash implementations support this type of behavior, so it should only be used
 * in scenarios which require it.  Most scenarios should use ecdsa_ecc_hw_verify_hash_and_finish
 * instead.
 *
 * @param ecc_hw The ECC hardware instance to use for signature verification.
 * @param hash The hash engine that contains the active context to verify.
 * @param hash_algo Hash algorithm being used by the active context.
 * @param pub_key Public key to use for verification.  The key length will determine the curve to
 * use.
 * @param signature The ECDSA signature for the hash context.
 *
 * @return 0 if the hash was verified successfully or an error code.
 */
int ecdsa_ecc_hw_verify_hash (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, const struct ecc_point_public_key *pub_key,
	const struct ecc_ecdsa_signature *signature)
{
	uint8_t digest[HASH_MAX_HASH_LEN];
	size_t digest_length;
	int status;

	if ((ecc_hw == NULL) || (hash == NULL) || (pub_key == NULL) || (signature == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	digest_length = hash_get_hash_length (hash_algo);
	if (digest_length == HASH_ENGINE_UNKNOWN_HASH) {
		return HASH_ENGINE_UNKNOWN_HASH;
	}

	status = hash->get_hash (hash, digest, sizeof (digest));
	if (status != 0) {
		return status;
	}

	return ecc_hw->ecdsa_verify (ecc_hw, pub_key, signature, digest, digest_length);
}

/**
 * Verify an active hash context with an ECDSA signature using an ECC hardware implementation.
 *
 * The hash context will be finished as part of signature verification.  No additional updates can
 * be made to the hash context, regardless of whether the signature verification was successful or
 * not.
 *
 * @param ecc_hw The ECC hardware instance to use for signature verification.
 * @param hash The hash engine that contains the active context to verify.  The active context will
 * always be terminated upon returning from this call.
 * @param hash_algo Hash algorithm being used by the active context.
 * @param pub_key Public key to use for verification.  The key length will determine the curve to
 * use.
 * @param signature The ECDSA signature for the hash context.
 *
 * @return 0 if the hash was verified successfully or an error code.
 */
int ecdsa_ecc_hw_verify_hash_and_finish (const struct ecc_hw *ecc_hw, struct hash_engine *hash,
	enum hash_type hash_algo, const struct ecc_point_public_key *pub_key,
	const struct ecc_ecdsa_signature *signature)
{
	uint8_t digest[HASH_MAX_HASH_LEN];
	size_t digest_length;
	int status;

	if (hash == NULL) {
		return ECDSA_INVALID_ARGUMENT;
	}

	if ((ecc_hw == NULL) || (pub_key == NULL) || (signature == NULL)) {
		status = ECDSA_INVALID_ARGUMENT;
		goto hash_cancel;
	}

	digest_length = hash_get_hash_length (hash_algo);
	if (digest_length == HASH_ENGINE_UNKNOWN_HASH) {
		status = digest_length;
		goto hash_cancel;
	}

	status = hash->finish (hash, digest, sizeof (digest));
	if (status != 0) {
		goto hash_cancel;
	}

	return ecc_hw->ecdsa_verify (ecc_hw, pub_key, signature, digest, digest_length);

hash_cancel:
	hash->cancel (hash);

	return status;
}
