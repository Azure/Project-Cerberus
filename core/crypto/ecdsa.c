// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.

#include <string.h>
#include "ecc.h"
#include "ecdsa.h"
#include "common/buffer_util.h"


/**
 * Instantiate an HMAC_DRBG per RFC 6979 that can be used for generating the k value needed for
 * ECDSA signatures in a deterministic way.
 *
 * @param hash The hash engine to used for HMAC operations.
 * @param hmac_algo The HMAC algorithm that should be used by the DRBG.
 * @param message_digest Digest of the message that is being signed with ECDSA.  This can be either
 * the raw digest of the message data or the truncated/padded version used during signature
 * generation.
 * @param digest_length Length of the message digest.
 * @param priv_key The private key being used to sign the message.
 * @param key_length Length of the private key.
 * @param drbg Output for the instantiated ECDSA DRBG.  This must be wiped using
 * ecdsa_deterministic_k_drbg_clear after the signing process has completed.
 *
 * @return 0 if the ECDSA DRBG was instantiated successfully or an error code.
 */
int ecdsa_deterministic_k_drbg_instantiate (struct hash_engine *hash, enum hmac_hash hmac_algo,
	const uint8_t *message_digest, size_t digest_length, const uint8_t *priv_key, size_t key_length,
	struct ecdsa_deterministic_k_drbg *drbg)
{
	struct hmac_engine hmac;
	int hash_length;
	uint8_t internal_octet;
	int status;

	if ((hash == NULL) || (message_digest == NULL) || (priv_key == NULL) || (drbg == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	hash_length = hash_hmac_get_hmac_length (hmac_algo);
	if (hash_length == HASH_ENGINE_UNKNOWN_HASH) {
		return hash_length;
	}

	/* Set the initial values for K (0's) and V (1's). */
	memset (drbg->key, 0, sizeof (drbg->key));
	memset (drbg->value, 1, sizeof (drbg->value));
	drbg->first = true;
	drbg->hmac_algo = hmac_algo;

	for (internal_octet = 0; internal_octet < 2; internal_octet++) {
		/* Derive a new K from the private key and message digest. */
		status = hash_hmac_init (&hmac, hash, hmac_algo, drbg->key, hash_length);
		if (status != 0) {
			goto erase_context;
		}

		status = hash_hmac_update (&hmac, drbg->value, hash_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, &internal_octet, 1);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, priv_key, key_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_update (&hmac, message_digest, digest_length);
		if (status != 0) {
			goto hmac_cancel;
		}

		status = hash_hmac_finish (&hmac, drbg->key, sizeof (drbg->key));
		if (status != 0) {
			goto erase_context;
		}

		/* Derive the new V using the updated K. */
		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			goto erase_context;
		}
	}

	return 0;

hmac_cancel:
	hash_hmac_cancel (&hmac);

erase_context:
	buffer_zeroize (drbg, sizeof (*drbg));

	return status;
}

/**
 * Generate a k value that can be used for ECDSA signatures following the deterministic generation
 * algorithm specified in RFC 6979.  ecdsa_instantiate_deterministic_k_drbg must be called prior to
 * generating any k values.
 *
 * No checking of the resultant value against curve order is done, nor is it proven to generate a
 * valid r value.  It is up to the caller to ensure the generated k value is valid and call this
 * function again if a new k is needed.
 *
 * If this call fails, the DRBG is left in an indeterminate state.  The DRBG context should be
 * cleared and reinstantiated for additional attempts to generate a k value.
 *
 * @param hash The hash engine to use for HMAC operations.
 * @param drbg The instantiated DRBG to use for k generation.  The DRBG context will be updated,
 * allowing for multiple calls to be made if invalid k values are produced.
 * @param k Output for the k value generated by the DRBG.
 * @param k_length The number of bytes to generate for k.
 *
 * @return 0 if k was generated successfully or an error code.
 */
int ecdsa_deterministic_k_drbg_generate (struct hash_engine *hash,
	struct ecdsa_deterministic_k_drbg *drbg, uint8_t *k, size_t k_length)
{
	struct hmac_engine hmac;
	uint8_t zero = 0x00;
	int hash_length;
	uint8_t *pos = k;
	size_t remaining = k_length;
	int status;

	if ((hash == NULL) || (drbg == NULL) || (k == NULL)) {
		return ECDSA_INVALID_ARGUMENT;
	}

	hash_length = hash_hmac_get_hmac_length (drbg->hmac_algo);
	if (hash_length == HASH_ENGINE_UNKNOWN_HASH) {
		return hash_length;
	}

	if (!drbg->first) {
		/* For subsequent requests, new K and V values need to be calculated. */
		status = hash_hmac_init (&hmac, hash, drbg->hmac_algo, drbg->key, hash_length);
		if (status != 0) {
			return status;
		}

		status = hash_hmac_update (&hmac, drbg->value, hash_length);
		if (status != 0) {
			hash_hmac_cancel (&hmac);

			return status;
		}

		status = hash_hmac_update (&hmac, &zero, 1);
		if (status != 0) {
			hash_hmac_cancel (&hmac);

			return status;
		}

		status = hash_hmac_finish (&hmac, drbg->key, sizeof (drbg->key));
		if (status != 0) {
			return status;
		}

		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			drbg->hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			return status;
		}
	}

	drbg->first = false;

	while (remaining > 0) {
		status = hash_generate_hmac (hash, drbg->key, hash_length, drbg->value, hash_length,
			drbg->hmac_algo, drbg->value, sizeof (drbg->value));
		if (status != 0) {
			return status;
		}

		pos += buffer_copy (drbg->value, hash_length, NULL, &remaining, pos);
	}

	/* This does not strictly follow the RFC for ECC-521 keys.  Since the key length is not an even
	 * multiple of bytes, 7 bits need to get dropped from the generated data.  Per the RFC, this
	 * would be the last 7 bits, but that would require right shifting the entire array.  Instead,
	 * a shortcut is taken by just masking out the first 7 bits that are generated. */
	if (k_length == ECC_KEY_LENGTH_521) {
		k[0] &= 0x01;
	}

	return 0;
}

/**
 * Erase the DRBG context used for ECDSA signature k generation.
 *
 * @param drbg The DRBG context to clear.
 */
void ecdsa_deterministic_k_drbg_clear (struct ecdsa_deterministic_k_drbg *drbg)
{
	buffer_zeroize (drbg, sizeof (*drbg));
}
